<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园 - ShaoJia</title>
  <subtitle type="text">博客备份 - cnblogs_blog_shaojia.20240227200454</subtitle>
  <id>uuid:8e8ae69e-5d03-4e42-9fe3-119a4a6d1924;id=30</id>
  <updated>2024-02-27T12:37:39Z</updated>
  <author>
    <name>ShaoJia</name>
    <uri>https://www.cnblogs.com/shaojia</uri>
  </author>
  <link rel="alternate" href="https://www.cnblogs.com/shaojia" />
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531773.html</id>
    <title type="text">盒子放球问题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:03:00Z</published>
    <updated>2021-03-14T03:03:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531773.html" />
    <content type="text"># 头-大-问-题
共分8种情况：
球-盒-空
1:相同/允许空
2:不同/不许空
1-1-1 n个相同的球放入m个相同的盒子中,可允许空盒子

1-1-2 n个相同的球放入m个相同的盒子中,不允许空盒子

1-2-1 n个相同的球放入m个不同的盒子中,可允许空盒子

1-2-2 n个相同的球放入m个不同的盒子中,不允许空盒子

2-1-1 n个不同的球放入m个相同的盒子中,可允许空盒子

2-1-2 n个不同的球放入m个相同的盒子中,不允许空盒子

2-2-1 n个不同的球放入m个不同的盒子中,可允许空盒子

2-2-2 n个不同的球放入m个不同的盒子中,不允许空盒子
注:第二类Stirling数$\begin{Bmatrix}n\\m\end{Bmatrix}$,其表示将n个不同的元素分成m个集合的方案数
通项公式(记不住):

$\begin{Bmatrix}n\\m\end{Bmatrix}=\dfrac{1}{m!}\sum\limits_{k=0}^m\left[(-1)^kC_m^k(m-k)^n\right]$

递推公式出场:

(1)如果$n-1$个元素构成了$m-1$个集合，那么第$n$个元素单独构成一个集合。方案数$\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$

(2)如果$n-1$个元素已经构成了$m$个集合，将第$n$个元素插入到任意一个集合。方案数$m\cdot\begin{Bmatrix}n-1\\m\end{Bmatrix}$。

综合两种情况得：

$\begin{Bmatrix}0\\0\end{Bmatrix}=1$

$\begin{Bmatrix}n\\0\end{Bmatrix}=0(n\in N^*)$

$\begin{Bmatrix}n\\m\end{Bmatrix}=\begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m\cdot\begin{Bmatrix}n-1\\m\end{Bmatrix}$
## §1-1-1§
$F_{n,m}$ 为 $G_x$ 中 $x^n$ 的系数

$G_x=\dfrac{1}{(1-x)(1-x^2)...(1-x^m)}$

$G_x$就是[无序分拆数](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E5%88%86%E6%8B%86/91991?fromtitle=%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86&amp;fromid=15991027&amp;fr=aladdin)
## §1-1-2§
$F_{n,m}$ 为 $H_x$ 中 $x^n$ 的系数

$H_x=\dfrac{x^m}{(1-x)(1-x^2)...(1-x^m)}$

$\Rightarrow H_x=\dfrac{1-(1-x^m)}{(1-x)(1-x^2)...(1-x^m)}$

$\Rightarrow H_x=\dfrac{1}{(1-x)(1-x^2)...(1-x^m)}-\dfrac{1}{(1-x)(1-x^2)...(1-x^{m-1})}$

$\Rightarrow H_x=G_x-G_{x-1}$

$H_x$就是 $2$ 个无序分拆数相减
## §1-2-1§
$F_{n,m}=C_{n+m-1}^n$
## §1-2-2§
$F_{n,m}=C_{m-1}^{n-1}$

隔板法
## §2-1-1§
$F_{n,m}=\sum\limits_{k=1}^m\begin{Bmatrix}n\\k\end{Bmatrix}$
## §2-1-2§
$F_{n,m}=\begin{Bmatrix}n\\m\end{Bmatrix}$
## §2-2-1§
$F_{n,m}=m^n$
## §2-2-2§
$F_{n,m}=m!\begin{Bmatrix}n\\m\end{Bmatrix}$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531788.html</id>
    <title type="text">重修 Fib斐波那契数列-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:07:00Z</published>
    <updated>2021-03-14T03:07:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531788.html" />
    <content type="text">## Fib

### 定义
$$
f_0=0,f_1=1,f_n=f_{n-1}+f_{n-2}
$$
### 从生成函数到通项公式

设生成函数为 $F(x)$。

由递推式得到
$$
F(x)=xF(x)+x^2F(x)+x
$$
乱搞得到
$$
F(x)=\frac{x}{1-x-x^2}
$$
即为 Fib 的生成函数。

为方便后面叙述，我们设两个黄金比例（Big Small）
$$\begin{aligned}
B&amp;=\frac{\sqrt5+1}{2}\sim1.618
\\
S&amp;=\frac{\sqrt5-1}{2}\sim0.618
\end{aligned}$$
有
$$
BS=1
\\
B+S=\sqrt5
$$
要求通项公式，考虑先将分母因式分解（二次方程的根）、裂项。
$$\begin{aligned}
F(x)&amp;=x\frac{1}{(x+B)(S-x)}
\\&amp;=\frac{x}{B+S}\cdot\frac{B+S}{(x+B)(S-x)}
\\&amp;=\frac{x}{\sqrt5}\left(\frac{1}{x+B}+\frac{1}{S-x}\right)
\end{aligned}$$
然后转为 $\frac{1}{1-x}$ 的形式，进而展开成无穷项
$$\begin{aligned}
F(x)&amp;=\frac{x}{\sqrt5}\left(\frac{S}{BS+Sx}+\frac{B}{BS-Bx}\right)
\\&amp;=\frac{x}{\sqrt5}\left(S\frac{1}{1+Sx}+B\frac{1}{1-Bx}\right)
\\&amp;=\frac{x}{\sqrt5}\left[
S\left(\sum_{i=0}^\infty(-Sx)^i\right)
+B\left(\sum_{i=0}^\infty(Bx)^i\right)
\right]
\\&amp;=\frac{1}{\sqrt5}\left[-\left(\sum_{i=1}^\infty(-Sx)^i\right)
+\left(\sum_{i=1}^\infty(Bx)^i\right)
\right]
\\&amp;=\sum_{i=1}^\infty\frac{1}{\sqrt5}\left(-(-S)^i+B^i\right)x^i
\\&amp;=\sum_{i=1}^\infty\frac{B^i-(-S)^i}{\sqrt5}x^i
\\&amp;=\sum_{i=0}^\infty\frac{B^i-(-S)^i}{\sqrt5}x^i
\end{aligned}$$
所以得到 $f_n$ 的通项公式
$$
f_n=\frac{B^n-(-S)^n}{\sqrt5}=\frac{\sqrt5}{5}\left[
\left(\frac{\sqrt5+1}{2}\right)^n
-\left(\frac{1-\sqrt5}{2}\right)^n
\right]
$$
### 模意义下循环节

模 $k$ 下循环节长度不超过 $6k$，我也不会证。

## 广义 Fib

### 定义
$$
f_x=\begin{cases}A&amp;x=1\\B&amp;x=2\\f_{x-1}+f_{x-2}&amp;x&gt;2\end{cases}
$$
### 前缀和
$$
\sum\limits_{i = 1}^{n} f_x = f_{n+2}-f_2
$$
证明：
$$\begin{aligned}
\sum\limits_{i = 1}^{n} f_x &amp;=\sum\limits_{i = 1}^{n} (f_{x+2}-f_{x+1})
\\&amp;=\sum\limits_{i = 3}^{n+2} f_x-\sum\limits_{i = 2}^{n+1} f_x
\\&amp;=f_{n+2}-f_2
\end{aligned}$$
### 矩阵快速幂
$$
\begin{bmatrix}
0&amp;1
\\
1&amp;1
\end{bmatrix}^{n-2}
\begin{bmatrix}
f_1
\\
f_2
\end{bmatrix}
=
\begin{bmatrix}
f_{n-1}
\\
f_n
\end{bmatrix}
$$
### 折半乘积
$$
f_{n+m}=f_{n}f_{m-1}+f_{n-1}f_{m}
$$
证明：
强归纳法。
$$\begin{aligned}
f_{n+m}=&amp;f_{n+m-1}+f_{n+m-2}
\\=&amp;(f_{n}f_{m-2}+f_{n-1}f_{m-1}）+
\\&amp;(f_{n}f_{m-3}+f_{n-1}f_{m-2}）
\\=&amp;f_{n}(f_{m-2}+f_{m-3})+
\\&amp;f_{n-1}(f_{m-1}+f_{m-2})
\\=&amp;f_{n}f_{m-1}+f_{n-1}f_{m}
\end{aligned}$$
其实在分裂重组。
### gcd(1)
$$
\gcd(f_1,f_2)=1\implies\gcd(f_{n-1},f_{n})=1
$$
证明：
$$\begin{aligned}
\gcd(f_1,f_2)=1&amp;\implies\gcd(f_1+f_2,f_2)=1
\\&amp;\implies\gcd(f_2,f_3)=1
\\&amp;\implies\dots
\\&amp;\implies\gcd(f_{n-1},f_{n})=1
\end{aligned}$$
### gcd(2)
$$
\gcd(f_1,f_2)=1\implies\gcd(f_n,f_m)=f_{\gcd(n,m)}
$$

证明：

当 $n=m$ 时显然成立。

不失一般性，设 $n&lt;m$。

$$\begin{aligned}
\gcd(f_n,f_m)&amp;=\gcd(f_n,f_nf_{m-n-1}+f_{n-1}f_{m-n})
\\&amp;=\gcd(f_n,f_{n-1}f_{m-n})
\\&amp;=\gcd(f_n,f_{m-n})
\end{aligned}$$

最后一步用到了 $\gcd(f_{n-1},f_{n})=1$。

然后就辗转相除得到了 $f_{\gcd(n,m)}$。

但是好像 $\text{lcm}$ 没有这样的结论。

### 特征根求通项

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221026092251558-290973873.png)

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221026092300089-1321194536.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531793.html</id>
    <title type="text">KMP-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:09:00Z</published>
    <updated>2021-03-14T03:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531793.html" />
    <content type="text">
# QUESTION：
## 有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？
# ANSWER:
## KMP
### step1:(真)前缀＆(真)后缀

| char | pre | suc | pre $\cap$ suc |
| :----------: | :----------: | :----------: | :----------: |
|  abc  |  a,ab  |  c,bc  |  $\varnothing$  |
|  abcba  |  a,ab,abc,abcb  |  a,ba,cba,bcba  | a |
|  ababa  |  a,ab,aba,abab  |  a,ba,aba,baba  | a,aba |
|  abcab  |  a,ab,abc,abca  |  b,ab,cab,bcab  | ab |
#### 设 $nxt[i]$ 为 $P[0]$~$P[i-1]$ 的 $pre \cap suc$ 中最长元素的长度
| P | a | b | a | b | a | b | c | a |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| nxt | -1 | 0 | 0 | 1 | 2 | 3 | 4 | 0 |
#### 好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找
e.g. 
```
S="ababababca"
P="abababca"
```
![](https://pic2.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_1440w.jpg?source=1940ef5c)
如果在 j 处字符不匹配，那么由于前边所说的 $P$ 字符串 $nxt$ 的性质，

$S[i-nxt[j]]$ ~ $S[i-1]=P[0]$ ~ $P[nxt[j]-1]$ (伪代码)

这是因为主字符串在 i 位失配，也就意味着

$S[i-j]$ ~ $S[i-1]=P[0]$ ~ $P[j-1]$ (伪代码)

在这个例子中就是

$S[i-j]$ ~ $S[i-1]=P[0]$ ~ $P[j-1]="ababab"$ (伪代码)

$pre \cap suc$ 的最长元素为 $"abab"$ ,长度为 $4$ 。

所以就可以断言，(a)图中两个灰色部分是相同的，即长度为   $4$ 的后缀与前缀相同。

#### 这样一来，我们就可以将灰色字符段的比较省略掉。

具体的做法是:(即变为(b)图)
```
i=i;
j=nxt[j];
```
具体函数：
```
int KMP() {
	int i = 0;
	int j = 0;
	while(i &lt; S.size() &amp;&amp; j &lt; P.size()) {
		if (j == -1 || S[i] == P[j]) 
			i++;
			j++;
		} else {
			j = nxt[j];
		}
	}
	if (j == P.size())
		return i - j;
	else
		return -1;
}
```

### 但是怎么求nxt？
### SO EASY
求 $nxt[i]$ 的过程完全可以看成字符串匹配的过程,即
```
newS=P;
newP=P.pre;//P的前缀皆可
```

一旦字符串匹配成功，那么当前的 $nxt[i]$ 值就是   $len($匹配$)$ 。

#### 具体来说，就是从$P$的第一位(注意，不包括第0位)开始对自身进行匹配运算。
![](https://pic2.zhimg.com/v2-645f3ec49836d3c680869403e74f7934_r.jpg?source=1940ef5c)
![](https://pic1.zhimg.com/v2-06477b79eadce2d7d22b4410b0d49aba_r.jpg?source=1940ef5c)
![](https://pic1.zhimg.com/v2-8a1a205df5cad7ab2f07498484a54a89_r.jpg?source=1940ef5c)
![](https://pic2.zhimg.com/v2-f2b50c15e7744a7b358154610204cc62_r.jpg?source=1940ef5c)
![](https://pic4.zhimg.com/v2-bd42e34a9266717b63706087a81092ac_r.jpg?source=1940ef5c)
```cpp
void getNxt()
{
	nxt[0] = -1;
	int i = 0, j = -1;

	while (i &lt; P.size())
	{
		if (j == -1 || P[i] == P[j])
		{
			i++;
			j++;
			nxt[i] = j;
		}	
		else
			j = nxt[j];
	}
}
```
D.E.**K**nuth
J.H.**M**orris
V.R.**P**ratt
三人联手打造**KMP**
KMP解决**字符串匹配问题**
(n为原串长度，m为匹配串长度)
蛮力算法:O(nm)
KMP:O(n+m)
![KMP.png](https://i.loli.net/2021/02/23/VwNfGCK2Mm14Zrh.png)
若在匹配中在图中蓝色位置**失配**
则匹配串要右移（假设原串与蓝框不动）
因为目标是让匹配串全部匹配，所以右移后让匹配串全部匹配的[必要条件](https://baike.baidu.com/item/%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/9706361?fr=aladdin)是**图中绿框串相等**(不相等的话直接GG)
为避免回溯，**绿框大小尽可能大**（但不碰蓝框），即**右移位移少**（保险）
### 理解如何求出$nxt[i]$
顺次扫描模式串P中每个元素，求出$nxt[i]$
当遍历到$i+1$时，$nxt[1]$至$nxt[i]$均已经求出
如图$O(Kn)$求出即可($K$为常数，图中相同颜色的矩形和相同的符号分别代表相同的子串和相同的字符)
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210715170322344-1703322730.png)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531831.html</id>
    <title type="text">约瑟夫环-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:19:00Z</published>
    <updated>2021-03-14T03:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531831.html" />
    <content type="text">**n个人围成一圈，选择一个正整数k，从第一个人开始从1报数，报到k的人被沙雕，在剩余的人中，从被拉出去那人下一个人开始，继续从1开始报数，报到k的人再被沙雕。如此循环，直至剩下最后一人。所以，对于每给定一组n和k，可以算得一个编号序列，序列中编号的位置表示这个人被沙雕的顺序。**
# 那么怎么求最后活着的人
$n,m\in N^* ,n&gt;1$

$F_{1,m}=0$

$F_{n,m}=(F_{n-1,m}+m)$%$n$

注：$F_{n,m}$(即每个人的编号)$=0,1,2\ldots(n-2),(n-1)$

$F_{n,m}$表示 $n$ 个人报数，每报到 $m$ 时杀掉那个人，最终活人的编号

$F_{n-1,m}$表示 $n-1$ 个人报数，每报到 $m$ 时杀掉那个人，最终活人的编号

### 特别地

当 $m=2$ 时

设$2^k\leqslant n&lt;2^{k+1}$

$F_{n,2}=2(n-2^k)+1$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531848.html</id>
    <title type="text">NOIP2012提高组初赛NB题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:22:00Z</published>
    <updated>2021-03-14T03:22:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531848.html" />
    <content type="text">**本题中，我们约定布尔表达式只能包含 p, q, r 三个布尔变量，以及“与”（∧）、“或”（∨）、“非”（¬）三种布尔运算。如果无论 p, q, r 如何取值，两个布尔表达式的值总是相同，则称它们等价。例如，(p∨q)∨r 和 p∨(q∨r)等价，p∨¬p 和 q∨¬q 也等价；而 p∨q 和 p∧q 不等价。那么，两两不等价的布尔表达式最多有___个。**

一看这题，人原地裂开

这不就是
`授人以鱼，考人以鱽鱾鲀鱿鲃鲂鲉鲌鲄鲆鲅鲇鲏鲊鲋鲐鲈鲍鲎鲝鲘鲙鲗鲓鲖鲞鲛鲒鲚鲜鲟鲔鲕鲑鲧鲬鲪鲫鲩鲣鲨鲡鲢鲤鲠鲥鲦鲺鲯鲹鲴鲶鲳鲮鲭鲵鲲鲰鲱鲻鲷鲸鳋鳊鳁鳀鲾鲼鳈鳉鳃鳄鲿鳇鳂鳆鳅鲽鳌鳒鳎鳏鳑鳐鳍鳘鳛鳕鳓鳙鳗鳚鳔鳖鳜鳟鳞鳝鳡鳠鳢鳣鳤。`
吗？

但，

正解：

**对于p、q、r三个变量，每个变量可取0,1两种取值，共有8种组合。**
**对于每种组合，代入表达式只有0和1两种答案。**
**因此两两不等价的表达式只有2^8=256种。**
**如果此题写出所有的逻辑表达式然后再去数，那你就上了出题人的当了，写半天再数半天却总免不了少几个或多几个。**
**反过来想，有n个元素，它们取“真”或“假”分别用“0”和“1”表示，那么n个元素取值情况就有 2^n 种，也就是n位的二进制数。**
**而 $2^n$ 种情况可对应于 $2^{2^n}$ 种不等价的逻辑表达式。**</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531868.html</id>
    <title type="text">C++优化列表-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:27:00Z</published>
    <updated>2021-03-14T03:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531868.html" />
    <content type="text">~~~
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
~~~
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14531875.html</id>
    <title type="text">tarjan算法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-03-14T03:30:00Z</published>
    <updated>2021-03-14T03:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14531875.html" />
    <content type="text">求强连通/割点/桥

### step1

将图深搜，形成深搜树，按遍历顺序标号-&gt;dfn[i]

### step2

将low[i]初始化为dfn[i]

### step3

回溯时low[i]=min(low[i],low[i的儿子])

### 判断

DFN［］作为这个点搜索的次序编号（时间戳）

LOW［］作为每个点在这颗树中的，子树根编号的最小值


------------
### 有向图中
如果找到DFN［］＝＝LOW［］就说明这个节点是这个**强连通分量**的根节点（毕竟这个LOW［］值是这个强连通分量里最小的。）


------------
### 无向图中
在深搜树中，如果对于某个点u，与它相连的点v（v不是u的父亲）。

如果 low[v]&gt;=dfn[u] , 那么也就是以v为根的深搜子树中的点所连接的点没有已经标记时间戳的。

也就是以v为根的子树是封闭的，那么一旦去掉点u,这棵子树中的点就称为了一个新的连通分量。

那么点u就是**割点**了。


若边 e （其对应的两个节点分别为 u 与 v）dfn[u] &lt; low[v]

我们发现从v节点出发,在不经过(u, v)的前提下,不管走哪一条边,

我们都无法抵达u节点,或者比u节点更早出现的节点,

此时我们发现v所在的子树似乎形成了一个封闭圈,那么(u, v)自然也就是**桥**了。

**桥的两端一定是割点**</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14618248.html</id>
    <title type="text">二元二次函数求最值-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-05T05:19:00Z</published>
    <updated>2021-04-05T05:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14618248.html" />
    <content type="text"># 题目：

求 $a^2-2ab+2b^2-2a-4b+27$ 的最小值。

## 解法一：

用十字相乘判断原式不为完全平方式（加常数）的形式。

用待定系数法设

$$a^2-2ab+2b^2-2a-4b+27=(x_1a+x_2b)^2+(x_3a+x_4)^2+(x_5b+x_6)^2+x_7$$

且存在 $a,b$ 使三个平方和为 $0$。

解得：

$$a^2-2ab+2b^2-2a-4b+27=(\dfrac{\sqrt{6}}{3}a-\dfrac{\sqrt{6}}{2}b)^2+(\dfrac{\sqrt{3}}{3}a-\sqrt{3})^2+(\dfrac{\sqrt{2}}{2}b-2\sqrt{2})^2+17$$

即 $\begin{cases}a=4\\b=3\end{cases}$ 时取到最小为 $17$。

## 解法二：

$$f(a,b)=a^2-2ab+2b^2-2a-4b+27=a^2+(-2b-2)a+(2b^2-4b+27)$$

此函数 $b$ 值固定时 $a=b+1$ 时取最小值(二次函数的最小值)

将其代入，得：

$$f(b+1,b)=b^2-6b+26$$

再次套用二次函数最值公式，得最小值为 $f(4,3)=17$。

原理为二元函数在空间中的图像（曲面）先纵剖，对每一个纵剖面求最小值，再在这些最小值（构成空间中的曲线）里求最小即可。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14640690.html</id>
    <title type="text">几何 三垂模型 及 正方形 及 弦图 及 jio拉jio模型 及 中位线-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-10T05:58:00Z</published>
    <updated>2021-04-10T05:58:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14640690.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Q:&lt;/strong&gt;&lt;/strong&gt;$AO\bot OB,AO=OB,CO\bot OD,CO=OD,BC\bot EF$ 求证 $E$ 为 $AD$ 中点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410214356324-715350854.png" alt="" width="369" height="313" loading="lazy" /&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;作如图 $AI\bot IH\bot HD$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410214420753-1783836052.png" alt="" width="433" height="347" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\because AO=OB,\angle AIO=\angle OFB,\angle IAO=\angle BOF$&lt;/p&gt;
&lt;p&gt;$\therefore \triangle AIO\cong \triangle BOF$&lt;/p&gt;
&lt;p&gt;$\therefore AI=OF$&lt;/p&gt;
&lt;p&gt;同理可得 $HD=OF=AI$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\triangle AIE\cong \triangle EHD$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;AE=ED$ 即&amp;nbsp;$E$ 为 $AD$ 中点&lt;/p&gt;
&lt;p&gt;此题图中左右两侧均为&lt;strong&gt;三垂模型&lt;/strong&gt;，可构造全等三角形&lt;/p&gt;
&lt;p&gt;接下来一道包含&lt;strong&gt;内三垂&lt;/strong&gt;和&lt;strong&gt;外三垂&lt;/strong&gt;的题目:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt;$AB\bot AC,AB=AC,AD\bot AE,AD=AE,AF\bot FC$ 求证 $G$ 为 $BE$ 中点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410225608705-1895713281.png" alt="" width="415" height="228" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;作如图&amp;nbsp;$BH\bot HI\bot IE$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410225658750-1983912413.png" alt="" width="337" height="231" loading="lazy" /&gt;&lt;/strong&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410225641075-576039542.png" alt="" width="372" height="222" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(为美观，过程已被删减)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\because \triangle YELLOW\cong \triangle BLUE,\triangle GREEN\cong \triangle RED$&lt;/p&gt;
&lt;p&gt;$\therefore IE=AF=BH$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\triangle BHG\cong \triangle GIE$&lt;/p&gt;
&lt;p&gt;$\therefore BG=GE$ 即&amp;nbsp;$G$ 为 $BE$ 中点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q:&amp;nbsp;&lt;/strong&gt;$\Box ABCD$ 中取一点 $E$ 使 $AE\bot EB,AE=1,CE=5 $ 求DE的长&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410134300932-423420201.png" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;作如图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410134855965-2019396750.png" alt="" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;显然 $\triangle ABE\cong \triangle BCF\cong \triangle CDG\cong&amp;nbsp;\triangle DAH$&lt;/p&gt;
&lt;p&gt;则 $AE=BF=CG=DH=1$&lt;/p&gt;
&lt;p&gt;设 $EF=FG=GH=HE=x$&lt;/p&gt;
&lt;p&gt;根据勾股定理&lt;/p&gt;
&lt;p&gt;&amp;nbsp;$EF^2+FC^2=EC^2$&lt;/p&gt;
&lt;p&gt;&amp;nbsp;$x^2+(1+x)^2=25$&lt;/p&gt;
&lt;p&gt;$x_1=3,x_2=-4$ ( $x_2$ 舍)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;$EH^2+HD^2=DE^2$&lt;br /&gt;&amp;nbsp;$x^2+1=DE^2$&lt;br /&gt;&amp;nbsp;$DE^2=10$&lt;br /&gt;&amp;nbsp;$DE=\sqrt{10}$&lt;/p&gt;
&lt;p&gt;此类图称为正方形的&lt;strong&gt;内弦图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正方形的弦图为多个三垂模型叠加而来&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410141413591-1757345248.png" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt;如图,$O_1,O_2$分别为两个正方形的中心点,$M$是$BE$的中点,求证$MO_1=MO_2,MO_1\perp MO_2$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202106/2213867-20210606135734211-705246246.png" alt="" width="848" height="476" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A1:（jio拉jio模型：&lt;a href="https://www.cnblogs.com/zhangshaojia/p/14729742.html" target="_blank"&gt;手拉手变式&lt;/a&gt;）&lt;/strong&gt;如图,倍长$O_2M$至$H$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202106/2213867-20210606140144000-1834484032.png" alt="" width="866" height="616" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;显然$\triangle O_2EM\cong \triangle BHM$&lt;/p&gt;
&lt;p&gt;$AO_2=O_2E=BH,AO_1=O_1B$&lt;/p&gt;
&lt;p&gt;(导角过程略)$\angle HBO_1=\angle O_1AO_2$&lt;/p&gt;
&lt;p&gt;$\triangle HBO_1\cong&amp;nbsp;\triangle O_1AO_2$&lt;/p&gt;
&lt;p&gt;$\angle HO_1O_2=\angle BO_1A=90^{\circ},HO_1=HO_2$(等腰直角三角形)&lt;/p&gt;
&lt;p&gt;$MO_1=MO_2,MO_1\perp MO_2$&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;strong&gt;A2:（&lt;a href="https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E4%BD%8D%E7%BA%BF/2145047?fr=aladdin" target="_blank"&gt;三角形中位线&lt;/a&gt;）&lt;/strong&gt;连接 $CE,BG$ 则 $CE=2MO_1,GB=2MO_2$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202106/2213867-20210606141522821-1809033114.png" alt="" width="740" height="432" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;$\because \triangle BAG\cong \triangle CAE$(证明略)&lt;/p&gt;
&lt;p&gt;$\therefore CE=BG,CE\perp BG$(证明略)&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;MO_1=MO_2,MO_1\perp MO_2$&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14640758.html</id>
    <title type="text">几何 远边相等怎么办？-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-10T06:19:00Z</published>
    <updated>2021-04-10T06:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14640758.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt;$\angle ABD=80^{\circ},\angle BDA=20^{\circ},AB=CD$ 求 $\angle ACB$ 的度数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410230800094-1016159301.png" alt="" width="613" height="255" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;作如图 $AB=BE=EA$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210410230827591-1662639750.png" alt="" width="589" height="249" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;$\because \angle ABD=80^{\circ},\angle BDA=20^{\circ}$&lt;/p&gt;
&lt;p&gt;$\therefore AD=DB$&lt;/p&gt;
&lt;p&gt;$\therefore \triangle AED\cong&amp;nbsp;\triangle BED$&lt;/p&gt;
&lt;p&gt;$\therefore \angle ADE=10^{\circ}$&lt;/p&gt;
&lt;p&gt;$\because&amp;nbsp;\angle ADC=\angle DAE=20^{\circ} ,AE=AB=CD$&lt;/p&gt;
&lt;p&gt;$\therefore \triangle AED\cong&amp;nbsp;\triangle ACD$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\angle CAD=\angle ADE=10^{\circ}$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\angle ACB=\angle ADC+\angle CAD=30^{\circ}$&lt;/p&gt;
&lt;p&gt;所以,远边相等怎么办?&lt;strong&gt;构全等&lt;/strong&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14640768.html</id>
    <title type="text">天空为什么是蓝色的?-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-10T06:21:00Z</published>
    <updated>2021-04-10T06:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14640768.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;天空为什么是蓝色的?&lt;/strong&gt;你有想过这个问题吗？&lt;/p&gt;
&lt;p&gt;那么对于非常纯净的大气环境下，即便其内部没有悬浮的各种尘埃、冰晶等杂质微粒，也会由于大气分子的散射作用，而使得太阳光中的蓝紫光被散射开，从而弥漫到整个大气层，因此&lt;strong&gt;瑞利散射&lt;/strong&gt;是天空呈现蓝色的原因。&lt;/p&gt;
&lt;p&gt;瑞利发现，散射现象不仅仅会发生在杂质微粒身上，对于单独的原子或分子而言，散射现象同样会发。这被称为瑞利散射，一般来说，当粒子的直径远小于入射光波长时（不超过波长的十分之一），散射光的强度同入射光的频率呈四次方正比关系（也即是和波长呈四次方反比），因此&lt;strong&gt;对于波长越短的光，散射就会越强&lt;/strong&gt;，如果以太阳光为例，那么位于可见光范围内的短波蓝紫光就最容易被散射开。&lt;/p&gt;
&lt;p&gt;而日落时的夕阳正是这一理论的最好验证。&lt;/p&gt;
&lt;p&gt;考虑到地球是一个球体，因为包裹地球的大气层可以看做是一个球壳，一般在每天正午左右，太阳位置达到每天的最高点，此时太阳光从大气层穿透到地面上时，经历的大气层厚度是一天当中最短的；而到了日落（或者日出）时，太阳光所经历的大气层厚度是一天当中最长的，关于这一点从下图比较直观的看出来&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417230541859-142449757.png" alt="" loading="lazy" /&gt;&lt;br /&gt;而穿过的距离越长则意味着更多的蓝紫光被散射，于是最后只有偏红的光抵达地面，这就是为什么在日落时的太阳呈现出咸鸭蛋黄的颜色，不过值得注意的是，这种红色只在太阳附近出现，而其余更大部分的天空，仍旧显示蓝色或者更暗的颜色（毕竟太阳要落山了，即将要进入夜晚）&lt;/p&gt;
&lt;p&gt;引出正题:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;光的波粒二象性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1905年，&lt;a href="https://baike.baidu.com/item/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6/122624" target="_blank" data-lemmaid="122624"&gt;爱因斯坦&lt;/a&gt;提出了&lt;a href="https://baike.baidu.com/item/%E5%85%89%E7%94%B5%E6%95%88%E5%BA%94/289208" target="_blank" data-lemmaid="289208"&gt;光电效应&lt;/a&gt;的&lt;a href="https://baike.baidu.com/item/%E5%85%89%E9%87%8F%E5%AD%90/4688570" target="_blank" data-lemmaid="4688570"&gt;光量子&lt;/a&gt;解释，人们开始意识到&lt;a href="https://baike.baidu.com/item/%E5%85%89%E6%B3%A2/10730221" target="_blank" data-lemmaid="10730221"&gt;光波&lt;/a&gt;同时具有波和粒子的双重性质。1924年，&lt;a href="https://baike.baidu.com/item/%E5%BE%B7%E5%B8%83%E7%BD%97%E6%84%8F/163543" target="_blank" data-lemmaid="163543"&gt;德布罗意&lt;/a&gt;提出&amp;ldquo;&lt;a href="https://baike.baidu.com/item/%E7%89%A9%E8%B4%A8%E6%B3%A2/3288667" target="_blank" data-lemmaid="3288667"&gt;物质波&lt;/a&gt;&amp;rdquo;假说，认为和光一样，一切物质都具有波粒二象性。根据这一假说，电子也会具有&lt;a href="https://baike.baidu.com/item/%E5%B9%B2%E6%B6%89/5722962" target="_blank" data-lemmaid="5722962"&gt;干涉&lt;/a&gt;和&lt;a href="https://baike.baidu.com/item/%E8%A1%8D%E5%B0%84/1084873" target="_blank" data-lemmaid="1084873"&gt;衍射&lt;/a&gt;等波动现象，这被后来的&lt;a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E8%A1%8D%E5%B0%84/11049329" target="_blank" data-lemmaid="11049329"&gt;电子衍射&lt;/a&gt;试验所证实。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418141334895-2113952626.jpg" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;为什么浮油和肥皂泡会有彩色图案？&lt;/p&gt;
&lt;p&gt;我们假设照射一束光波于薄膜表面，由于折射率不同，光波会被薄膜的上界面与下界面分别反射，因相互干涉而形成新的光波，这现象称为薄膜干涉。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418141348975-225171274.gif" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电子跃迁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418142530776-1290545667.png" alt="" loading="lazy" /&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418142559135-1883380312.png" alt="" loading="lazy" /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;粒子的&lt;strong&gt;外层电子&lt;/strong&gt;从&lt;strong&gt;低能级&lt;/strong&gt;转移到&lt;strong&gt;高能级&lt;/strong&gt;的过程中会&lt;strong&gt;吸收能量&lt;/strong&gt;；从&lt;strong&gt;高能级&lt;/strong&gt;转移到&lt;strong&gt;低能级&lt;/strong&gt;则会&lt;strong&gt;释放能量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;激光发射器原理:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418142124978-1292264587.png" alt="" width="588" height="327" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;相当于将一小段时间的光在一瞬间放出(所以光是&amp;ldquo;断断续续&amp;rdquo;的，但亮度高)&lt;/p&gt;
&lt;p&gt;电子只在光的频率，方向一定的时候跃迁&lt;/p&gt;
&lt;p&gt;此为该粒子的&lt;strong&gt;受激辐射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以此激光发射器发射&lt;strong&gt;频率，方向一定&lt;/strong&gt;的激光&lt;/p&gt;
&lt;p&gt;东西放久了为什么会变黄?&lt;/p&gt;
&lt;p&gt;因为物质氧化后分子从原来的&lt;strong&gt;吸收紫外光反射可见光&lt;/strong&gt;到&lt;strong&gt;吸收紫外光及紫光反射可见光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;吸收更多紫色，就显出黄色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://baike.baidu.com/item/%E7%91%9E%E5%88%A9-%E9%87%91%E6%96%AF%E5%85%AC%E5%BC%8F/12729329?fr=aladdin" target="_blank"&gt;瑞利-金斯公式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E5%8A%9B%E5%AD%A6/4309354?fr=aladdin" target="_blank"&gt;矩阵力学&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://baike.baidu.com/item/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%8E%9F%E7%90%86/473553?fr=aladdin" target="_blank"&gt;不确定性原理&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14670586.html</id>
    <title type="text">几何 塞瓦定理及梅涅劳斯定理-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-17T05:53:00Z</published>
    <updated>2021-04-17T05:53:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14670586.html" />
    <content type="text"># 2023年6月8日

梅涅劳斯定理的充分性可以用更直观且对称且无分讨的方式证明。

将那三点共线所在直线设为 $l$，将平面上每个点设一个权值等于其到直线的距离。

则三个分式相乘等于 $1$ 的意义是三角形某个顶点的权值变换三次回到自己时缩放比例为 $1$。

# 远古

**塞瓦定理**

如图 $\frac{AB}{BC}\cdot \frac{CD}{DE}\cdot \frac{EF}{FA}=1$ **当且仅当** $AD,CF,EB$ 三线共点

证明略(面积法)

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417140458072-1609896167.png)

**梅涅劳斯定理**

(开局一个三角形,一条直线,装备全靠捡)

梅涅劳斯定理因直线与三角形的位置关系不同而变化

如图一 $\frac{AE}{EB}\cdot \frac{BD}{DC}\cdot \frac{CF}{FA}=1$ **当且仅当** $D,E,F$ 三点共线

如图二 $\frac{AD}{DB}\cdot \frac{BF}{FC}\cdot \frac{CE}{EA}=1$ **当且仅当** $D,E,F$ 三点共线

证明略(与塞瓦类似)

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417140957328-27000752.png)![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417141238329-966645102.png)

这6条边在式中的顺序难记,怎么办?

从三角形的一个顶点出发,按顺序遍历 $[$ 顶点为三角形的顶点,交点为当前遍历到的三角形的边(的延长线)与直线的交点 $]$ :

顶点 $\rightarrow$ 交点 $\rightarrow$ 顶点 $\rightarrow$ 交点 $\rightarrow$ 顶点 $\rightarrow$ 交点 $\rightarrow$ 最初的顶点

经过的边分别记作 $a,b,c,d,e,f$

则公式为 $\frac{a}{b}\cdot \frac{c}{d}\cdot \frac{e}{f}=1$

举个例子:

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417142857539-1852514802.png)

*梅涅劳斯定理例题(蒙日定理):*

平面上有三个圆,每一对圆的外公切线交于一点,则三个交点共线

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417151418447-1197449587.png)

首先提取出两个圆

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417150003347-1565484053.png)

易知

$\because \triangle ACO\sim \triangle BDO$

$\therefore \frac{AO}{BO}=\frac{AC}{BD}$ (即半径之比)

转回原图:

![img](https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210417150852869-1889155260.png)

$\because \frac{AF}{CF}=\frac{a}{c},\frac{BD}{AD}=\frac{b}{a},\frac{CE}{BE}=\frac{c}{b}$

$\therefore \frac{AF}{CF}\cdot \frac{BD}{AD}\cdot \frac{CE}{BE}=1$

$\therefore D,E,F$共线(梅涅劳斯定理)

**summary**

塞瓦定理多用于证**三线共点**
梅涅劳斯定理多用于证**三点共线**</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14672956.html</id>
    <title type="text">几何 相切圆-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-04-18T02:35:00Z</published>
    <updated>2021-04-18T02:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14672956.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt;如图,两线同切三圆,大圆面积为9,小圆面积为4,求证中圆面积为6&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210418103426013-2082246470.png" alt="" width="483" height="289" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;如图, $AD:AO:DO=BE:BO:EO=CF:CO:FO,AD+BE=DE,BE+CF=EF$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202104/2213867-20210424111642214-335170313.png" alt="" width="614" height="300" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;可推得 $AD:BE=BE:CF$&lt;/p&gt;
&lt;p&gt;&amp;nbsp;则 $AD^{2}CF^{2}=BE^4$&lt;/p&gt;
&lt;p&gt;即中圆的面积 $S_{MediumCirc}=\sqrt{S_{BiggerCirc}\cdot S_{SmallerCirc}}=6$&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14729643.html</id>
    <title type="text">素数の判定-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-05-04T07:59:00Z</published>
    <updated>2021-05-04T07:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14729643.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;定义判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$1000000007\not\equiv 0(mod$ $2)$&lt;/p&gt;
&lt;p&gt;$1000000007\not\equiv 0(mod$ $3)$&lt;/p&gt;
&lt;p&gt;$1000000007\not\equiv 0(mod$ $5)$&lt;/p&gt;
&lt;p&gt;$1000000007\not\equiv 0(mod$ $7)$&lt;/p&gt;
&lt;p&gt;$\vdots$&lt;/p&gt;
&lt;p&gt;$1000000007\not\equiv 0(mod$ $31607)$&lt;/p&gt;
&lt;p&gt;所以 $1000000007$ 是素数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;费马小定理逆用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;费马小定理: $a^p\equiv a(mod$ $p),p$ 是素数 $,a$ 是整数&lt;/p&gt;
&lt;p&gt;$2^{1000000007}\equiv 2(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;$3^{1000000007}\equiv 3(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;$4^{1000000007}\equiv 4(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;$5^{1000000007}\equiv 5(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;$\vdots$&lt;/p&gt;
&lt;p&gt;$1000000006^{1000000007}\equiv 1000000006(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;所以 $1000000007$ 是素数的&lt;strong&gt;概率非常大(上述式子是必要不充分条件)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;威尔逊定理(我愿称之为最强)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;威尔逊定理:&amp;nbsp;&lt;strong&gt;当且仅当 $&lt;/strong&gt;p$ 为素数时 $(p-1)!\equiv -1(mod$ $p)$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当且仅当！充要条件！亦可赛艇！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$1000000006!\equiv -1(mod$ $1000000007)$&lt;/p&gt;
&lt;p&gt;所以 $1000000007$ 是素数&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14729742.html</id>
    <title type="text">几何 手拉手模型及夹半角模型-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-05-04T08:35:00Z</published>
    <updated>2021-05-04T08:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14729742.html" />
    <content type="html">&lt;p&gt;&lt;strong&gt;Q:&amp;nbsp;&lt;/strong&gt;如图,有两个等边 $\triangle ABC,\triangle ADE$ 且 $B,C,E$ 三点共线,求证 $CD$ 平分 $\angle ACE$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202105/2213867-20210504164959783-549185374.png" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\because AB=AC,AE=AD,\angle BAE=\angle CAD$&lt;/p&gt;
&lt;p&gt;$\therefore \triangle ABE\cong&amp;nbsp;\triangle ACD$&lt;/p&gt;
&lt;p&gt;$\therefore \angle ACD=\angle ABC=60^{\circ}$&lt;/p&gt;
&lt;p&gt;$\because \angle ACE=120^{\circ}$&lt;/p&gt;
&lt;p&gt;$\therefore CD$ 平分 $\angle ACE$&lt;/p&gt;
&lt;p&gt;像这样&lt;strong&gt;两个相似三角形&lt;/strong&gt;(题中等边三角形)&lt;strong&gt;共顶点&lt;/strong&gt;,连接剩下两顶点来&lt;strong&gt;构造全等三角形&lt;/strong&gt;的模型叫作&lt;strong&gt;手拉手模型（其变式jio拉jio模型位于&lt;a href="https://www.cnblogs.com/zhangshaojia/p/14640690.html" target="_blank"&gt;此文章Q4&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: &lt;/strong&gt;如图$,\square OACE$ 内 $\angle BOD=45^{\circ},$求证 $AB+DE=BD$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202105/2213867-20210504165753978-1824817896.png" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/strong&gt;如图$,OE=EG,OF=OB$&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2020.cnblogs.com/blog/2213867/202105/2213867-20210504165921621-1208729068.png" alt="" loading="lazy" /&gt;&lt;/p&gt;
&lt;p&gt;显然$,\because \triangle OAB\cong \triangle OEF,\triangle OAC\cong&amp;nbsp;\triangle OEG$&lt;/p&gt;
&lt;p&gt;$\therefore \triangle OBC\cong&amp;nbsp;\triangle OFG$&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\angle BOF=\angle COG=90^{\circ}$&lt;/p&gt;
&lt;p&gt;$\because \angle BOD=45^{\circ}$&lt;/p&gt;
&lt;p&gt;$\therefore OD$ 是等腰直角 $\triangle OBF$ 一边 $BF$ 的垂直平分线&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;\triangle DBF$&amp;nbsp;等腰&lt;/p&gt;
&lt;p&gt;$\therefore&amp;nbsp;BD=DF=DE+EF=DE+AB$&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;夹半角模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14770030.html</id>
    <title type="text">信息算法牛杂面-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-02-22T11:30:00Z</published>
    <updated>2022-02-22T11:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14770030.html" />
    <content type="text">[CSP初赛知识点梳理](https://www.luogu.com.cn/blog/334586/csp-pre-knowledge)
[傅里叶变换交互式入门](https://www.jezzamon.com/fourier/zh-cn.html)
[算法学习笔记](https://zhuanlan.zhihu.com/p/105467597)
[pb_ds](https://oi-wiki.org/lang/pb-ds/tree/#__gnu_pbds-tree)
[Miller-Rabin素性测试](https://blog.csdn.net/ECNU_LZJ/article/details/72675595)
[Pollard_Rho](https://zhuanlan.zhihu.com/p/267884783)
[线性筛约数个数和约数和的新方法](https://www.cnblogs.com/ldysy2012/p/10390857.html)
[（组合游戏）SG函数与SG定理详解](https://blog.csdn.net/bestsort/article/details/88197959)
[YLWang 学习笔记 莫比乌斯反演及杜教筛](https://www.luogu.com.cn/blog/YLWang/post-xue-xi-bi-ji-mu-bi-wu-si-fan-yan)
[Dancing Links](https://www.cnblogs.com/grenet/p/3145800.html)
[FFT(胡小兔)](https://www.cnblogs.com/RabbitHu/p/FFT.html#4215213)
[FFT(bilibili)](https://www.bilibili.com/video/BV1za411F76U)
[NTT从入门到精通](https://blog.csdn.net/Force_CHL/article/details/81748537)
[斜率优化学习笔记](https://www.cnblogs.com/MashiroSky/p/6009685.html)
[top_tree](https://blog.csdn.net/iamzky/article/details/43494481)
[类欧几里德算法](https://oi-wiki.org/math/number-theory/euclidean/)
[K-D Tree](https://oi-wiki.org/ds/kdt/)
[zkw线段树详解](https://blog.csdn.net/keshuqi/article/details/52205884)
[卢卡斯定理及扩展(洛谷日报)](https://yangty.blog.luogu.org/lucas-theorem-note)
[扩展卢卡斯定理](https://blog.csdn.net/hqddm1253679098/article/details/82897638)
[卢卡斯定理](https://zhuanlan.zhihu.com/p/116698264)
[狄利克雷卷积和莫比乌斯反演](https://zhuanlan.zhihu.com/p/390895860)
[点分治](https://www.luogu.com.cn/blog/user9012/dian-fen-zhi-lve-xie)
[模拟退火](https://www.cnblogs.com/rvalue/p/8678318.html)
[tarjan(桥&amp;割点)](https://blog.csdn.net/Harington/article/details/105793229)
[DP四边形不等式优化](https://blog.csdn.net/NOIAu/article/details/72514812)
[DP四边形不等式优化(oi-wiki)](https://oi-wiki.org/dp/opt/quadrangle/)
[dfs序](https://www.cnblogs.com/kousak/p/9192094.html)
[vector的用法](https://blog.csdn.net/wkq0825/article/details/82255984)
[最小生成树计数（MST） kruskal&amp;矩阵定理](https://blog.csdn.net/usernamezzz/article/details/84316426)
[matrix tree矩阵树定理](https://blog.csdn.net/weixin_30243533/article/details/99093791)
[prufer序列](https://blog.csdn.net/qq_42101694/article/details/103151094)
[分块](http://hzwer.com/8053.html)
[如何正确地生成一个随机数](https://www.cnblogs.com/RabbitHu/p/10390146.html)
[线性求逆元的算法](https://www.cnblogs.com/RabbitHu/p/9070983.html)
[树状数组详解](https://www.cnblogs.com/xenny/p/9739600.html)
[积性函数与线性筛&lt;-素数线性筛也在这里](https://www.cnblogs.com/zhoushuyu/p/8275530.html)
[启发式合并](https://www.luogu.com.cn/blog/288716/solution-p6279)
[set](https://blog.csdn.net/qq_40941722/article/details/104296162)
[splay](https://blog.csdn.net/ModestCoder_/article/details/90139481)
[ZKW线段树](https://blog.csdn.net/keshuqi/article/details/52205884)
[最小生成树Boruvka算法](https://blog.csdn.net/qq_44691917/article/details/107672438)
[BSGS](https://www.cnblogs.com/wxyww/p/BSGS.html)
[CDQ分治](https://blog.csdn.net/wu_tongtong/article/details/78785836)
[线性基](https://blog.csdn.net/a_forever_dream/article/details/83654397)
[整体二分](https://oi-wiki.org/misc/parallel-binsearch/)
[nim博弈](https://blog.csdn.net/clover_hxy/article/details/53818624)
[DP斜率优化](https://blog.csdn.net/xiang_6/article/details/81450647)
[CDQ分治](https://blog.csdn.net/wu_tongtong/article/details/78785836)
[Dsu on tree](https://www.cnblogs.com/zwfymqz/p/9683124.html)
[kruskal重构树](https://www.cnblogs.com/zwfymqz/p/9683523.html)
[二次剩余及其计算方法](https://blog.csdn.net/zhouyuheng2003/article/details/86685762)
[二次剩余](https://www.cnblogs.com/cjyyb/p/10830057.html)
[BSGS](https://blog.csdn.net/zzkksunboy/article/details/73162229)
[原根](https://oi-wiki.org/math/primitive-root/)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14993587.html</id>
    <title type="text">主席树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-10T04:39:00Z</published>
    <updated>2021-07-10T04:39:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14993587.html" />
    <content type="text">**USE1**
区间询问第K大值 单次$O(logn)$
例如:
`3 1 9 2 8`
先离散化:
`3 1 5 2 4`
再列出桶（存各元素出现次数）:
`
     1  2  3  4  5
1~1: 0  0  1  0  0
1~2: 1  0  1  0  0
1~3: 1  0  1  0  1
1~4: 1  1  1  0  1
1~5: 1  1  1  1  1
`
**桶的空间$n^2$太大怎么办?**
**再建主席树:**
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210710122315581-1767850767.png)
**空间不还是$n^2$吗?**
观察,相邻两个线段树只有常数$1$个值不同
所以相邻两个线段树中相同的子树可用同一个地址存（直接$copy$）
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210710122323238-506953303.png)
这样除第一个线段树外,其余都只要另开$logn$的空间即可
共$nlogn$的空间
**时间复杂度呢？**
每次询问$[l,r]$内第K大值
从$head[l-1]$和$head[r]$两个$root$开始向下找
**判断两个右子树的1的个数的差是否小于K**
若大于等于K，则$[l,r]$内第K大值在右子树
otherwise，$[l,r]$内第K大值在左子树
递归调用即可(最后别忘了反离散化)

**USE2**
询问区间众数（超过一半的数）
与USE1过程类似，先鸽着</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/14999296.html</id>
    <title type="text">值域线段树及离散化模板-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-11T10:55:00Z</published>
    <updated>2021-07-11T10:55:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/14999296.html" />
    <content type="text">**例**
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210711190053643-348256916.png)
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210711190101528-672019749.png)
就是说**给一个序列a，将其中几个元素删去使其严格递增，求删去的数的总和的最小值**
**首先想着DP**
$f[i]$表示将$[1,i]$中几个元素删去使其严格递增,**未删去的数的总和的最大值**
易知$f[i]=a[i]+max(f[j])$其中$j$满足$j&lt;i,a[j]&lt;a[i]$
复杂度$O(n^2)$
像这种**每次在不同限定下取某些元素中的最值/和···**
用**值域线段树**
step1:将数组$a[i]$**离散化**成$b[i]$
离散化精简代码:
```
#include&lt;bits/stdc++.h&gt;
#define inf 0x3f3f3f3f'
#define N 1000010
using namespace std;
typedef long long ll;
void setio(string);

int a[N],n; //原序列 
int b[N];//b[1~lim]是离散化后的数向原数的映射 
int main() {
	setio("");
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	//start
	for(int i=1;i&lt;=n;i++)b[i]=a[i];
	sort(b+1,b+1+n);
	int lim=unique(b+1,b+1+n)-b-1;//limit
	for(int i=1; i&lt;=n; i++) a[i]=lower_bound(b+1,b+1+lim,a[i])-b;//二分查找 
	//end
	for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;" ";cout&lt;&lt;endl;
	return 0;
}
void setio(string name) {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	if(name!="") {
		freopen((name+".in").c_str(),"r",stdin);
		freopen((name+".out").c_str(),"w",stdout);
	}
}
```
step2:开线段树
**大小:数组不同元素的个数**
step3:在dp遍历数组时更新值域线段树:
新加入一个$f[i]$，与**线段树$b[i]$的位置**取MAX存入线段树$b[i]$的位置
step4:计算$f[i]$时，$max(f[j])$可直接替换为$O(logn)$的**$query(1,b[i]-1)$**
总体$O(nlogn)$
**END**</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15003469.html</id>
    <title type="text">攻克路径技术难关-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-12T11:09:00Z</published>
    <updated>2021-07-12T11:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15003469.html" />
    <content type="text">![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210712185057834-1260883014.png)
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210712185104385-1646218475.png)
**怎么计算题中不同的路径数?**
**规定:合法路径必须先右再上**
如:
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210712185731434-934541742.png)
得:
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210712190154308-36406768.png)
$f[i][j]+=f[i-1][j]$
若$mp[i+1][j-1]=1$(障碍物)，再加一句$f[i][j]+=f[i][j-k]$其中k为(i,j)之下连续无障碍物的格数
轻松拿下前12个点
剩下的呢?
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210714221039417-107711947.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15004246.html</id>
    <title type="text">三角关系并查集-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-12T14:14:00Z</published>
    <updated>2021-07-12T14:14:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15004246.html" />
    <content type="text">[题目luogu P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)
各个并查集中不一定是同一类了，有了权值
**ACcode**
```cpp
//https://www.luogu.com.cn/problem/P2024
#include&lt;bits/stdc++.h&gt;
#define N 50010
using namespace std;
typedef long long ll;
void setio(string);

int n,k,f[N],cost[N]; //cost指向父亲的边的属性（0~3）0同类 1吃 2被吃  
int ans=0;
int gf(int x){//找祖先并路径压缩 
	if(f[x]==x)return x;
	int tmp=gf(f[x]);
	cost[x]=(cost[x]+cost[f[x]])%3;
	f[x]=f[f[x]]; 
	return f[x];
}
int main(){
	setio("");
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++){//并查集init 
		f[i]=i;
		cost[i]=0;
	}
	for(int i=1,op,x,y;i&lt;=k;i++){
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
		if(x==y &amp;&amp; op==2 || x&gt;n || y&gt;n){//必假 
			ans++;
			continue;
		}
		int xx=gf(x),yy=gf(y);
		if(xx==yy){//判断是否为真（双路cost同余） 
			if((op==1 &amp;&amp; cost[x]!=cost[y]) || (op==2 &amp;&amp; (1+cost[y]-cost[x]+3)%3!=0))ans++;
		}else{//必定为真，直接操作 
			cost[xx]=(3-cost[x])%3;
			cost[yy]=(3-cost[y])%3;
			f[xx]=x;
			f[yy]=y;
			f[x]=f[y]=y;
			if(op==1)cost[x]=0;//同类 
			else cost[x]=1;//吃 
			cost[y]=0;
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
void setio(string name){
	ios_base::sync_with_stdio(0);
	cin.tie(0);
    if(name!=""){
        freopen((name+".in").c_str(),"r",stdin);
        freopen((name+".out").c_str(),"w",stdout);
    }
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15005905.html</id>
    <title type="text">树状数组奆-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-13T04:38:00Z</published>
    <updated>2021-07-13T04:38:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15005905.html" />
    <content type="text">##树状数组比线段树和平衡树好写，且功能强大
[题目ACwing244](https://www.acwing.com/problem/content/description/245/)
倒序遍历，每次遍历到的数字表示此元素在剩下的元素中的排名
用树状数组维护那些没有用过的排名
**ACcode:**
```
//https://www.acwing.com/problem/content/description/245/
#include &lt;bits/stdc++.h&gt;
#define lowbit(x) x&amp;(-x)
#define N 200010
using namespace std;
typedef long long ll;
void setio(string);

int c[N],a[N],n,m,ans[N];
inline int pre(int x) {//sum 1~x
	int res=0;
	while(x&gt;0) {
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
inline int add(int x,int y) {//x的位置+=y 
	while(x&lt;=n) {
		c[x]+=y;
		x+=lowbit(x);
	}
}
int main() {
	setio("");
	cin&gt;&gt;n;
	add(1,1);
	for(int i=2; i&lt;=n; i++) {
		cin&gt;&gt;a[i];
		add(i,1);
	}
	for(int i=n; i&gt;=1; i--) {
		int l=1,r=n;
		while(l&lt;r) { //二分找点
			int mid=l+r&gt;&gt;1;
			if (pre(mid)&lt;a[i]+1)//查询第a[i]+1个1在什么位置,这个位置号就是奶牛的高度
				l=mid+1;
			else
				r=mid;
		}
		ans[i]=r;
		add(r,-1);//我们已经选择了
	}
	for(int i=1; i&lt;=n; i++) //倒序扫描,正序输出
		cout&lt;&lt;ans[i]&lt;&lt;endl;
	return 0;
}
void setio(string name) {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	if(name!="") {
		freopen((name+".in").c_str(),"r",stdin);
		freopen((name+".out").c_str(),"w",stdout);
	}
}

```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15009864.html</id>
    <title type="text">线段树+扫描线+二分查找+离散化-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-14T02:58:00Z</published>
    <updated>2021-07-14T02:58:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15009864.html" />
    <content type="text">[题目](https://www.acwing.com/solution/content/1027/)
##[扫描线](https://blog.csdn.net/xianpingping/article/details/83032798)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15012583.html</id>
    <title type="text">二维问题怎么转化？-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-14T11:27:00Z</published>
    <updated>2021-07-14T11:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15012583.html" />
    <content type="text">## 先将二维问题转为一维问题，再用低复杂度解决另一维
[题目](https://www.luogu.com.cn/problem/P7149)
先离散化,再$\mathcal{O}(n^2)$枚举两个点,横着划两刀,代表上下边界
再数左右侧点的个数（预处理二维前缀和）,相乘后每种相加即可
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210714192712806-471555740.png)
ACcode:
```cpp
#include&lt;bits/stdc++.h&gt;
#define inf 0x3f3f3f3f
#define pi pair&lt;int,int&gt;
#define X first
#define Y second
#define mkp make_pair
#define fo(x,y,z) for(int x=y;x&lt;=z;x++)
#define N 2600
using namespace std;
typedef long long ll;
void setio(string);

int pre[N][N],mp[N][N]; 
int n;
pi pos[N];
int xxx[N],yyy[N]; 
ll ans;
int sum(int x1,int y1,int x2,int y2){
	return pre[x2][y2]-pre[x1-1][y2]-pre[x2][y1-1]+pre[x1-1][y1-1]+1;
}
int main(){
	setio("");
	cin&gt;&gt;n;
	fo(i,1,n){
		cin&gt;&gt;pos[i].X&gt;&gt;pos[i].Y;
		xxx[i]=pos[i].X;
		yyy[i]=pos[i].Y;
	}
	sort(xxx+1,xxx+1+n);
	sort(yyy+1,yyy+1+n);
	fo(i,1,n){
		pos[i].X=lower_bound(xxx+1,xxx+1+n,pos[i].X)-xxx;
		pos[i].Y=lower_bound(yyy+1,yyy+1+n,pos[i].Y)-yyy;
	}
	fo(i,1,n){
		mp[pos[i].X][pos[i].Y]=1;
	}
	fo(i,1,n){
		fo(j,1,n){
			pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];
			if(mp[i][j])pre[i][j]++;
		}
	} 
	ans=1+n;
	fo(i,1,n-1){
		fo(j,i+1,n){
			ans+=sum(1,min(pos[i].Y,pos[j].Y),min(pos[i].X,pos[j].X)-1,max(pos[i].Y,pos[j].Y))
				*sum(max(pos[i].X,pos[j].X)+1,min(pos[i].Y,pos[j].Y),n,max(pos[i].Y,pos[j].Y));
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
void setio(string name){
	ios_base::sync_with_stdio(0);
	cin.tie(0);
    if(name!=""){
        freopen((name+".in").c_str(),"r",stdin);
        freopen((name+".out").c_str(),"w",stdout);
    }
}

```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15030883.html</id>
    <title type="text">重修 Dp 总览-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-25T15:11:00Z</published>
    <updated>2022-01-25T15:11:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15030883.html" />
    <content type="text">## Konata28

三层：**阶段，状态，决策**。

写在程序里大概是这样的：

```
For(阶段){
	For(状态){
		1.决策
		2.For(决策集合) 决策
	}
}
```

### 阶段

**Forward**

对，就这一个词。为了满足**无后效性**必须让阶段只能向前。

只能向前的：时间，单向火车等。

经典的阶段：[UVA1025 城市里的间谍 A Spy in the Metro](https://www.luogu.com.cn/problem/UVA1025)

### 决策

先考虑这个，再说状态。

考虑在一个情景下，如何**转移**。或者说，如何将题目中的条件写成公式。

### 状态

构建**满足决策和时间复杂度**的状态。

注意：一道题可能有不同的解法对应不同的状态定义，但**只有部分的时间复杂度是对的**。

经典的状态定义不同：[UVA10934 装满水的气球 Dropping water balloons](https://www.luogu.com.cn/problem/UVA10934)

## Hu Kang

以下均以 01 背包举例。

### 状态表示

将每一个状态看作一个**集合集的属性**。

$f[i,j]$ 表示前 $i$ 个物品中总体积为 $j$ 的物品集合集的元素大小和的最大值（属性）。

$e.g.$

$$id:1,2,3$$

$$w_i:4,5,9$$

$$v_i:6,8,7$$

$$f[3,9]\to\{\{1,2\},\{3\}\}$$

其中 $\{1,2\}$ 的价值和最大，为 $6+8=14$，故 $f[3,9]=14$

常见的属性有：大小、最值、和、乘积、异或和……

### 状态转移

**对集合集中集合的划分。**

将 $f[i,j]$ 的集合集划分成包含 $i$ 物品的集合和不包含 $i$ 物品的集合。

两种情况分别对应 $f[i-1,j]$ 和 $f[i-1,j-w_i]+v_i$。

所以状态转移方程为 $f[i,j]=\max(f[i-1,j],f[i-1,j-w_i]+v_i)$。

$e.g.$

$$id:1,2,3,4$$

$$w_i:4,5,9,8$$

$$v_i:6,8,7,1$$

$$f[4,13]\to\{\color{blue}{\{1,3\}},\color{red}{\{2,4\}}\}$$

蓝色为不含 $i$ 的，红色为含 $i$ 的。

再思考，可以用滚动数组优化空间复杂度。

## Unknown

![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210719163146652-930070978.png)

**拿到一道题，先写出状态转移方程，再优化时间复杂度。**

### 状态优化

对于状态可累加
$e.g.dp[i+j]=dp[i]+dp[j]+i+j$
的，用倍增优化

### 决策优化：

#### 单调队列优化

$e.g.dp[i][j]=\max(dp[i-1][j-233]+(j-233)^2,dp[i-1][j-232]+(j-232)^2,...,dp[i-1][j]+j^2)$

#### 斜率优化

$e.g.dp[i]=\max(dp[1]+i,dp[2]+2i,...,dp[i-1]+(i-1)i)$

#### 四边形不等式优化

交叉小于包含
$e.g.dp[i][j]=\max(dp[i][i]+dp[i+1][j],dp[i][i+1]+dp[i+2][j],...,dp[i][j-1]+dp[j-1][j],dp[i][j]+dp[j][j])$

![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210719164228123-573371129.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15033208.html</id>
    <title type="text">树上DFS序在换根时的变化规律-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-20T01:03:00Z</published>
    <updated>2021-07-20T01:03:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15033208.html" />
    <content type="text">![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210720085948013-1615995773.png)
其中$12324215$为循环链表，可用双倍空间存（如图）</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15036435.html</id>
    <title type="text">遇到括号就是栈(bushi)-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-20T10:42:00Z</published>
    <updated>2021-07-20T10:42:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15036435.html" />
    <content type="text">[CF508E Arthur and Brackets](https://www.luogu.com.cn/problem/CF508E)
我在赛场上想都没想直接DP
$O(n^3)$[过了](https://www.luogu.com.cn/record/53705503)
但别人说正解是栈+贪心
## 讲讲DP
$bool$ $dp[i][j]$表示**从第i对括号至第j对括号是否在ans中能变成一段连续的区间**
转移($check(a,b)$表示$a=(a || b)$):
* 可以第i对括号中间包含第i+1对括号至第j对括号: $check(dp[i][j],dp[i+1][j])$
* 可以由多段相接的连续区间组成($i\leq k&lt;j$): $check(dp[i][j],dp[i][k]\&amp; \&amp; dp[k+1][j])$
发现不用优化$O(n^3)$就能过
（记得记录每个$dp$是从哪里推过来的）
**ACcode**
```
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define FOR(i,j,k) for(register int i=j;(j&lt;k)?(i&lt;=k):(i&gt;=k);i+=(j&lt;k)?1:(-1))
#define IO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define N 666

int n,r;
bool dp[N][N];//从第i对括号至第j对是否能是一段连续区间 
int fang[N][N];//我从哪里推来~ 
pair&lt;int,int&gt; ku[N];
void dfs(int x,int y){
	if(x==y) cout&lt;&lt;"()";
	else if(fang[x][y]==-1){
		cout&lt;&lt;"(";
		dfs(x+1,y);
		cout&lt;&lt;")";
	}else{
		dfs(x,fang[x][y]);
		dfs(fang[x][y]+1,y);
	}
} 
signed main(){
    IO;
    memset(dp,0,sizeof dp);
    cin&gt;&gt;n;
    FOR(i,1,n)cin&gt;&gt;ku[i].first&gt;&gt;ku[i].second;
    FOR(i,1,n)dp[i][i]=(bool)(ku[i].first==1);
    FOR(i,2,n){
    	FOR(l,1,n-i+1){
    		r=l+i-1;
			//dp[l][r]准备就绪 
    		if(dp[l+1][r] &amp;&amp; ku[l].first-1&lt;=(r-l)*2 &amp;&amp; (r-l)*2&lt;=ku[l].second-1){
				dp[l][r]=1;
				fang[l][r]=-1; 
			}else{
    			FOR(k,l,r-1){//k~k+1之间为断点
					if(dp[l][k] &amp;&amp; dp[k+1][r]){
						dp[l][r]=1;
						fang[l][r]=k;
						break;
					}
				}
			}
		}
	}
	if(dp[1][n]){
		dfs(1,n);
		cout&lt;&lt;endl;
	}else cout&lt;&lt;"IMPOSSIBLE"&lt;&lt;endl;
    return 0;
}
```
## 讲讲正解
这是一道括号匹配问题，因此我们考虑使用栈模拟。
因为两对括号要么包含要么相离
所以每次存左括号
右括号肯定优先匹配栈顶左括号
剩下的就是模拟</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15036589.html</id>
    <title type="text">极角排序-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-20T11:24:00Z</published>
    <updated>2021-07-20T11:24:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15036589.html" />
    <content type="text">[CF1284E New Year and Castle Construction](https://www.luogu.com.cn/problem/CF1284E)
[CYJian's I/O Road的题解](https://www.luogu.com.cn/blog/CYJian/solution-cf1284e)（但code好像不对...）</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15072537.html</id>
    <title type="text">分类讨论法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-28T12:54:00Z</published>
    <updated>2021-07-28T12:54:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15072537.html" />
    <content type="text">## 题目
**平面上有九个整点，三点不共线，求证，必有三个点构成的三角形的重心是整点**
## solution
首先考虑**十三个点**的解法
首先设 $X_0,X_1,X_2$ 分别表示**横坐标模 $3$ 同余于 $0,1,2$ 的点的集合**，设 $Y_0,Y_1,Y_2$ 分别**表示纵坐标模 $3$ 同余于 $0,1,2$ 的点的集合**
由**抽屉原理**得 $\max(|X_0|,|X_1|,|X_2|)\geq5$ 设最大的集合为 $X'$
若 $\min(|X'\cap Y_0|,|X'\cap Y_1|,|X'\cap Y_2|)&gt;0$ 则 $X'\cap Y_0,X'\cap Y_1,X'\cap Y_2$ 每个集合各任取一个元素作为三角形三个顶点即可
否则，设除一个空集以外剩余两个集合分别为 $Y',Y''$，由**抽屉原理**得 $\max(|Y'|,|Y''|)\geq3$ 从较大的集合中任取三个元素作为三角形三个顶点即可
原命题得证
### 观看此过程，发现有许多“浪费”的条件，所以尝试一下九个点
同样，设 $X_0,X_1,X_2$ 分别表示横坐标模 $3$ 同余于 $0,1,2$ 的点的集合，设 $Y_0,Y_1,Y_2$ 分别表示纵坐标模 $3$ 同余于 $0,1,2$ 的点的集合
设:
$$A=\begin{pmatrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}\\a_{2,1}&amp;a_{2,2}&amp;a_{2,3}\\a_{3,1}&amp;a_{3,2}&amp;a_{3,3}\end{pmatrix}=\begin{pmatrix}|X_0\cap Y_0|&amp;|X_0\cap Y_1|&amp;|X_0\cap Y_2|\\|X_1\cap Y_0|&amp;|X_1\cap Y_1|&amp;|X_1\cap Y_2|\\|X_2\cap Y_0|&amp;|X_2\cap Y_1|&amp;|X_2\cap Y_2|\end{pmatrix}$$
发现，若满足其中之一：
* $a_{i,1}&gt;0$ 且 $a_{i,2}&gt;0$  且 $a_{i,3}&gt;0$ ①
* $a_{1,i}&gt;0$ 且 $a_{2,i}&gt;0$  且 $a_{3,i}&gt;0$ ②
* $a_{1,p_1}&gt;0$ 且 $a_{2,p_2}&gt;0$  且 $a_{3,p_3}&gt;0$，其中 $p_1,p_2,p_3$ 是 $3$ 的一个排列 ③
* $a_{i,j}\geq3$ ④

则满足必有三个点构成的三角形的重心是整点
现在只要说明**不存在九个整点不满足其中任意一个**即可
由于要使④不成立，则必有 $5$ 个 $A$ 中元素不为零（抽屉原理）
由于 $A$ 中每一行，每一列都是轮换对称的，不妨设 $a_{2,2}&gt;0$
再分两种情况：（以下图中红框为大于零，蓝框为零，橙色、紫色框中至少有一个为零，绿线两头至少有一个为零）
**1. 有一个角上不为零**
由于 $A$ 是旋转对称的，不妨设 $a_{1,1}&gt;0$
此时 $a_{3,3}=0$（不然就满足③了）
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210728205200791-1649724340.png)
经枚举，不存在
**2. 有一个棱上不为零**
由于 $A$ 是旋转对称的，不妨设 $a_{2,1}&gt;0$
此时 $a_{2,3}=0$（不然就满足①了）
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210728205208191-119428778.png)
经枚举，不存在
### 综上，必有三个点构成的三角形的重心是整点，原命题得证</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15082780.html</id>
    <title type="text">找欧拉回路为什么要回溯的时候存？-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-07-30T14:29:00Z</published>
    <updated>2021-07-30T14:29:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15082780.html" />
    <content type="text">[题目](https://www.luogu.com.cn/problem/P1341)
由题可知，优先选字典序小的字符
例如：
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210730220859451-366401573.png)
此时有两个奇点 $a$ 和 $b$
优先选 $a$
若正序保存
则序列为
$$a,b,c,d$$
显然这不是正解
则回溯的时候存
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210730221422166-929524085.png)
则序列为
$$b,d,c,a$$
$reverse$ 一下
$$a,c,d,b$$
正确✔
为何？
因为：
![](https://img2020.cnblogs.com/blog/2213867/202107/2213867-20210730222856505-398814747.png)
```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,head;
char a[2];
int b[130][130];//存图
int deg[130],fa[130];//deg存储度数，fa存储父亲，用来并查集判断是否联通
char ans[1330];//稍大于51*52/2
int find(int x) {
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void dfs(int x) { //找欧拉回路/路径
	for(int i=64; i&lt;=125; i++)
		if(b[x][i]) {
			b[x][i]=b[i][x]=0;
			dfs(i);
		}
	ans[n--]=x;//因为是回溯的时候存，所以倒着存!!!!!!!
}
int main() {
	cin&gt;&gt;n;
	for(int i=64; i&lt;=125; i++)fa[i]=i;
	//A在ASCII码表里为65，z为122，所以64~125就足够了
	for(int i=1; i&lt;=n; i++) {
		cin&gt;&gt;a;
		b[a[0]][a[1]]=b[a[1]][a[0]]=1;
		deg[a[0]]++;
		deg[a[1]]++;
		int xx=find(a[0]),yy=find(a[1]);
		fa[xx]=yy;
	}
	int cnt=0;
	for(int i=64; i&lt;=125; i++)
		if(fa[i]==i&amp;&amp;deg[i])cnt++;//祖宗结点
	if(cnt!=1) {
		cout&lt;&lt;"No Solution"&lt;&lt;endl;    //如果不是连通图
		return 0;
	}
	cnt=0;
	head=0;
	for(int i=64; i&lt;=125; i++) {
		if(deg[i]&amp;1) {
			cnt++;
			if(head==0)head=i;//顺道存储起点
		}
	}
	if(cnt&amp;&amp;cnt!=2) {
		cout&lt;&lt;"No Solution"&lt;&lt;endl;
		return 0;
	}
	//如果有奇数度数的点，并且不是两个，说明不存在欧拉回路/路径
	if(head==0)//如果是欧拉回路
		for(int i=64; i&lt;=125; i++)
			if(deg[i]) {
				head=i;    //找欧拉回路的起点
				break;
			}
	dfs(head);
	cout&lt;&lt;ans;
	return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15138057.html</id>
    <title type="text">狄利克雷卷积重要公式及定义-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-11T00:39:00Z</published>
    <updated>2021-09-11T00:39:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15138057.html" />
    <content type="text">## Upd 2023年5月27日

积性函数和完全积性函数在推式子的时候几乎没用，唯一的用处在可以用欧拉筛快速求值。

## Upd 2022年8月5日
$$
d(ij)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]
$$
考虑 $(ij)$ 的每一个素因子，设为 $p^{k_i+k_j}$，则有 $k_i+k_j+1$ 种取法，而 $[\gcd(x,y)=1]$ 限制了 $i,j$ 合并时 $k_i'$ 和 $k_j'$ 至少有一个是 $0$，共 $k_i+k_j+1$ 种，得证。

## Upd 2022年8月2日

$\text{Powerful Number}$（以下简称 PN）指的是其所有素因子的幂均 $&gt;1$ 的数。

**结论：** $[1,n]$ 范围内的 PN 个数为 $O(\sqrt n)$。

**证明：**

由于 $2,3$ 完全背包可以得出 $&gt;1$ 的所有自然数，所以任意 PN $n$ 必然可以拆解为 $n=a^2b^3$ 的形式。

&lt;details&gt;
&lt;summary&gt;接下来就是 dirty work&lt;/summary&gt;

$$\begin{aligned}
|PN|&amp;\le \sum_{i=1}^n[i\text{ can turn into }a^2b^3]
\\&amp;=\sum_{a=1}^{\lfloor\sqrt n\rfloor}\lfloor\sqrt[3]{\frac{n}{a^2}}\rfloor
\\&amp;=O(\int_1^{\sqrt{n}}\sqrt[3]{\frac{n}{a^2}}\, \text{d} a)
\\&amp;=O(n^{1/3}\int_1^{\sqrt{n}}a^{-2/3}\, \text{d} a)
\\&amp;=O(n^{1/3}a^{1/3}|_{1}^{\sqrt{n}})
\\&amp;=O(n^{1/3}n^{1/6})
\\&amp;=O(\sqrt n)
\end{aligned}$$
&lt;/details&gt;

## Upd 2022年7月23日

[P5495 Dirichlet 前缀和](https://www.luogu.com.cn/problem/P5495)

将每个数看作素因数分解每维坐标为素数的幂的超空间的点，则我们其实在做高维前缀和（FMT），时间复杂度 $O(n\log \log n)$（埃氏筛复杂度）

```cpp
For(i,1,pt)
	for(int j=1;j*p[i]&lt;=n;j++)
		a[p[i]*j]+=a[j]; 
```

## Upd 2022年7月22日

$$\sum_{i|n}\mu(i)=[n=1]$$
判断 $n$ 是否有非 $1$ 因子。
$$\sum_{i^2|n}\mu(i)=[n\text{ square free}]$$
判断 $n$ 是否有非 $1$ 平方因子。

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

设 $n=p^2q$，其中 $q\text{ square free}$。
$$\begin{aligned}
\sum_{i^2|n}\mu(i)&amp;=\sum_{i^2|p^2}\mu(i)
\\&amp;=\sum_{i|p}\mu(i)
\\&amp;=[p=1]
\\&amp;=[n\text{ square free}]
\end{aligned}$$

&lt;/details&gt;

进一步
$$\sum_{i^k|n}\mu(i)=[n\ k\text{-th power free}]$$
本质是素因数分解后指数对 $k$ 的商和余数。

# Definition

## 完全积性函数
单位函数

$$\varepsilon(n)=[n=1]$$

幂函数

$$Id_k(n)=n^k$$

特别地，有：
* $k=0$ 时，为常数函数 $$I(n)=1$$
* $k=1$ 时，为恒等函数 $$Id(n)=n$$

## 非完全积性函数的积性函数

除数函数

$$\sigma_k(n)=\sum\limits_{d|n}d^k$$

特别地，有：
* $k=0$ 时，为个数函数 $$d(n)=\sum\limits_{d|n}1$$
* $k=1$ 时，为因数函数 $$\sigma(n)=\sum\limits_{d|n}d$$

欧拉函数

$$\varphi(n)=n\prod\limits_{p|n}(1-\frac{1}{p}) \ \ \ (p\in prime)$$

莫比乌斯函数

$$\begin{aligned}\mu(n) &amp; =[\max(\alpha_1,\alpha_2,\dots,\alpha_k)\leqslant1]\times(-1)^k \\ &amp; =\begin{cases}1&amp;n=1\\(-1)^k&amp;n=p_1 \ p_2 \ p_3 \ ... \ p_k \ \ \ (p_i\in prime)\\0&amp;otherwise\end{cases}\end{aligned}$$

其中 $\alpha_i$ 表示第 $i$ 个质因数的指数，这里默认 $\max(\varnothing)=0$。

# Formula
 
若 $f,g$ 皆为积性函数，则 $f*g$ 也是积性函数。

$$f*g=g*f$$

$$(f*g)*h=f*(g*h)$$

$$f*(g+h)=f*g+f*h$$

$$\text{Id}_k*I=\sigma_k$$

$$\varphi*I=Id \ \Leftrightarrow \ Id*\mu=\varphi$$

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

考虑 $n=\sum_{d|n}\varphi(d)=\sum_{d|n}\varphi(n/d)$ 的意义：设 $\le n$ 的正整数 $x$，枚举 $d=\gcd(n,x)$，$x/d$ 合法数量就是 $\varphi(n/d)$（$n/d$ 和 $x/d$ 要互质）。
&lt;/details&gt;

$$I*I=d$$

莫比乌斯函数与常数函数互为狄利克雷逆：
$$\mu*I=\varepsilon$$

莫比乌斯反演定理：
$$f=I*g \ \Leftrightarrow \ g=\mu*f$$
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15141222.html</id>
    <title type="text">有趣的概率问题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-08-14T09:04:00Z</published>
    <updated>2021-08-14T09:04:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15141222.html" />
    <content type="text">[这里](https://www.zhihu.com/question/330408241)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15174087.html</id>
    <title type="text">LaTeX 常用公式-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-08-29T03:37:00Z</published>
    <updated>2021-08-29T03:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15174087.html" />
    <content type="text">## Upd 2024年1月4日

映射
$$\mapsto$$

## Upd 2023年7月12日

$$
2\text{KMnO}_4\overset{\Delta}=\text{K}_2\text{MnO}_4+\text{MnO}_2+\text{O}_2\uparrow
$$

## Upd 2022年9月21日

斯特林数
$$
{a\brace b}{c\brack d}
$$
基向量
$$
\hat\imath\hat\jmath\widehat{qwq}
$$
上下划线（下降幂）
$$
\bar a\ \overline{bc}\ \underline{cde}
$$
上下水平大括号
$$
\underbrace{\overbrace{a+b}^{2}+c}_{3}
$$
黑红梅方
$$
\spadesuit\heartsuit\clubsuit\diamondsuit
$$
章节
$$
\P \ \S
$$

## 基础

行内公式 $\dfrac{F}{S}=\displaystyle\sum p$ 这样变大为行间公式的大小。

行间公式

$$\textstyle\frac{F}{S}=\sum p$$

这样变小为行内公式的大小。

## 符号

$\leqslant \geqslant$ 珍爱生命，请用：$\le \ge$

$\pm\dfrac{1}{a}$

$\bmod \equiv \pmod{p}$

$\% \&amp; \_$

$\in \subseteq \subsetneq$

$\cap \cup \lor \land$

$\forall \exists$

$\perp \angle \ 1^\circ$

$\sqrt[n]{x}$

$\cong\sim$

$\because \therefore$

$\not\! 5 \ne \nleqslant \notin \nsubseteq \nexists$

## 矩阵

$$
\begin{bmatrix}
a&amp;{\color{blue}\dots} &amp;b
\\
\vdots&amp;\ddots &amp;\vdots
\\
c&amp;{\color{green}\cdots} &amp;d
\end{bmatrix}
\begin {matrix}a&amp;b\\c&amp;d\end {matrix}
\begin{vmatrix}a&amp;b\\c&amp;d\end{vmatrix}
\begin{Bmatrix}a&amp;b\\c&amp;d\end{Bmatrix}
\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}
$$

## Aligned &amp; Cases

$\begin{aligned} a_1 &amp; = 1 \\ a_2 &amp; = 2 \\ &amp; \dots \\ a_n &amp; = n \end{aligned}$

$f(x)=\begin{cases} x &amp; x\geqslant0 \\ x^{-1} &amp; x&lt;0 \end{cases}$

## 箭头

$\implies \iff$

$\uparrow\downarrow\leftarrow\rightarrow\leftrightarrow\updownarrow$

$\Uparrow\Downarrow\Leftarrow\Rightarrow\Leftrightarrow\Updownarrow$

## 函数

$\text{qwq}(x,y)\gcd(x,y)\min(x,y)\max(x,y)$

$\text{Sort}_{id=0}^{n-1}\max\limits_{m=1}^p\sum\limits_{i=1}^n\prod\limits_{j=1}^n\lim\limits_{k\to\infty}\int_{i}^{j}e^x \text dx$

## 括号

$\binom{4}{2}$

$\left(\dfrac{y}{x+\dfrac{2}{3}}\right)^5$

此功能(使用 `\left` 和 `\right`)可以推广到不同的括号

$\left\lfloor\dfrac{\lceil\frac{1}{2}\rceil}{2}\right\rfloor $

## Array

$$
\begin{array}{|lcr|c|}
  \hline
  \text{left} &amp; \text{center} &amp; \text{right} &amp; \text{vertical dividing}
  \\
  \hline
  \Box &amp; \Box &amp; \Box &amp; \text{hline}\downarrow
  \\
  \hline
  \Box\Box &amp; \Box\Box &amp; \Box\Box &amp; \text{no hline}\downarrow
  \\
\end{array}
$$

$$
\begin{array}{rcl|c}
  \text{use} &amp; = &amp; \text{array} \qquad &amp; \text{(or)}
  \\
  &amp; \ge &amp; \text{aligned}^{[1]} &amp;
  \\
  \text{is} &amp; = &amp; \text{up}+\text{to}+\text{you} &amp; \blacksquare
  \\ \hline
  ^{[1]}\text{114514}
\end{array}
$$

$$
\boxed{
\begin{array}{l}
\textbf{def: } \mathrm{five}(a,b)
\\ \qquad
\textbf{if } (a \text{ is a leaf node})
\\ \qquad\qquad
\textbf{return } b
\\ \qquad
\textbf{else}
\\ \qquad\qquad
\textbf{return } a
\\ \qquad
\textbf{endif.}
\\
\textbf{enddef.}
\end{array}
}
$$

## 字体与希腊字母

$\text{对任意的 } x &gt; 0 \text{，有 } f(x) &gt; 0 \text{。}$

希腊字母不放了。

$\aleph$ 希伯来文

$$
\mathbb{Aa0}\
\mathtt{Aa0}\
\mathcal{Aa0}\
\text{Aa0}\
\mathfrak{Aa0}\
\mathscr{Aa0}
$$

$$
\Huge \pi
\huge \pi
\LARGE \pi
\Large \pi
\large \pi
\normalsize \pi
\small \pi
\tiny \pi
$$

$$
\color{red}S
\color{orange}h
\color{yellow}a
\color{yellowgreen}o
\color{cyan}j
\color{blue}i
\color{purple}a
$$

$$
\blacksquare\!
\Box
\blacksquare\,
\Box\:
\blacksquare\;
\Box\
\blacksquare\quad
\Box\qquad
\blacksquare
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15200499.html</id>
    <title type="text">乘法逆元专题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-08-28T08:59:00Z</published>
    <updated>2021-08-28T08:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15200499.html" />
    <content type="text">### 正常求逆元

由费马小定理

$$a^p\equiv a\pmod{p} \quad p\in prime$$

得：

$$a^{p-2}\equiv \dfrac{1}{a}\pmod{p}$$

之后称 $a$ 关于模 $p$ 的乘法逆元为 $inv(a)$

求 $inv(a)$ 的时间复杂度为 $O(\log p)$ （快速幂）

### 线性求 $inv(i) \ (1\leqslant i\leqslant n)$ 

即要 $O(1)$ 在已知 $inv(j) \ (1\leqslant j\leqslant i-1)$ 的前提下求 $inv(i)$

推导：

将 $p$ 拆开

$$p=\left\lfloor\dfrac{p}{i}\right\rfloor\times i+p\%i$$

得

$$\left\lfloor\dfrac{p}{i}\right\rfloor\times i+p\%i\equiv 0\pmod{p}$$

两边同乘 $inv(i)\times inv(p\%i)$，得

$$\left\lfloor\dfrac{p}{i}\right\rfloor\times inv(p\%i)+inv(i)\equiv 0\pmod{p}$$

即

$$inv(i)\equiv -\left\lfloor\dfrac{p}{i}\right\rfloor\times inv(p\%i)\pmod{p}$$

其中 $inv(p\%i)$ 我们已知，就能线性求 $inv(i) \ (1\leqslant i\leqslant n)$ 啦~

### 线性求 $inv(i!) \ (1\leqslant i\leqslant n)$ 

先求出 $inv(n!)$，之后

$$inv(i!)=inv((i+1)!)\times (i+1) \ (1\leqslant i\leqslant n-1)$$

就结束了~

当然这个也可以配合 $i! \ (0\leqslant i\leqslant n-1)$ 导出 $inv(i) \ (1\leqslant i\leqslant n)$ 的取值，也就是

$$inv(i)=inv(i!)\times (i-1)! \ (1\leqslant i\leqslant n)$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15201971.html</id>
    <title type="text">我认为我有的怪癖心理-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-08-29T03:18:00Z</published>
    <updated>2021-08-29T03:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15201971.html" />
    <content type="text">## From:《怪癖心理学》

### 过度敏感造成幻觉

然而，从偶然当中也能感觉出特殊意义的敏感心理，已经很接近异常心理了。像抛物型天线一样**过度地接收信息**，**有可能把没有任何意义的噪声当成有意义的信息并接收**。仅仅是一次**偶然事件**，也会**误以为是某种具有特殊意义的事情**，就像是灵敏度过高的雷达会产生幻影一样。

对过度敏感的人来说，**细微的咳嗽声或是身边人起身时发出的声音对他们也是一种痛苦的折磨**。而在并不那么敏感的正常人看来，那样的痛苦简直难以想象。对于咳嗽声或者周围人所发出的声音，抑或擦肩而过的中学生的欢笑声，如果只是偶尔感觉那是他人在指责自己或嘲笑自己，那么这种心理很正常。但是，如果你终日都被这些声音所折磨，甚至觉得自己从这些声音中清楚地听到了别人责骂自己的话语，那你的心理可能已经踏入异常心理的领域了。

去洗手间的时候，偶尔会听到隔壁啪的一下关上玻璃窗。如果你觉得那只是偶然，那说明你的心理很健康。有些人会把那种声音理解为有人讽刺自己上厕所的行为。这种人没有把偶然的事情看成偶然，而是认为这是一种具有特殊意图或特殊关系的行为。这种心理也可以被叫作关系焦虑或被害焦虑。一旦这种症状加剧，有些人就会做某种妄想性的解释，认为是自己上厕所的声音会吵到邻居，所以自己上厕所的时候邻居才会把玻璃窗关上，更有甚者会认为邻居一直在监视自己。

有时在路上与偶然碰到的熟人打招呼，**熟人没有理会自己**，冷冷地从自己身边走了过去。正常人一般会认为那只不过是一次没有意义的偶然情况，对方一定是想着其他的事情没有注意到自己。但是，也有不少人**会思前想后，觉得肯定是有什么特殊的意义**。

这种心理一旦加剧，他们**甚至连偶尔碰到朋友时都会感到紧张**，一直犹豫自己是应该先打招呼呢，还是觉得反正朋友也不会理会自己，自己干脆先不打招呼。就这样一直在心里纠结，到最后，甚至因为不想被当成傻瓜而只是眼睁睁地盯着朋友。实际上，这样的举动会让他人误以为是挑衅，反而会给自己带来麻烦。这种人会慢慢变得害怕出门。

哲学家尼采也是从小时候开始就对任何事情都过度敏感，常常苦于自己的幻听及噩梦。年仅二十四岁就成为巴塞尔大学教授的他在大学里渐渐将自己孤立起来，经常挣扎于头痛及不良的身体状况中。最后他患上了抑郁症和被害妄想症，变得越来越害怕出门。别说在大学里教书了，就连在巴塞尔城里散散步也变得极其困难。年仅三十四岁，尼采便辞去了教授的职位。从此以后，尼采再也没有从事过一份稳定的工作。

然而，这种过度敏感的性格也必然与灵感或创造性有互通的一面。因为尼采留给后世的成就，正是从他辞去大学教授的职位时开始的。

### 完美主义是异常心理的入口

完美主义是日常生活中常见的一种心理状态，它有时会被看作一种正常心理，有时会被认定为一种**极端的异常心理**。但**完美主义和洁癖症一样，都具有强迫自己维持事物完整性及秩序性的心理倾向**。

具有完美主义特质的人，当原本计划的事情**没有按照自己所期待的方式展开**的时候，**会万分失望**，认为整件事情糟透了。

完美主义在**良性状态**时，会成为**积极向上、高水平表现的原动力**。事实上，不论是在学业上，还是在职场、家庭以及子女教育上，完美主义者经常会取得较好的成果。

学生如果做不到**要求自己在考试中拿到一份满分的答卷**，便不可能**取得优秀的成绩**；无论是创作、演奏还是参加竞技比赛，若做不到**完美无缺**，便不可能**获得让他人望尘莫及的技术性成功**。因此，**只有不断地追求完美，才能保持奋斗不息**。

正因如此，**完美主义多出现在对父母和老师言听计从的优等生身上**。他们在努力追求完美的过程中，不断积累成功的经验，**而追求完美所获得的各种成绩更强化了他们追求完美的欲望**。

然而，完美主义是一把双刃剑。完美主义使人不断向上，但当这种对完美的追求遭遇困难时，**完美主义者就会产生强烈的病态心理**，此时，完美主义者若不能**适时舍弃追求完美的心态**，这种不完美的计划之外的现实状况便会**使完美主义者陷入远超于非完美主义者的焦虑感中**。不完美的现实已成定局，无论完美主义者如何努力都无济于事，这种努力追求完美的信念只会让完美主义者**陷入痛苦的境地**。

因此，当完美主义者在工作、人际交往、恋爱或子女教育等不是只靠个人努力便能解决一切问题的领域遇到问题时，他们会很容易受挫。这种追求完美的愿望会逐渐演变为想要控制周围的事，使其按照自己的预定计划进行。但这种控制欲不可能总是顺利达成，这又会让完美主义者感到挫败。

**完美主义因此被看作一系列精神疾病和精神问题的先兆特质**。抑郁症、厌食症、焦虑症、边缘性人格障碍、酒精依赖症和身心疾病等精神疾病，以及虐待狂、工作狂、夫妻关系及其他人际关系的破裂、各种嗜癖行为，甚至自杀等异常行为，不仅与完美主义者自身所产生的精神压力有关，也与很难实现十全十美的现实息息相关。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15202217.html</id>
    <title type="text">BIBD&amp;SBIBD的矩阵题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-08-29T03:44:00Z</published>
    <updated>2021-08-29T03:44:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15202217.html" />
    <content type="text">证明不存在 $01$ 方阵 $A$ 使得：

$A^TA=\begin{pmatrix}7&amp;2&amp;\dots &amp;2\\2&amp;7&amp;\dots&amp;2\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 2&amp;2&amp;\dots&amp;7\end{pmatrix}_{22\times22}$

证明：

若 $\exists A$ 满足上述条件。

$\because A^TA=\begin{pmatrix}7&amp;2&amp;\dots &amp;2\\2&amp;7&amp;\dots&amp;2\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 2&amp;2&amp;\dots&amp;7\end{pmatrix}_{22\times22}$

$\begin{aligned} 
\therefore 
|A^TA| &amp; = 
\begin{vmatrix}7&amp;2&amp;\dots &amp;2\\2&amp;7&amp;\dots&amp;2\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 2&amp;2&amp;\dots&amp;7\end{vmatrix}_{22\times22} 
\\ &amp; = 
\begin{vmatrix}7&amp;2&amp;2&amp;\dots &amp;2\\-5&amp;5&amp;0&amp;\dots&amp;0\\-5&amp;0&amp;5&amp;\dots&amp;0\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ -5&amp;0&amp;0&amp;\dots&amp;5\end{vmatrix}_{22\times22} 
\\ &amp; = 
\begin{vmatrix}7+21\times2&amp;2&amp;2&amp;\dots &amp;2\\0&amp;5&amp;0&amp;\dots&amp;0\\0&amp;0&amp;5&amp;\dots&amp;0\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;0&amp;\dots&amp;5\end{vmatrix}_{22\times22} 
\\ &amp; = 5^{22-1}( 7+21\times 2 )
\\ &amp;= 7^2\times 5^{21}\end{aligned}$

$\because |A|^2=|A^T||A|=|A^TA|$

$\therefore |A|=\pm\sqrt{|A^TA|}=\pm7\times5^{10}\sqrt{5}$

$\because A$ 为 $01$ 矩阵。

$\therefore |A|\in \mathbb{Z}$

$\because \pm7\times5^{10}\sqrt{5}\notin \mathbb{Z}$

$\therefore$ 假设不成立，即 $\nexists A$ 满足上述条件，原命题得证。

可以推出一个结论：

不存在 $01$ 方阵 $A$ 使得：

$A^TA=\begin{pmatrix}r&amp;\lambda&amp;\dots &amp;\lambda\\\lambda&amp;r&amp;\dots&amp;\lambda\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ \lambda&amp;\lambda&amp;\dots&amp;r\end{pmatrix}_{v\times v}$

$(r,\lambda\in\mathbb{Z},v\in\mathbb{N^+},2|v,\sqrt{r-\lambda}\notin \mathbb{N})$
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15202942.html</id>
    <title type="text">FFT&amp;原根&amp;NTT&amp;MTT-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-08T10:37:00Z</published>
    <updated>2021-09-08T10:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15202942.html" />
    <content type="text">## 2023年5月25日

[之前写的 NTT 太丑了，改了一下](https://www.luogu.com.cn/record/111216800)

## 2022年7月22日

[之前写的 NTT 太慢了，CF 题被卡常了，就改了一下](https://www.luogu.com.cn/record/80674206)

## 例题

[P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)

[record](https://www.luogu.com.cn/record/77803991)

## FFT

[bilibili 3b1b视频讲解](https://www.bilibili.com/video/BV1za411F76U?spm_id_from=333.999.0.0)

核心过程：

![](https://i.loli.net/2021/09/08/1hcFmpzGtIObBwX.png)

## 原根

### Definition

若 $a$ 模 $m$ 的阶等于 $\varphi(m)$，则称 $a$ 为模 $m$ 的一个原根。$(a\in\mathbb{Z},m\in\mathbb{N^+})$

### Special Case

$p=1004535809=2^{21}\times479+1,g=3$

$p=998244353=2^{23}\times7\times17+1,g=3 \leftarrow most \ important$

$p=469762049=2^{26}\times7+1,g=3$

## NTT

非常简单。

用**原根**代替FFT中的**单位根**，**减小了常数、避免了精度误差而且方便好写**。

适用条件：**取模意义下求值且已知模数的原根**。

## MTT

如果NTT中**模数的原根布吉岛**且FFT中**精度有问题**，则MTT闪亮登场！

有如下几种：

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210908183601371-188958418.png)

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210908183628049-967310499.png)

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210908183649003-898620433.png)

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210908183710824-1725643938.png)

[P4245 【模板】任意模数多项式乘法 写了一个三模NTT](https://www.luogu.com.cn/record/111219751)

注意 MTT 是不好处理模意义下分数的，如 P3784 [SDOI2017] 遗忘的集合 这道题。

还有负数也不行（尤其是多项式乘法逆 $2C-AC^2$）如 P4239 任意模数多项式乘法逆 这道题。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15225933.html</id>
    <title type="text">Miller-Rabin and Pollard-Rho-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-04T02:17:00Z</published>
    <updated>2021-09-04T02:17:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15225933.html" />
    <content type="text">## Miller-Rabin

她是一个素数判定的算法。

首先需要知道费马小定理

$$a^{p-1}\equiv1\pmod{p}\quad p\in prime$$

和二次探测定理

$$x=1 \ or \ p-1 \iff x^2\equiv1\pmod{p}
\\ p\in prime,x\in[0,p)$$

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

正确的运用平方差公式：
$$
x^2\equiv1\implies (x+1)(x-1)\equiv 0\pmod{p}
$$
然而对于素数 $p$，有（零因子）
$$
ab\equiv0\implies a\equiv0\lor b\equiv0\pmod{p}
$$
所以原命题得证。
&lt;/details&gt;

Miller-Rabin（设要被检验的数为 $n$，$n\leqslant2 \ or \ 2\nmid n$ 的情况请特判）:

1. **将 $n-1$ 拆成 $2^{cnt}\times m\quad (2\nmid m)$ 的形式**，并随机选出一个整数 $a$ ，构造此 **Miller 序列**：
$$\begin{aligned} M_i&amp;=a^{2^i\times m}\pmod{n}\quad (0\leqslant i\leqslant cnt) \\ &amp;=\begin{cases} a^m\pmod{n} &amp; i=0 \\ M_{i-1}^2\pmod{n} &amp; i&gt;0 \end{cases} \end{aligned}$$

2. 由于费马小定理，若 $M_{cnt}\ne1$，则 $n$ 一定不是素数；若 $M_{cnt}=1$，则 $n$ **可能**是素数。

3. 若 $n$ 没有被第二步筛掉，即还有机会是素数，则研究 $M_{cnt-1}$：若 
 $M_{cnt-1}=1 \ or \ n-1$，则二次探测定理成立， $n$ **可能**是素数；否则二次探测定理不成立， $n$ 一定不是素数。

4. 若 $M_{cnt-1}=n-1$ ，则接下来**不能用二次探测定理**判定了，直接返回 $n$ 为素数。

5. 若 $n$ 没有被第三步筛掉，即还有机会是素数，则研究 $M_{cnt-2}$：若 
 $M_{cnt-2}=1 \ or \ n-1$，则二次探测定理成立， $n$ **可能**是素数；否则二次探测定理不成立， $n$ 一定不是素数。

6. 递归地使用第四第五两步，若到了 $M_0$ 还没有出结果，即 $M_i=1\quad (0\leqslant i\leqslant cnt)$ ，则返回 $n$ 为素数。

7. 重复多次上述过程，即 $a$ 多次随机。只有当每次结果都返回是素数时，最终判定结果才是素数，否则不是素数。

举个例子,

若要判定 $561=3\times11\times17$ 是否为素数:

$561-1=560=2^4\times35,cnt=4,m=35$。$a$ 取 $8$，则构造的 **Miller 序列**分别为：

$$M_0=a^{2^0\times 35}\pmod{561}=461$$

$$M_1=a^{2^1\times 35}\pmod{561}=463$$

$$M_2=a^{2^2\times 35}\pmod{561}=67$$

$$M_3=a^{2^3\times 35}\pmod{561}=1$$

$$M_4=a^{2^4\times 35}\pmod{561}=1$$

发现 $M_2$ 和 $M_3$ 不满足二次探测定理，断定了 $561$ 不是素数，事实确实如此。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
inline bool MR(ll n){//Miller-Rabin
	#define Times 80//检验次数 
	if(n&lt;2 || !(n&amp;1))return (n==2);//特判
	ll a,b,m=n-1,cnt=0;//cnt:2因子的个数 
	while(!(m&amp;1)){
		cnt++;
		m&gt;&gt;=1;
	}
	uid(R,1,n-1);//随机数init,这里用mt19937
	For(i,1,Times){
		a=Rand(R);//随机值
		a=pw(a,m,n);//快速幂
		For(j,1,cnt){
			b=a*a%n;//此时b为M_j,a为M_{j-1}
			if(b==1 &amp;&amp; a!=1 &amp;&amp; a!=n-1)//二次探测定理都不行qwq 
				return false;
			a=b;
		}
		if(b!=1)//费马小定理都不行qwq 
			return false;
	}
	return true; 
}
```
&lt;/details&gt;

发现这样常数太大，若将 `Times` 调小，则有些素数会误判。

### 优化

选取几个特定的优秀的素数作为 $a$，此时还要特判这些素数

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
inline bool mr(ll n,ll c){//用c来筛n 
    ll k=n-1,cnt=0;
    while(!(k&amp;1)){
    	k&gt;&gt;=1;
    	cnt++;
	}
	ll x=pw(c,k,n),y=x;
	if(x==1) return true;
    while(cnt--){
    	y=pw(x,2,n);
    	if(y==1 &amp;&amp; x!=n-1 &amp;&amp; x!=1) return false;
		x=y;
    	if(x==1) return true;
    }
    return false;
}
vector&lt;ll&gt; pr={2,3,5,7,13331,998244353}; //素数选得好，AC不能少 
inline bool MR(ll x){
    if(x&lt;2) return false;
    for(ll i:pr) if(x==i) return true;
    for(ll i:pr) if(!mr(x,i)) return false;
    return true;
}
```
&lt;/details&gt;

## Pollard-Rho

她是一个分解大合数的算法。

如果是你，你会如何**找到某个大整数的一个非1、非自身的因子？**

### 算法1：试除法

从 $2$ 到 $\sqrt{n}$ 枚举，判断是否为 $n$ 的因子。

时间复杂度 $O(\sqrt{n})$

### 算法2：随机数法

从 $2$ 到 $n-1$ 枚举，判断是否为 $n$ 的因子。

&gt; 这个算法看上去像是来搞笑的，简直和猴子排序不谋而合，然而它正是Pollard-Rho算法的基础。

最坏情况下的期望时间复杂度 $O(n)$

### 算法3：2的优化

从判断是否为 $n$ 的因子改成判断是否与 $n$ 不互素，之后取 $\gcd$ 即可。

最坏情况为：

$$n=p^2\quad p\in prime$$

此时期望时间复杂度 $O(\sqrt{n}\log n)$ （$\log$ 是 $\gcd$ 带来的）

为了更好得介绍下面的内容，先引入一堆——

### 生日悖论（其实不是悖论）

这只是有悖直觉而已 OvO

&gt; 一个房间里有23个人，则他们中有两人生日相同的概率超过一半（不考虑闰年）。

证明从略。

生日悖论启示我们，如果我们**不断在某个范围内生成随机整数**，**很快便会生成到重复的数**，期望大约在**根号级别**。

对于一个 $[1,N]$ 内整数的**随机生成器**，生成序列中**第一个重复数字的位置**的期望为

$$\sqrt{\dfrac{\pi N}{2}}$$

但这件事意义并没有那么大。正如虽然生日悖论是正确的，但**你不一定能在班上遇到和自己生日相同的人**，因为这个高概率是在**两两比较下才成立**的。对这些数两两进行验证，复杂度立刻退化，并没有什么进步。所以我们需要一些技巧。

### 伪随机数序列

设 $f(x)=x^2+c$（可能受[曼德勃罗集](https://baike.baidu.com/item/%E6%9B%BC%E5%BE%B7%E5%8B%83%E7%BD%97%E9%9B%86/4888291?fr=aladdin)的启发吧）

则构造序列

$$P(i)=\begin{cases} 0 &amp; i=0 \\ f(P(i-1)) &amp; i&gt;0 \end{cases}$$

和

$$P(i)_n=P(i)\pmod{x}$$


由于 $P(i)_n$ 的取值**只由上一个决定**（马尔可夫链）（$n,c$ 看作常数）且**值域有限**，则此序列一定会形成**环**。

举个例子：

取 $n=1001=7\times11\times13,c=2$ 时，序列 $P(i)_n$ 的走向为：

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210904220905870-1938467321.png)

生成的序列常常形成这样的 $\rho$ 形，这也是为什么 Pollard 把这个算法命名为 $\rho$ (rho) 算法。

### 算法4：Pollard-Rho

转换一下原问题至：**不断求出 $n$ 的一个非 $1$ 因数，直到此因数不为 $n$ 即可。**

接下来考虑如何**求出 $n$ 的一个非 $1$ 因数**。

其实就是找 $P$ 序列中两数 $x,y$（不一定相邻)，使得 $\gcd(|x-y|,n)&gt;1$

我们称**整个为 $\rho$，环（此图中的 $445\to830\to214\to753\to445$）为 $o$，$o$ 的环长为 $len(o)$**

这伪随机数序列有什么**好处**呢？其实，这个**伪随机数**生成器生成的数具有一个性质：

若 $\rho$ 上有两个数 $i,j$ 位置相差 $d\quad(len(o) \nmid d)$ （$e.g.$ 图中 $38$ 与 $214$ 相差 $3$；$445$ 与 $753$ 相差 $1$ 或 $3$ 均可），且

$$\gcd(|i-j|,n)&gt;1$$

则在 $o$ 上 $\forall x,y$ 位置相差 $d$ ,有

$$\gcd(|x-y|,n)&gt;1$$

&lt;details&gt;
&lt;summary&gt;证明&lt;/summary&gt;

$len(o) \nmid d \implies \rho$ 上位置相差 $d$ 的数不可能相同 

$$\gcd(|i-j|,n)&gt;1$$

$$\implies \gcd(|i-j|\times|i+j|,n)&gt;1$$

$$\implies \gcd(|i-j|\times|i+j|,n)&gt;1$$

$$\implies \gcd(|i^2-j^2|,n)&gt;1$$

$$\implies \gcd(|f(i)-f(j)|,n)&gt;1$$

$$\implies \dots$$

（递推）

$$\implies \gcd(|x-y|,n)&gt;1$$
&lt;/details&gt;

换言之，任意选取 $o$ 上距离为 $i\quad(0&lt;i&lt;len(o))$ 的两点 $x_i,y_i$，判断 $\gcd(|x_i-y_i|,n)$ 是否为 $n$ 的非 $1$ 因数。

**这些二元组基本上（因为距离为 $len(o)$ d 倍数的没算，由于这是概率算法，这些可忽略）代表了 $\rho$ 上的所有二元组。**

所以我们在一个 $o$ 上，对于每种距离 $i$，任意找一组 $x_i,y_i$ 判断是否有非 $1$ 因子即可。

若没找到，则 $f(x)$ 中 $c$ 换一个随机值构造 $\rho$ **重复上述步骤**即可。

那怎么**快速枚举环上每种距离的两点**呢？——

### Floyd判环算法（龟兔赛跑算法）

形象理解一下，就是**把 $\rho$ 看作飞行棋棋盘，有两只小灰鸡从 $0$ 开始，慢的（称为 $turtle$）每次走一格，快的（称为 $rabbit$）每次走两格**。

即初始

$$turtle=rabbit=0$$

每次

$$turtle:=f(turtle),rabbit:=f(f(rabbit))$$

且判断 $\gcd(|rabbit-turtle|,n)$

**由于 $rabbit$ 与 $turtle$ 之间的距离先逐渐增大，之后在环上相遇，所以两者之间的距离几乎可以取到所有可能的值。**

期望复杂度 $O(n^{\frac{1}{4}}\log n)$

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
inline ll f(ll x,ll c,ll n){
    return (/*__int128*/(lll)x*x+c)%n;
}
inline ll PR(ll n,ll c){
    ll t=f(0,c,n);//turtle 
	ll r=f(f(0,c,n),c,n);//rabbit
    while(t!=r){
        ll d=gcd(abs(t-r),n);
        if(d&gt;1)
            return d;
        t=f(t,c,n);
		r=f(f(r,c,n),c,n);
    }
    return n;//没有找到,重新调整参数c
}
```
&lt;/details&gt;

据说这个方法分解不了 $4$，所以最好特判一下。

&lt;details&gt;
&lt;summary&gt;时间复杂度的证明&lt;/summary&gt;

设 $d|n\quad(1&lt;d\leqslant\sqrt{n})$

因为 $P(i)_n$ 和 $P(i)_d$ 可**近似看为随机序列**，根据**生日悖论**可以推出其**出现循环的期望步数**分别为

$$\sqrt{\dfrac{\pi n}{2}},\sqrt{\dfrac{\pi d}{2}}$$

由于 $n&gt;d$ ，所以有极大的概率**当第一次 $P(rabbit)_d=P(turtle)_d$ 时，$P(rabbit)_n\ne P(turtle)_n$**（即 $P_d$ 比 $P_n$ 更早进入循环)

此时 

$$\begin{aligned} |P(rabbit)_n-P(turtle)_n|&amp;=|(k_{rabbit}d+P(rabbit)_d)-(k_{turtle}d+P(turtle)_d)| \\ &amp;=|(k_{rabbit}-k_{turtle})d+(P(rabbit)_d-P(turtle)_d))| \\ &amp;=|(k_{rabbit}-k_{turtle})d|\end{aligned}$$

**为 $d$ 的倍数，于是求 $\gcd$ 即可求出 $d$ 这个因子。**

因为 $P_d$ 的循环期望步数 $= \sqrt{\dfrac{\pi d}{2}} \approx \sqrt{d}$，而 $d\leqslant\sqrt{n}$，再乘上 $\gcd$ 的时间复杂度 $O(\log n)$，则最后是 $O(n^{\frac{1}{4}}\log n)$
&lt;/details&gt;

### 优化：倍增距离

这个方法复杂度很低了，但是这个 $\log$ 还是看得人不爽，我们考虑如何去掉它。

我们想到

$$\gcd(x,n)&gt;1 \implies \gcd(kx,n)&gt;1 \quad (k\in \mathbb{N^+})$$

所以我们可以减少求公因数的次数，即**先把一些待选数乘起来**，再统一与 $n$ 求公因数。

我们可以每隔 $1,2,4,8,16,\dots$ 个数（依次增加）求一次公因数，这样只需要求期望 $\log(n^{\frac{1}{4}})$ 次公因数。

具体做法改为（伪代码）：

1. $turtle:=rabbit:=k:=0$

2. $mul:=1$

3. $\operatorname{For}(i:1\to 2^k) rabbit:=f(rabbit),mul:=mul
\times |rabbit-turtle|$

4. $\operatorname{check\_gcd}(mul,n)$

5. $turtle:=rabbit$

6. $k:=k+1$

6. $\operatorname{goto}(step \ 2)$

~~即 $turtle$ 开启了瞬移到 $rabbit$ 身边的功能，冷却时间倍增。~~

总期望时间复杂度为 $O(n^{\frac{1}{4}}+\log(n^{\frac{1}{4}})\log(n))\approx O(n^{\frac{1}{4}})$

### 优化：固定步数

倍增距离在常数上有个缺点，就是到后面间隔很大，可能已达成目标却迟迟无法退出。

所以我们也可以龟兔赛跑算法（~~不带瞬移~~）**每隔固定步数** $C\approx \log n$ （取 $128$ 较优）就求一次公因数。

注意：**这里的固定步数不是指固定 $turtle,rabbit$ 之间的距离，而是与Floyd判环算法/龟兔赛跑算法相同，只不过将相邻的 $\gcd$ 询问堆在一起处理。**

总期望时间复杂度为 $O(n^{\frac{1}{4}}+\dfrac{n^{\frac{1}{4}}\log n}{C})\approx O(n^{\frac{1}{4}})$

网上很多模板会把这**两种方法结合**，即倍增取距离，但又规定一个上限。本人本地测试了一下，似乎**跟固定步数的时间差别不大，但 Luogu 上好像只有结合的方法能过，固定步数TLE调不出来 qwq**。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
inline ll gcd(ll x,ll y){//定义 gcd(0,x)=x 
	if(x&lt;y) swap(x,y);
	if(y==0) return x;
	return gcd(y,x%y);
}
inline ll f(ll x,ll c,ll n){
    return ((lll)x*x+c)%n;
}
inline ll PR(ll n,ll c){
    ll t;//turtle
	ll r=0;//rabbit 
    ll val;//累乘 
    ll d;//因数 
    for(int len=1;;len&lt;&lt;=1){//len:这一阶段的长度 （倍增） 
    	t=r;
    	val=1;
        For(cnt,1,len){//rabbit跑 
            r=f(r,c,n);
            val=(lll)val*abs(r-t)%n;
            if(cnt%127==0){
                d=gcd(val,n);
                if(d&gt;1)
                    return d;
            }
        }
        d=gcd(val,n);
        if(d&gt;1)
            return d;
    }
}
```
&lt;/details&gt;

#### 求最大因数（ Luogu P4718 ）

既然可以求一个因数，自然就可以求最大因数，这需要一个递归即可。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
ll ans;
void work(ll n){//求n的最大素因数-&gt;ans
	if(n&lt;=ans || n&lt;2) return ;
	if(MR(n)){//特判素数 
		ckmx(ans,n);
		return ;
	}
	ll d=n;
	uid(R,1,n-1);
	while(d==n) d=PR(n,Rand(R));//找到一个因子（不一定素） 
	while(n%d==0) n/=d;
	work(n);
	work(d);
}
```
&lt;/details&gt;

[完整呆码](https://www.luogu.com.cn/record/57558098)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15257841.html</id>
    <title type="text">std::sort 的注意事项-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-12T07:18:00Z</published>
    <updated>2021-09-12T07:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15257841.html" />
    <content type="text">[Luogu P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)

$\Large{AC}$ 代码：
```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,a[100010]; 
bool cmp(int x,int y){
    return x&lt;y;
}
signed main(){
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
    sort(a,a+n,cmp);
    for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;("\n "[i!=n-1]);
    return 0;
}
```

$\Large{TLE}$ 代码：
```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,a[100010]; 
bool cmp(int x,int y){
    return x&lt;=y;
}
signed main(){
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
    sort(a,a+n,cmp);
    for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;("\n "[i!=n-1]);
    return 0;
}
```

有木有发现就是第 $5$ 行的 `&lt;` 与 `&lt;=` 的区别...

这是由于 `std::sort` 中 `cmp(x,y)` 类似于：

&gt; 现在 `x` 在 `y` 后（右）边，`cmp` 返回 `x` 是否应该超到 `y` 的前（左）边。

那为什么 `&lt;=` 会 $\Large{TLE}$ 呢？

由于 `std::sort` 中的某些蜜汁操作，当有两个值相同的元素 $x,y$ 时，程序里会反复交换 $x,y$，导致 $\Large{TLE}$。

所以啊，

**写 `std::sort` 的 `cmp` 时，若两个元素判定为相同的，请务必输出**

$$\Large{False}$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15258307.html</id>
    <title type="text">概率期望题 切木棍-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-12T07:41:00Z</published>
    <updated>2021-09-12T07:41:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15258307.html" />
    <content type="text">接下来所说的“随机切”均指切的位置呈均匀分布。

## 一根长为 $1$ 的木棍，随机切 $2$ 刀 ，$3$ 段木棍能组成三角形的概率是多少？

**错误解法：**

以木棍中点分成 $A,B$ 两段。

若两刀均切在同一段内，则三段中最长边的长度 $\geqslant\dfrac{1}{2}$，无法组成三角形。

所以两刀分别在 $A,B$ 两段的概率为 $\dfrac{1}{2}$，即答案。

**正确解法：**

将木棍上每一个点用 $[0,1]$ 内的实数表示。

设两刀分别切在 $x,y\in [0,1]$ 的位置。

列不等式组：

$$\begin{cases}0\leqslant x\leqslant1\\0\leqslant y\leqslant1\\ \max(|x-y|,\min(x,y),1-max(x,y))&lt;\dfrac{1}{2}\end{cases}$$

绘制：

![](https://img2020.cnblogs.com/blog/2213867/202109/2213867-20210912153937331-1491621250.png)

占总面积的 $\dfrac{1}{4}$，即为答案。

## 一根长为 $1$ 的木棍，随机切 $2$ 刀 ，中间那段木棍的期望长度是多少？

$$\begin{aligned}
Ans &amp; =\int_{0}^{1}\int_{0}^{1}|x-y| \, dx \, dy \\
&amp; = \int_{0}^{1}\left(\int_{0}^{y}|x-y| \, dx+\int_{y}^{1}|x-y| \, dx\right) \, dy \\
&amp; = \int_{0}^{1}\left(y^2-\int_{0}^{y}x \, dx+\int_{y}^{1}x \, dx-y(1-y)\right) \, dy \\
&amp; = \int_{0}^{1}\left(2y^2-y+\int_{y}^{1}x \, dx-\int_{0}^{y}x \, dx\right) \, dy \\
&amp; = \int_{0}^{1}\left(2y^2-y+\dfrac{(y+1)(1-y)}{2}-\dfrac{y^2}{2}\right) \, dy \\
&amp; = \int_{0}^{1}\left(\dfrac{1}{2}+y^2-y\right) \, dy \\
&amp; = \dfrac{1}{2}+\int_{0}^{1}y^2 \, dy-\int_{0}^{1}y \, dy \\
&amp; = \dfrac{1}{2}+\dfrac{1}{3}-\dfrac{1}{2} \\
&amp; = \dfrac{1}{3}
\end{aligned}$$

## 一根长为 $1$ 的木棍，切 $2$ 刀 ，第 $1$ 刀随机切，第 $2$ 刀从第 $1$ 刀切出来的左半部分木棍里随机切，中间那段木棍的期望长度是多少？

$$\begin{aligned}
Ans &amp; =\int_{0}^{1}\left(\dfrac{1}{x}\int_{0}^{x}(x-y) \, dy \right)\, dx \\
 &amp; =\int_{0}^{1}\dfrac{x}{2} \, dx \\
 &amp; =\dfrac{1}{2}\int_{0}^{1}x \, dx \\
 &amp; =\dfrac{1}{4}
\end{aligned}$$

## Summary

$$\Large{积分YYDS}$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15354661.html</id>
    <title type="text">最大中位数问题-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-09-29T14:18:00Z</published>
    <updated>2021-09-29T14:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15354661.html" />
    <content type="text">题目：[CF1486D Max Median](https://www.luogu.com.cn/problem/CF1486D)

即给定一个长度为 $n$ 的序列 $\{a\}$，求所有长度 $\geqslant k$ 的子串中，中位数的最大值。

请记住一个套路：**二分中位数答案并将原序列按与中位数的大小关系分为两部分**。

sol:

在 $a$ 的值域内二分答案 $x$，$check$ 一下答案是否能大于等于 $x$。

因为此时我们只关心 $a_1,a_2,a_3\dots a_n$ 和 $x$ 的相对大小关系，所以我们可以构造一个序列 $\{b\}$：

$$b_i=\begin{cases} 1 &amp; a_i\geqslant x \\ -1 &amp; a_i&lt;x \end{cases}$$

此时序列 $\{a\}$ 的中位数 $\geqslant x$ 当且仅当 $\exists l\leqslant r-k+1,\sum\limits^r_{i=l}b_i&gt;0$。

维护一下 $\{b\}$ 的**前缀和**和**前缀最小值**即可 $O(n\log n)$ AC 此题
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15359471.html</id>
    <title type="text">三角形的费马点（即托里拆利点）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-10-01T08:37:00Z</published>
    <updated>2021-10-01T08:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15359471.html" />
    <content type="text">[费马问题](https://buhuibaidu.me/?s=%E8%B4%B9%E9%A9%AC%E9%97%AE%E9%A2%98)

[托里拆利点](https://buhuibaidu.me/?s=%E6%89%98%E9%87%8C%E6%8B%86%E5%88%A9%E7%82%B9)

## Q:给定三角形 $\triangle ABC$，用尺规作图作出三角形内一点 $D$ 使得 $AD+BD+CD$ 取到最小值。

## A:

### 若三角形三个角均小于 $120^{\circ}$：

则将 $\triangle ACD$ 绕点 $A$ 逆时针旋转 $60^{\circ}$ 得到 $\triangle AC'D'$。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211001161319349-1833184596.png)

再连结 $DD'$ 和 $BC'$。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211001161604969-502625065.png)

发现 $AD+BD+CD=DD'+BD+C'D'\geqslant BC'$（证明留给读者）

所以当 $B,D,D',C'$ 四点共线时 $AD+BD+CD$ 取最小值。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211001162012067-336542302.png)

显然

$$\begin{cases}\angle ADC=\angle AD'C'=120^{\circ} \\  \angle ADB=120^{\circ} \\ \angle BDC=120^{\circ}\end{cases}$$

尺规作图轻松解决（分别以三边中一边，向三角形外作正三角形，如图相连，交点即为 $D$）。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211001163412963-443510212.png)

### 若三角形有个角不小于 $120^{\circ}$：

则 $D$ 与那个不小于 $120^{\circ}$ 的角的顶点重合（证明略）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15380404.html</id>
    <title type="text">Tarjan（年早失修 漏洞百出）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-10-08T08:20:00Z</published>
    <updated>2021-10-08T08:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15380404.html" />
    <content type="text">## [Tarjan是谁](https://buhuibaidu.me/?s=Tarjan)

# Tarjan's SCCs（有向图强连通分量）algorithm

给定⼀个有向图 $G$，若存在 $rt\in V$，满⾜从 $rt$ 出发能到达 $V$ 中的所有的点，则称 $G$ 是⼀个源点为 $rt$ **流图**。

从 $rt$ 出发做 $DFS$。

## 符号表

* $fa[x]$：$x$ 节点的父亲节点

* $anc[x]$：$x$ 节点的祖先点集

* $son[x]$：搜索树中 $x$ 节点的儿子节点集

* $e[x]$：$\{y \ | \ (x \to y)\in E\}$

* $dfn[x]$：$x$ 节点的时间戳

* $sbt[x]$：$x$ 节点为根的子树点集

* $low[x]$：$x$ 节点的追溯值

$G$ 中的每条有向边 $x\to y$ 必然是以下四种之⼀：

* 枝：$x=fa[y]$

* 前：$x\in (anc[y]-fa[y])$

* 后：$y\in (anc[x]-fa[x])$

* 横：$x\notin anc[y] \ \and \ y\notin anc[x]$ 此时一定满足 $dfn[x]&gt;dfn[y]$

节点上的数字为时间戳：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211008165246325-632231524.png)

## 分析

我们在搜索树上分析，发现**“前”边没有什么用处**，因为搜索树上本来就存在从 $x$ 到 $y$ 的路径。**“后”边非常有用**，它可以和搜索树上从 $x$ 到 $y$ 的路径⼀起构成环。**“横”边要看情况**，如果从 $y$ 出发能找到⼀条路径回到 $x$ 的祖先节点，那么 $x\to y$ 就是有用的。

$low[x]$ 定义为满⾜以下条件的节点的最小时间戳：

* 该点在栈中。

* 存在⼀条从 $sbt[x]$ 出发的有向边，以该点为终点。

## $tarjan(x)$ 主体

1. $low[x]=dfn[x]=++dfn\_time$

2. $for(y:e[x])\begin{cases}tarjan(y) \ check\_min(low[x],\color{blue}{low[y]}) &amp; !vis[y] \\ check\_min(low[x],\color{red}{dfn[y]}) &amp; y\in anc[x] \\ do \ nothing &amp; otherwise\end{cases}$

3. $if(low[x]=dfn[x]) \ pop \ stack \ until \ x \ is \ popped \to a \ SCC$

**注意标红和标蓝的不能改，不能错！！！**



## Code

[P1407 [国家集训队]稳定婚姻](https://www.luogu.com.cn/problem/P1407)

```cpp
vector&lt;int&gt; e[N];
int dfn[N];//时间戳
int low[N];//追溯值
int tim=0;//时间戳计数器
int col[N];//所属 SCC （为其中一个点的 id）
int st[N];//stack
int tot=0;//stack_top
bool in[N];//是(1)否(0)在栈中
void tar(int x){
	dfn[x]=low[x]=++tim;//init
	st[++tot]=x;//进栈
	in[x]=1;
	for(int i:e[x]){
		if(!dfn[i]){//萌新
			tar(i);//递归
			ckmn(low[x],low[i]);
		}else if(in[i]){//祖先
			ckmn(low[x],dfn[i]);
		}
	}
	if(low[x]==dfn[x]){//导出 SCC
		do{
			col[st[tot]]=x;
                        //着上 x 的颜色，以后你就是 x 的人了
			in[st[tot]]=0;
		}while(st[tot--]!=x);//pop until x popped
	}
}
```

# Tarjan's BCCs（无向图双连通分量）algorithm

**与 SCC 类似，所以符号沿用**

注意此时 $low[x]$ 的定义改变，且图 $G$ 中不再存在意义上的“横”边、“前”边。

$low[x]$ 定义为满⾜以下条件**之一**的节点的最小时间戳：

* 该点在 $sbt[x]$ 中。

* 存在⼀条从该点出发至 $sbt[x]$ 中任一点的**非树边**。

剩下的分析和算法就一样了~

## 桥

**桥⼀定是搜索树上的边。**

$$x\leftrightarrow fa[x] 为桥 \iff dfn[fa[x]]&lt;low[x]$$

#### Code by FuZhenTao

```cpp
const int SIZE=100010;
int head[SIZE],ver[SIZE*2],nxt[SIZE*2];
int dfn[SIZE],low[SIZE],n,m,tot,num;
bool bridge[SIZE*2];
void add(int x,int y){
 ver[++tot]=y;
 nxt[tot]=head[x];
 head[x]=tot;
}
void tarjan(int x,int in_edge){
 dfn[x]=low[x]=++num;
 for(int i=head[x];i;i=nxt[i]){
 int y=ver[i];
 if(!dfn[y]){
 tarjan(y,i);
 low[x]=min(low[x],low[y]);
 if(low[y]&gt;dfn[x]) bridge[i]=bridge[i^1]=true;
 }
 else if(i!=(in_edge^1)){
 low[x]=min(low[x],dfn[y]);
 }
 }
}
int main(){
 cin&gt;&gt;n&gt;&gt;m;
 tot=1;
 for(int i=1;i&lt;=m;i++){
 int x,y;
 cin&gt;&gt;x&gt;&gt;y;
 add(x,y);
 add(y,x);
 }
 for(int i=1;i&lt;=n;i++){
 if(!dfn[i]) tarjan(i,0);
 }
 for(int i=2;i&lt;tot;i+=2){
 if(bridge[i]) cout&lt;&lt;ver[i^1]&lt;&lt;" "&lt;&lt;ver[i]&lt;&lt;endl;
 }
}
```

## 割点

$$x 为割点 \iff \begin{cases}| \ son[x] \ |&gt;1 &amp; x=rt\\ \exists y\in son[x] \ , \ dfn[x]\leqslant low[y] &amp; x\ne rt\end{cases}$$

#### Code by FuZhenTao

```cpp
void tarjan(int x){
 dfn[x]=low[x]=++num;
 int flag=0;
 for(int i=head[x];i;i=nxt[i]){
 int y=ver[i];
 if(!dfn[y]){
 tarjan(y);
 low[x]=min(low[x],low[y]);
 if(low[y]&gt;=dfn[x]){
 flag++;
 if(x!=root||flag&gt;1) cut[x]=true;
 }
 }
 else low[x]=min(low[x],dfn[y]);
 }
}
```

## e-DCC（边双连通分量）

设 $G$ 是无向连通图。

$$G 是 e-DCC \iff \kappa'(G)\geqslant2 \iff 任意⼀条边都包含在至少⼀个简单环中$$

只需要求出无向图中所有的桥，**把桥都删除之后，图会分成若干个连通块，每个连通块就是⼀个"边双连通分量"**。

#### Code by FuZhenTao

```cpp
int c[SIZE],dcc;
void dfs(int x){
 c[x]=dcc;
 for(int i=head[x];i;i=nxt[i]){
 int y=ver[i];
 if(c[y]||bridge[i]) continue;
 dfs(y);
 }
}
for(int i=1;i&lt;=n;i++){
 if(!c[i]){
 ++dcc;
 dfs(i);
 }
}
```

## v-DCC（点双连通分量）

$$G 是 v-DCC \iff \kappa(G)\geqslant2 \iff n(G)\leqslant2 \or 任意两点都包含在至少⼀个简单环中$$

v-DCC 的求法炒鸡麻烦，鸽了。

&gt; 由于 Tarjan $O(n)$ 求 LCA 好像并不是 Tarjan 的算法，而且倍增 $O(n\log n)$ 好用并好写，所以就不再论述了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15390822.html</id>
    <title type="text">重修 基环树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-10-10T13:38:00Z</published>
    <updated>2021-10-10T13:38:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15390822.html" />
    <content type="text">[P1453 城市环路](https://www.luogu.com.cn/problem/P1453)

即**求一棵基环树中独立集点权和最大值**。

# 我的辣鸡写法（考场上没调出来、家里写 3 hours）

先 $topo$ 找基环，对于每个环上的点，作为 $root$ 树形 $DP$，再在环上环形 $DP$ ~~即可~~。

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(register int i=j;i&lt;=k;i++)
#define N 100010
vector&lt;int&gt; e[N],cy;
int clen;
int a[N];
int deg[N];
bool vis[N];
int dp[N][2];//树上 DP 
int f[N][2][2];//环上 DP 
int n;
double k;
void topo(){
	queue&lt;int&gt; q;
	For(i,0,n-1){
		if(deg[i]==1){
			q.push(i);
			vis[i]=1;
		}
	}
	int now;
	while(!q.empty()){
		now=q.front();
		q.pop();
		for(int i:e[now]){
			if(vis[i]) continue;
			deg[i]--;
			if(deg[i]==1){
				q.push(i);
				vis[i]=1;
			}
		}
	}
	now=0;
	while(vis[now])now++;
	while(!vis[now]){
		vis[now]=1;
		cy.pb(now);
		for(int i:e[now]){
			if(!vis[i]){
				now=i;
				break;
			}
		}
	}
	clen=cy.size();
}
void dfs(int rt,int fa,int b1,int b2){
	dp[rt][0]=0;
	dp[rt][1]=a[rt];
	for(int i:e[rt]){
		if(i==fa || i==b1 || i==b2) continue;
		dfs(i,rt,b1,b2);
		dp[rt][0]+=max(dp[i][0],dp[i][1]);
		dp[rt][1]+=dp[i][0];
	} 
}
void DP(){
	For(i,0,clen-1){
		dfs(cy[i],-1,cy[(i+clen-1)%clen],cy[(i+1)%clen]);
//		cerr&lt;&lt;cy[i]&lt;&lt;":"&lt;&lt;dp[cy[i]][0]&lt;&lt;" "&lt;&lt;dp[cy[i]][1]&lt;&lt;endl;
	}
	f[0][0][0]=dp[cy[0]][0];
	f[0][1][1]=dp[cy[0]][1];
	For(i,1,clen-1) For(j,0,1){
		f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])+dp[cy[i]][0];
		f[i][j][1]=f[i-1][j][0]+dp[cy[i]][1];
	}
}
signed main(){
	scanf("%d",&amp;n);
	For(i,0,n-1) scanf("%d",a+i);
	int x,y;
	For(i,0,n-1){
		scanf("%d%d",&amp;x,&amp;y);
		e[x].pb(y);
		e[y].pb(x);
		deg[x]++;
		deg[y]++;
	}
	scanf("%lf",&amp;k);
	topo();
//	cerr&lt;&lt;"cy:"; for(int i:cy) cerr&lt;&lt;i&lt;&lt;" "; cerr&lt;&lt;endl;
	DP();
	int ans=max(f[clen-1][0][0],max(f[clen-1][1][0],f[clen-1][0][1]));
	printf("%.1lf\n",ans*k);
    return 0;
}
```

# 简便写法

随便断基环上任意一条边 $(x,y)$，图就变成了一棵树，以 $x$ 为根不能取 $x$ 的独立集更新一下 $Ans$，再以 $y$ 为根不能取 $y$ 的独立集更新一下 $Ans$，答案就出来了。

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(register int i=j;i&lt;=k;i++)
#define ckmx(a,b) if(a&lt;b){a=b;}
#define N 100010

int n,a[N],f[N],S,T,dp[N][2];
vector&lt;int&gt; e[N]; 
double k;
inline int gf(int x){ return f[x]==x?x:f[x]=gf(f[x]); }
void dfs(int rt,int fa){
//	cerr&lt;&lt;rt&lt;&lt;" "&lt;&lt;fa&lt;&lt;endl;
	dp[rt][0]=0;
	dp[rt][1]=a[rt];
	for(int i:e[rt]){
		if(i==fa) continue;
		dfs(i,rt);
		dp[rt][0]+=max(dp[i][0],dp[i][1]);
		dp[rt][1]+=dp[i][0];
	}
//	cerr&lt;&lt;rt&lt;&lt;" "&lt;&lt;dp[rt][0]&lt;&lt;" "&lt;&lt;dp[rt][1]&lt;&lt;endl;
} 
signed main(){
	scanf("%d",&amp;n);
	For(i,0,n-1) f[i]=i;
	For(i,0,n-1) scanf("%d",a+i);
	int x,y;
	For(i,0,n-1){
		scanf("%d%d",&amp;x,&amp;y);
		if(gf(x)==gf(y)){
			S=x;
			T=y;
		}else{
			e[x].pb(y);
			e[y].pb(x);
			f[gf(x)]=gf(y);
		}
	}
	scanf("%lf",&amp;k);
	int ans=0;
	dfs(S,-1);
	ckmx(ans,dp[S][0]);
	dfs(T,-1);
	ckmx(ans,dp[T][0]);
	printf("%.1lf\n",ans*k);
    return 0;
}
```
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15409081.html</id>
    <title type="text">Dev-cpp 汉化-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-10-14T14:59:00Z</published>
    <updated>2021-10-14T14:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15409081.html" />
    <content type="text">![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211014224445357-91642798.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211014224656869-1593122845.png)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15413108.html</id>
    <title type="text">2021 简思短解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-02-05T14:12:00Z</published>
    <updated>2022-02-05T14:12:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15413108.html" />
    <content type="text">[![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211015230528837-1549120109.png)](https://www.cnblogs.com/LJC00118/p/13584464.html)

## abc238_e

一道简单的题被我做成不简单的。

考场上由于这是 E 题，所以高估了这道题的难度，直接往随机大整数和线性基的方向想了。

作未知序列 $\{a\}$ 的前缀和 $\{s\}$。对于给定的 $[l,r]$，即固定了 $s_{l-1}$ 和 $s_r$ 的差值。而整个序列的和就是 $s_n-s_0$，所以利用并查集判断 $s_0$ 和 $s_n$ 的差是否固定即可（是否在同一集合内）。

## P7518 [省选联考 2021 A/B 卷] 宝石

关键条件：$P_1,P_2,\dots,P_c$ 互不相等。

**Part1:Up**

DFS 同时存祖先中每种宝石出现的位置（按 $deep$ 排序），对于每一个树上的节点 $x$，记录 向上第一个碰到的颜色为 $\{P\}$ 中**下一个**的宝石的节点编号 和 向上第一个碰到的颜色为 $\{P\}$ 中**上一个**的宝石的节点编号 为 $U_x,D_x$（对于该节点的宝石在 $\{P\}$ 中的情况），和向上第一个在 $\{P\}$ 中的宝石位置 $T_x$（对于该节点的宝石不在 $\{P\}$ 中的情况）。

将 $U,D$ 倍增处理。

离线询问，对于每一个询问，先 $O(\log n)$ 求出 LCA，再 $O(\log c)$ 贪心+倍增求出上行路径的宝石收集数。

**Part2:Down**

对于每个询问 $x\to y$（$lca(x,y)=z$），在 $y$ 节点上挂一个 struct $(lst,id,top)$ 分别表示上行已经收集的宝石数，询问的编号，$z$ 的位置。

仍然 DFS 同时存祖先中每种宝石出现的位置，当到一个节点时，遍历挂着的 structs，分别用二分+倍增 $O(\log^2 c)$ 求出答案。

具体地，二分收集宝石数，找到祖先中结尾的宝石出现的最后位置，向上用 $D$ 倍增至 $z$，判断是否能与上行的接上即可。

时间 $O(n(\log n+\log c)+q\log^2 c)$，不过有单 $\log$ 做法。

[这必须放一下代码](https://www.luogu.com.cn/record/67495198)

## P3216 [HNOI2011]数学作业

不让下载数据且超级难调的题目是屑。

由于不能 $O(n)$，我们想到 $O(\log n)$。

那肯定是快速幂啊，设 $f_n=Concatenate(n)\% m$ 考虑：

$$\begin{bmatrix}
10^k&amp;1&amp;1
\\0&amp;1&amp;1
\\0&amp;0&amp;1
\end{bmatrix}
\begin{bmatrix}
f_{n-1}\\n-1\\1
\end{bmatrix}=
\begin{bmatrix}
f_{n}\\n\\1
\end{bmatrix}$$

$k$ 为新加入的 $n$ 的十进制位数。

这里矩阵乘法指带模乘法。

对于每一种 $k$（最多 $\log n$ 种），分别做快速幂即可。

时间 $O(3^3\log^2 n)$。

[评测](https://www.luogu.com.cn/record/66764198)

## 382. K取方格数/275. 传纸条/P1006 [NOIP2008 提高组] 传纸条/P3381 【模板】最小费用最大流

**最小费用最大流 MCMF** 集合！

[专题讲解](https://www.cnblogs.com/zhangshaojia/p/15795622.html)

提交记录及本人精美代码+注释：

[K取方格数](https://www.acwing.com/problem/content/submission/code_detail/9902192/)

[传纸条](https://www.luogu.com.cn/record/66642124)

[【模板】最小费用最大流](https://www.luogu.com.cn/record/66641298)

## AT3955 [AGC023D] Go Home/agc023_d

[小粉兔的 Sol](https://www.luogu.com.cn/blog/PinkRabbit/solution-at3955)

## P2150 [NOI2015] 寿司晚宴

给定 $\sum=\{2,3,\dots,n\}(n\le 500)$，求有几种方案取两个子集 $S,T$，使得 $\forall x\in S,y\in T,\gcd(x,y)=1$。

发现 $n\le 30$ 时可以用状压 DP，其实 $n\le 500$ 也行。

由于 $n$ 最多一个 $&gt;\sqrt{n}$ 的素因数，我们存一下这个因数，没有设为 $-1$，将这些数按照这个因数升序排序，这个因数相同的每一段或者这个因数为 $-1$ 的单个元素用状压 DP，再将这些结果汇入总 DP 中，具体见[代码](https://www.luogu.com.cn/record/66344732)。

## P3224 [HNOI2012]永无乡/1063. 永无乡

**并查集 + 权值线段树合并。**

## P4178 Tree/252. 树

给定一棵**带边权**的树（$n\approx10^4$），求长度不超过 $k$ 的**路径**有多少条。

**点分治模板题**。

定根 $rt$，树上的路径只有两种情况：

* 经过或端点是 $rt$。

* 只在 $rt$ 的子树内。

对于第一类，DFS 整棵树，求出每一个点到根的距离，**容斥**即可，$O(n\log n)$，**瓶颈在排序**。

处理完第一类路径后可以在**子树里递归求解**。

那不铁定超时吗？不然。

我们**每次选择重心定根**即可，由于这样**子问题规模都减半**，总时间 $O(n\log^2n)$。

```
//Said no more counting dollars. We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(register int i=j;i&lt;=k;i++)
#define cmx(a,b) a=max(a,b)
#define gc getchar
#define pc putchar
inline int read(){
	int x=0;char c=gc();bool f=0;
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=gc();}
	if(f)x=-x;
	return x;
}
inline void write(int x){
	if(x&lt;0){pc('-');x=-x;}
	if(x&gt;9)write(x/10);
	pc(x%10+'0');
}
#define N 40010
#define All(i,s) for(int i=head[(s)];i;i=e[i].nxt)
struct edge{int to,val,nxt;}e[2*N];//前向星 
int tot,head[N];
bool vis[N];//是否当过根（重心） 
int n,k,ans;
inline void adde(int x,int y,int z){e[++tot]={y,z,head[x]};head[x]=tot;}
int sum,root,sz[N],wn[N];//gtrt 时树的大小，当前最优重心，子树大小，最大儿子大小 
inline void gtrt(int rt,int fa){//求重心 
	sz[rt]=1;wn[rt]=0;
	All(i,rt){
		int to=e[i].to;
		if(to==fa || vis[to]) continue;
		gtrt(to,rt);
		sz[rt]+=sz[to];
		cmx(wn[rt],sz[to]);
	}
	cmx(wn[rt],sum-sz[rt]);
	if(wn[rt]&lt;wn[root]) root=rt;
}
int dt[N],dtt; 
int dis[N];//到根的距离 
inline void gtds(int rt,int fa){
	dt[++dtt]=dis[rt];
	All(i,rt){
		int to=e[i].to;
		if(to==fa || vis[to]) continue;
		dis[to]=dis[rt]+e[i].val;
		gtds(to,rt);
	}
}
int calc(int rt,int len){//计算 
	dtt=0;
	dis[rt]=len;
	gtds(rt,0);
	sort(dt+1,dt+1+dtt);
	int r=dtt,res=0;
	For(l,1,dtt){
		while(l&lt;r &amp;&amp; dt[l]+dt[r]&gt;k) r--;
		if(l&gt;=r) break;
		res+=r-l;
	}
	return res;
}
void solve(int rt){
	vis[rt]=1;
	ans+=calc(rt,0); 
	All(i,rt){
		int to=e[i].to;
		if(vis[to]) continue;
		ans-=calc(to,e[i].val);//减掉多算的部分 
		sum=sz[to];wn[root=0]=n;
		gtrt(to,rt);
		solve(root);//递归 
	}
}
signed main(){
	n=read();
	tot=1;
	ans=0;
	For(i,1,n) vis[i]=head[i]=0;
	int x,y,z;
	For(i,1,n-1){
		x=read(),y=read(),z=read();
		adde(x,y,z);
		adde(y,x,z);
	}
	k=read();
	wn[root=0]=sum=n;
	gtrt(1,0);
	solve(root);
	write(ans);pc('\n');
    return 0;
}
```

## P4381 [IOI2008] Island/358. 岛屿

题意转化：给定带边权的**基环树森林**（$n\leqslant10^6$），求每一棵基环树的最长链的长度之和。

考虑单个基环树，最长链只有如下两种情况：

* 在去掉基环的边后的森林中，$O(n)$ 树形 DP 求直径取最大值即可。

* 经过基环。

对于第二种情况，记录每一个基环 $C$ 上的点 $x$，存所在子树中离她最远的点的距离 $f_x$，则答案为（设基环上的点顺时针编号依次为 $1,2,\dots,|C|$）：

$$ans=\max\limits_{i&lt;j}(f_i+f_j+dis_i-dis_j+len,f_i+f_j+dis_j-dis_i)$$

其中 $dis_x$ 表示环上 $1\to 2\to\dots\to x$ 的距离，$len$ 表示环长。

设 $g_x=f_x+dis_x,h_x=f_x-dis_x$，则：

$$ans=\max\limits_{i&lt;j}(g_i+h_j+len,h_i+g_j)$$

$O(V(C))$ 即可，最终 $O(n)$。

## 377. 泥泞的区域

**将每一个行极大泥泞块和列泥泞块看作点，单个泥泞 block 看作所在两个极大泥泞块之间的边**，题目要求的最小木板数就是这个**二分图的最小覆盖，即最大匹配**，$O(N^4)$（**匈牙利算法 $O(V\times E)$**），以下为**二分图最大匹配模板代码**。

```
//...head
bool vis[MAXN];//visited
int ma[MAXN];//女生匹配的男生，无对象则为 0 
vector&lt;int&gt; e[MAXN];//graph 
bool dfs(int rt){//帅哥 rt 找对象 
	for(int i:e[rt]){
		if(vis[i]) continue;//试过了 
		vis[i]=1;//约会 
		if(ma[i]==0 || dfs(ma[i])){//女生小 i 本来就没有对象或者把对象绿了 
			ma[i]=rt; return true;//match 
		}
	}
	return false;//男生 rt 为单身狗 
}
signed main(){
	//...input
	//...init
	int ans=0;
	memset(ma,0,sizeof ma);
	For(i,1,men){//遍历男生
		memset(vis,0,sizeof vis);//清除约会记忆 
		if(dfs(i)) ans++;//世上又多了一对 
	}
	cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
```

## 348. 沙漠之王

**最优比率生成树**模板。

用 0/1 规划，假设答案为 $x$，设所有边 $(i,j)$ 的边权为 $cost(i,j)-x\times dis(i,j)$，用 Prim 判断最小生成树总长是否小于 $0$ 二分即可。

注意这里为实数二分，我用的**固定二分次数**。

## arc132_d

转化好题。

给定两个 $01$ 串 $s,t$，两串 $0$ 的个数都为 $n$，$1$ 的个数都为 $m$。两个等长的 $01$ 串之间的**距离 $d(a,b)$** 定义为最小的邻项交换次数使得 $s,t$ 可以互相变换。一个 $01$ 串的**价值 $v(a)$** 为相邻两项值相同的个数（$e.g.\ s=\mathtt{00111},v(s)=3,t=\mathtt{01010},v(t)=0$）。求：

$$\min\limits_{d(s,x)+d(x,t)=d(s,t)}v(x)$$

发现 $0,1$ 分别的个数不随操作而改变，联想到（我考场上没想到）$\binom{n+m}{n}$ 和平面中从 $(0,0)$ 走到 $(n,m)$ 的方案。

是的，我们**将 $01$ 串转化成一条 $(0,0)\to(n,m)$ 的折线**。

**结论：$d(s,x)+d(x,t)=d(s,t)\iff$ 表示成路径后 $x$ （被夹）在 $s,t$ 的路径之间。**

证明看官方题解，不再赘述。

于是有了贪心策略：

1. 枚举 $x$ 的起始方向（上或右）（即字符串的第一位 $0/1$）。

2. 贪心地直走，“碰壁”转弯。

3. 更新答案。

我们可以通过证明有不“碰壁”转弯的 $x$ 路径，一定有转弯次数不比她少的 $x'$ 不“碰壁”转弯出现在其之后，来证明贪心是对的（证明看官方题解 qwq）。

[官方题解](https://atcoder.jp/contests/arc132/editorial/3205)

## P4180 [BJWC2010]严格次小生成树

结论：**必有一个严格次小生成树与最小生成树的对称差的边数为 $2$。**

先用 Kruscal 求出最小生成树，再**枚举每一条非树边，加入树边，再在树边中删掉一条使得仍然是树，计算答案**。

然而这样是 TLE 的，我们考虑**维护枚举的非树边两端在树上的路径中边权的最大值、严格次大值**（因为题目要求严格次小生成树，所以要存严格次大），在之中断掉一条边使得新的树严格次于最小生成树，**再在这些答案中取 $\min$ 即可**。

路径中边权的最大值、严格次大值可以用**树上倍增** $O(\log n)$ 实现，总时间 $O(n\log n)$。

## 202. 最幸运的数字

题意：求最小的正整数 $N$ 使得 $L | \dfrac{8}{9}(10^N-1)$，不存在则输出 $0$。

变形：

$$\dfrac{9L}{\gcd(8,L)} | 10^N-1$$

设 $M=\dfrac{9L}{\gcd(8,L)}$，则：

$$10^N\equiv 1\pmod{M}$$

如果 $\gcd(10,M)&gt;1$，则必然无解，输出 $N=0$。

否则，由[欧拉定理](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/891345?fr=aladdin#2)得到：

$$10^{k}\equiv 1\pmod{M}\implies k|\varphi(N)$$

我们用 $O(\sqrt{n})$ **计算 $\varphi(N)$** 并 $O(\sqrt{\varphi(N)})$ **枚举其因数**，$O(\log \varphi(N))$ **快速幂**判断是否合法，总时间 $O(\sqrt{n}+\sqrt{\varphi(N)}\log \varphi(N))$。

由于快速幂中模数最大 $10^{10}$ 级别，所以不要忘了**龟速乘**！不要忘了龟速乘！不要忘了龟速乘！

## CF1606F Tree Queries

**根号算法**万岁！

答案一定非负，那么对于一个 $k$ 的 $m$ 上界是 $\dfrac{n}{k}$ 的，于是我们考虑根号分治。

考虑当 $k&lt;\sqrt{n}$ 时，我们直接进行树上 DP，设 $f_{i,j}$ 表示 $i$ 的子树里当 $k=j$ 时的答案，那么转移的时候我们直接考虑当前子节点删不删，这样这部分复杂度就是 $O(n\sqrt{n})$ 的。

然后考虑当 $k\geqslant\sqrt{n}$ 的时候，一定有 $m\leqslant \sqrt{n}$，这样的话考虑树形背包，记 $g_{i, j}$ 表示 $i$ 子树里删 $j$ 个点的最大儿子数，这样进行树形背包，考虑每个儿子删不删，由于树形背包的复杂度是 $O(nm)$ 的，所以这部分复杂度就是 $O(n\sqrt{n})$。

不过如果直接这么做空间会萎，于是你把询问离线下来，分成两部分做就不会 MLE 了。

## 219. 剪纸游戏

模板**博弈 SG 函数**。

对于一个状态：

* 若分情况（即一场游戏走一条路），则为 $\operatorname{mex}$。

* 若分子游戏（即所有路一起走），则为 $\operatorname{xor}$。

```
int f[N][N];//记忆化
int sg(int x,int y){
	if(f[x][y]!=-1) return f[x][y];
	unordered_set&lt;int&gt; S;
	For(i,2,x-2) S.insert(sg(i,y)^sg(x-i,y));
	For(i,2,y-2) S.insert(sg(x,i)^sg(x,y-i));
	int pos=0;
	while(S.find(pos)!=S.end()) pos++;
	return f[x][y]=f[y][x]=pos;
}
```

## CF1280D Miss Punyverse

显然先将 $w-b$ 作为点权，题意即为**将这棵树划分为 $m$ 个连通块，最大化点权和为正数的连通块个数**。

想到树形背包，状态 $f_{i,j}$ 表示以 $i$ 为根的子树**分成了 $j+1$ 块，点权和为正数的连通块个数的最大值**。

但是这样转移不了，再定义一个 $g_{i,j}$ 表示 $i$ 为根的子树中**分成了 $j+1$ 块，点 $i$ 所在的连通块的点权和的最大值**。

特殊地，$g_{i,j}=0$ 可以表示不将根节点 $i$ 的连通块与祖先连通，即闭关锁国，此时一共**分成 $j$ 块而不是 $j+1$**。

转移见[代码](https://www.luogu.com.cn/record/65443912)。

转移后再更新一下：是否从开放至闭关能获得更大结果，即可。

## P1600 [NOIP2016 提高组] 天天爱跑步

小小紫题，耗我两天 qwq。

**“LCA+桶+树上差分”**

发现我们要处理树上的路径，必定要**求 LCA，用倍增即可**。

如果一个观察员 $P$ 能够准时看到 $s\to t$ 路线上的人在跑步，则**满足任一**：

1. $W(P)+deep(P)=deep(s)\land P\in anc(s)\land P\not\in anc(lca(s,t))$

2. $W(P)-deep(P)=dis(s,t)-deep(t)\land P\in anc(t)\land P\not\in anc(lca(s,t))$

发现两部分的处理方式类似，我们着重讲第 $1$ 种。

可以做树上差分。

将树**建 DFS 序**（每个点只有第一次才到 DFS 序里），将路径拆成底端加，顶端的 $fa$ 减的差分形式，这样可以用桶扫一遍 DFS 序，每到一个点就相应的修改，用**前缀和相减**的方式即可求出 $P$ 为根的子树内的操作的集合，$P$ 的答案即为桶中下标为 $W(P)+deep(P)$ 的值。

[Code](https://www.luogu.com.cn/record/65284541)

## P1054 [NOIP2005 提高组] 等价表达式

~~我写了两天 qwq。~~

题目就是求与给出的代数式恒等的有哪些（变量只有 $a$）。

想到评测机对提交者代码的做法，想到：

**我们可以多代入一些 $a$ 的值来 check 两个代数式的值是否相同。**

接下来就是计算一个无变量的式子了，但在实操中发现对于负号 `"-"` 的特判极其难弄：

* 不能以负号分裂求解 $e.g. 1-2+3\not=1-(2+3)$

* 要将负号提出幂次不至于正负颠倒 $e.g. -3^4\not=(-3)^4$

* $\dots$

我突发奇想：是否将 string 中的所有 `"-"` 替换成 `"+b*"`（如果在最左端改成 `"b*"`）即可算出同样的效果？（$b=-1$）

答案是肯定的。

原因是负号的优先级与乘号相同……

这样做即可，细节看代码。

[Code](https://www.luogu.com.cn/record/65019831)

## P5110 块速递推

先计算得到**通项公式**：

$$f_n=a(b^n-c^n)\% mod$$

其中

$$a=233230706,b=94153035,c=905847205,mod=10^9+7$$

发现 $O(T\log N)$ 在 $T=5\times 10^7,N=1.8\times 10^{19}$ 的数据下根本过不了。

优化：

由于 $x^y\equiv x^{y\%(mod-1)}\pmod{mod}$，将 $N$ 降到 $10^9$ 级别。

于是瞟一眼题目“块速递推”，想到**分块加速幂运算**。

拆 $n=xB+y\quad(B=65536\land x,y&lt;B)$，以 $b$ 为例，预处理出 $b^{kB}$ 和 $b^k\quad(0&lt;k&lt;B)$ 即可 $O(1)$ 得 $b^n=b^{xB}\times b^{y}$。

时间 $O(T)$。

## P1471 方差

建线段树，每个节点存区间的和及平方和。

$$avg=\dfrac{sum}{len},s^2=\dfrac{len\times sos-sum^2}{len^2}$$

区间修改，区间询问 打懒标记即可。

## arc131_d

~~我可能永远不会猜结论 qwq~~

**结论零**：

标枪的位置只取整数即可。

**结论一**：

相邻的两个标枪一定相距正好 $D$。

**结论二**：

第 $x=\left\lceil\dfrac{n+1}{2}\right\rceil$ 个标枪一定在 $[0,D]$ 位置范围内。

于是有了想法：

设 $a_i\quad (0\leqslant i\leqslant D)$ 表示 $x-1$ 个标枪分别插在 $i,i+D,i+2D,\dots,i+(x-2)D$ 的位置时的分数。

设 $b_i\quad (0\leqslant i\leqslant D)$ 表示 $n-x+1$ 个标枪分别插在 $i,i+D,i+2D,\dots,i+(n-x)D$ 的位置时的分数。

最终答案即为 $\max\limits_{i=0}^D(a_i+b_{D-i})$。

问题就在于如何求 $\{a\},\{b\}$。

以下以 $\{a\}$ 为例。

考虑每一段相同分值的区间，计算每一个 $i$，这段对于 $a_i$ 的贡献，发现这些贡献只有可能为 $y$ 和 $y+1$（即相差不过 $1$，这算**结论三**吧 qwq），而且贡献为 $y+1$ 的只是连续的一段（特别地，当同余类里包含了 $0$，要分成前后两段），用差分数组维护即可。

时间复杂度：$O(m+D)$。

## P2375 [NOI2014] 动物园

对于字符串 $S$（长度为 $n\leqslant 10^6$）的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀**不重叠**，将这种字符串的数量记作 $num_i$，求 $\{num\}$。

KMP 求 $nxt$ 数组，倍增跳即可。

时间 $O(Tn\log n),T\leqslant 5$，极其卡常，过不了。

但是，**将倍增数组的两维交换**（即代表 $2^k$ 那一维放前面），这样**数组指针**只会单次增减 $O(1)$，实测能基本快一倍，能过。

## P2486 [SDOI2011]染色

树剖，线段树维护区间连续颜色块数量和两端颜色。

## P7950 [✗✓OI R1] 后方之水

通过生成函数计算得答案为：

$$\binom{S+1}{n+1}\binom{n}{2}$$

$O(n)$ 计算即可。

## P1450 [HAOI2008]硬币购物

先作完全背包，再用容斥原理减掉多算的。

P7883 平面最近点对（加强加强版）

期望 $O(n)$ 的算法：

先将点 $rand\_shuffle$ 一下，保证随机，维护前缀点集的答案。

记前 $i$ 个点的答案为 $d_i$。

我们将全平面划分为边长为 $d_i$ 的正方形网格。将前 $i$ 个点丢到网格里，可以发现每个正方形中最多只有 $3$ 个点。

对于新加入的第 $i+1$ 个点，只需检查它所属的正方形周围 $9$ 个正方形中的所有备选点。

如果 $d_{i+1}\ne d_i$，则需要 $O(i)$ 重构整个网格。但由于第 $i$ 个点只有 $\frac{1}{i}$ 的概率更新答案，故总复杂度仍为 $O(n)$。

需要使用哈希表存储每个方格中的点。

## AcWing326

将二进制的每一位分开考虑期望。

设 $f_x$ 表示 $x\to n$ 随机路径边权异或和的当前二进制位的期望（即为 $1$ 的概率）。

$$f_x=\dfrac{1}{deg_x}\sum_{y\in N(x)}(f_y[val(x,y)=0]+(1-f_y)[val(x,y)=1])$$

其中 $N(x)$ 为 $x$ 的开领域，$val(x,y)$ 为 $(x,y)$ 这条边当前二进制位的权值。

由于该式子有后效性，用高斯消元即可。

总共 $O(32n^3)$。

## P4054

注意到值域只有 $100$，可以作 $100$ 个数据结构来二维单点修改，矩阵查询。

而且 $n\times m$ 很小（否则就要用树套树或 CDQ 分治了 qwq），直接二维树状数组（本蒟蒻初学）维护每一种值即可。

时间 $O(100nm\log(nm))$。

## P4396

经典**莫队**的变形。

sol 1:

莫队区间移动时实时维护一个数组表示某个值在区间内出现的次数和是否出现。

再用树状数组维护它。

最终复杂度 $O(n\sqrt{m}\log n+m\log n)$。

跑得慢，不知道能不能过。

sol 2:

在 sol 1 的基础上将树状数组换成分块维护，实现 $O(1)$ 修改，$O(\sqrt{n})$ 查询。

最终复杂度 $O(n\sqrt{m}+m\sqrt{n})$，能过。

## P3863

将区间修改和单点查询离线下来。

扫描线按序列 $1\to n$ 顺序扫描。

如果碰到修改的左端点，则扫描线上该时刻及以后的时刻加上对应的值。

如果碰到修改的右端点，则扫描线上该时刻及以后的时刻减去对应的值。

如果碰到一个询问，则求扫描线上该时刻以前的时刻中询问值的 rank。

扫描线上用分块即可。

## P2163

**二维静态数点模板题**

先对 $y$ 坐标进行离散化。

对于每一个矩形询问，拆分成四个二维前缀和询问。

从左往右扫，维护一个树状数组存目前扫过的各个 $y$ 上的点的个数。

当扫到一个二维前缀和询问 $(x,y)$ 的 $x$ 时求树状数组中 $pre(y)$ 的值即为该询问的答案。

[对 $x,y$ 两维都离散化了的屑程序](https://www.luogu.com.cn/record/61434702)

## CF1582G

维护一个序列 $L_i$ 表示第 $i$ 位为右端点的子串的最大左端点下标，可对每个素数用 vector 存当前还有哪些位置上的数是该素数的倍数且没有被抵消，一边更新一边扫当前 $a_i$ 的素因数求出 $L_i$。

再对 $L_i$ 开线段树，每次将 $query(i,i)\quad(1\leqslant i\leqslant n)$ 累加得到答案。

$query(x,y)$ 表示 $L_x\to L_n$ 中最长前缀使得所有该前缀中的 $L_i$ 均不小于 $y$，该前缀的长度。

## P2633

比 P3302 少了 Link 操作，稍加修改 P3302 的代码即可。

## P3302

对每个点存该点到根节点的所有点权的可持久化值域线段树（点权离散化后）。

Link 时启发式合并。

Query 时四个值域线段树相加减搜索第 $k$ 小即可。

## P1972

对每个位置 $x$ 存前一个颜色相同的位置 $pre_x$。

顺序遍历数组，当前为 $a_x$，维护树状数组，每次 $add(x,1)$ 并且 $add(pre_x,-1)$。

当遍历到了某一个询问 $[l_i,r_i]$ 的右端点 $r_i$，$ans$ 为 $sum(r_i)-sum(l_i-1)$。

## CF1446D2

猜结论:子串长度取最大值时其中一个众数必为全局众数。

根号分治即可，其中之一用尺取法。

[巨佬的题解](https://www.luogu.com.cn/blog/infinity-dimension/solution-cf1446d2)

## P4592

对于 1 操作，用 DFS 序+可持久化 01trie 维护。

对于 2 操作，可持久化 01trie 维护到根节点的所有值。

## P3834

离散化后维护数组的前缀值域可持久化线段树，每次按照对应的子树大小之差二分查找。

$$O((n+q)\log n)$$

## P7447

值域倍增分块。

[奆佬的题解](https://www.luogu.com.cn/blog/111055/solution-p7447)。

## CF438D

考虑 $x\%p$ 的情况：

$$\begin{cases}x\%p=x ,x&lt;p\\x\%p\leqslant\dfrac{x}{2} ,x\geqslant p\end{cases}$$

所以一个数的有意义取模（$x\%p\ne x$）最多进行 $\log x$ 次。

线段树暴力（无懒标记）解决即可。

## P4198

斜率预处理+线段树 $O(m\log^2n)$ 维护（单点修改后每层 $push\_up$ 时 $O(\log n)$ 递归求解）。

## CF1583E

先按度的奇偶来判断，奇点个数 $cnt&gt;2$ 则 NO 并输出 $\frac{cnt}{2}$

否则建原图的任意生成树，求 $q$ 组两点间路径记录途径点即可。

## P2709

莫队模板

## CF1598E

二维数组斜着开 set 记录位置，每次 upd 计算差值</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15415540.html</id>
    <title type="text">笛卡尔树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-27T12:20:00Z</published>
    <updated>2022-09-27T12:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15415540.html" />
    <content type="text"># 概念

[Link](https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802?fr=aladdin)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211016221105335-806948797.png)

**笛卡尔树的节点各有两个权值，其中一个权值满足二叉搜索树的性质，另一个满足小（大）根堆的性质。**

所以说 **Treap 也是一种笛卡尔树**。

# 构造

[知乎](https://zhuanlan.zhihu.com/p/89401577)

**以下均假设原序列元素两两不相同。**

从左至右依次加入元素，维护当前笛卡尔树的右儿子链

$$root\to rson\to rson.rson\to rson.rson.rson\dots$$

至一个栈内。

设加入的节点为 $x$，$t$ 为当前笛卡尔树。

1. 找到栈中最靠顶部的节点 $y$ 使得 $val[y]&lt;val[x]$。

2. 特判 $y$ 为栈顶，直接 $t[y].rson:=x$ 即可结束。

3. 记栈中 $y$ 的楼上为 $z$，$t[y].rson:=x,t[x].lson:=z$。

4. 将栈中 $y$ 之上的所有全部 $pop$，再 $push(x)$。

时间 $O(n)$

# 实战

## 模板

好像单调栈能做的，她都行。

[P5854 【模板】笛卡尔树](https://www.luogu.com.cn/problem/P5854)

~~以前这里贴了一个 $O(n\log n)$ 的代码，放了好久，我该咋办。~~

现在改好了，$O(n)$ 的。

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-27 18:20:41
* Motto: We'll be counting stars.
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define ll long long
#define N 10000005
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
int n,a[N],ls[N],rs[N],s[N],st;
signed main(){
	n=read();
	For(i,1,n) a[i]=read();
	s[st=1]=1;
	int x;
	For(i,2,n){
		if(a[i]&gt;a[s[st]]){
			rs[s[st]]=i;
			s[++st]=i;
		}else if(a[i]&lt;a[s[1]]){
			ls[i]=s[1];
			s[st=1]=i;
		}else{
			x=s[st--];
			while(a[s[st]]&gt;a[i]){
				x=s[st--];
			}
			rs[s[st]]=i;
			ls[i]=x;
			s[++st]=i;
		}
	}
	// For(i,1,n) cout&lt;&lt;ls[i]&lt;&lt;" "; cout&lt;&lt;"\n";
	// For(i,1,n) cout&lt;&lt;rs[i]&lt;&lt;" "; cout&lt;&lt;"\n";
	ll L=0,R=0;
	For(i,1,n){
		L^=1ll*i*(ls[i]+1);
		R^=1ll*i*(rs[i]+1);
	}
	cout&lt;&lt;L&lt;&lt;" "&lt;&lt;R&lt;&lt;"\n";
return 0;}
```

## CF1220F Gardener Alex

vp 场上 $O(n)$ 想法因为 sb 错误没调出来，被 Little09 $O(n\log n)$ 压哨过暴踩。

发现其实就是要快速求出一个序列的任意前缀的笛卡尔树的深度。

发现我们可以直接在右链上维护每个节点左儿子的 $\text{mxdep}$，压栈和弹栈的时候维护一下即可。

细节看代码吧，讲不清楚 /yun。

[Link](https://codeforces.com/contest/1220/submission/173675145)

## P5654 基础函数练习题

咕咕咕，我还没 A 这道题呢。

## P7244 章节划分

过了，但是咕咕咕。

## CF1748E Yet Another Array Counting Problem

由于最大值位置定义为最左边的最大值，我们将每个位置 $i$ 上的值改成二元组 $(val,-i)$，这样不存在相同的元素了，大小直接用 `std::pair` 比较即可。

不难发现题目相当于要求与 $\{a\}$ 大根笛卡尔树结构相同的（长度 $n$，值域 $m$）序列有多少个。

然后就简单了，发现 $n\cdot m\le 10^6$，树形背包做完了。

[Code](https://codeforces.com/contest/1748/submission/180719983)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15430360.html</id>
    <title type="text">重修 对拍-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-14T14:08:00Z</published>
    <updated>2022-01-14T14:08:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15430360.html" />
    <content type="text"># 对拍，考场干货

[Link](https://blog.csdn.net/code12hour/article/details/51252457?locationNum=1&amp;fps=1)

## Arunner.cpp

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
long long tmp,cnt=0,t1=0,t2=0,lim;
inline void start(){tmp=clock();}
inline long long end(){return clock()-tmp;}
signed main(){
	cout&lt;&lt;"Input times(-1 for infinity):"&lt;&lt;endl;
	cin&gt;&gt;lim;
	while(cnt!=lim){
		system("Amake.exe &gt; Adata.txt");
		start();
		system("1.exe &lt; Adata.txt &gt; A1.txt");
		t1+=end();
		start();
		system("2.exe &lt; Adata.txt &gt; A2.txt");
		t2+=end();
		cnt++;
		if(system("fc A1.txt A2.txt")){
			cout&lt;&lt;"There's something wrong."&lt;&lt;endl;
			system("pause"); 
			return 0;
		}
	}
	cout&lt;&lt;cnt&lt;&lt;" times running."&lt;&lt;endl;
	cout&lt;&lt;"Avg time of 1: "&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;0.001*t1/cnt&lt;&lt;endl;
	cout&lt;&lt;"Avg time of 2: "&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;0.001*t2/cnt&lt;&lt;endl;
	system("pause"); 
    return 0;
}
```

## Amake.cpp

写随机数据的地方，不用 freopen。

缺省源：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define int long long 
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define uid(i,j,k) uniform_int_distribution&lt;ll&gt; i(j,k)
#define Rand(s) s(rand_num)
unsigned seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rand_num(seed);

signed main(){IOS;

return 0;}
```

### 1.cpp &amp; 2.cpp

两个比较程序，不用写 freopen。

注意每次对拍前要编译，否则 `.exe` 文件没被修改。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15435177.html</id>
    <title type="text">2021 做题记录-ShaoJia</title>
    <summary type="html">$$\begin{matrix}
\mathtt{P1656炸铁路:洛谷}\qquad&amp;\mathtt{351.树网的核:AcWing}\qquad&amp;\mathtt{Loj144.DFS序1:LibreOJ}
\\
\mathtt{cf \ 1520:CF整套}\qquad&amp;\mathtt{C3-00016涂格子:Onecode}\qquad&amp;\mathtt{arc131\_a:AtCoder}
\end{matrix}$$</summary>
    <published>2021-11-14T15:18:00Z</published>
    <updated>2021-11-14T15:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15435177.html" />
    <content type="text">## 01
### 01-10
P2111 考场奇遇
P3382 【模板】三分法
P1423 小玉在游泳
### 01-17
P2557 [AHOI2002]芝麻开门
P2602 [ZJOI2010]数字计数
## 02
### 02-20
P1656 炸铁路
P2835 刻录光盘
### 02-21
P3388 【模板】割点（割顶）
P1343 地震逃生
### 02-22
P2218 [HAOI2007]覆盖问题
P1831 杠杆数
P1364 医院设置
### 02-25
P4643 [国家集训队]阿狸和桃子的游戏
P3304 [SDOI2013]直径
## 03
### 03-14
P3386 【模板】二分图最大匹配
### 03-20
P1079 [NOIP2012 提高组] Vigenere 密码
P1080 [NOIP2012 提高组] 国王游戏
### 03-21
P7368 [USACO05NOV]Asteroids G
P2055 [ZJOI2009]假期的宿舍
P5248 [LnOI2019SP]快速多项式变换(FPT)
### 03-27
P1084 [NOIP2012 提高组] 疫情控制
P1083 [NOIP2012 提高组] 借教室
P1082 [NOIP2012 提高组] 同余方程
### 03-28
P3376 【模板】网络最大流
## 04
### 04-03
P1967 [NOIP2013 提高组] 货车运输
P1966 [NOIP2013 提高组] 火柴排队
P1965 [NOIP2013 提高组] 转圈游戏
### 04-04
P4779 【模板】单源最短路径（标准版）
P1251 餐巾计划问题
P2598 [ZJOI2009]狼和羊的故事
### 04-10
P1979 [NOIP2013 提高组] 华容道
P1970 [NOIP2013 提高组] 花匠
P1969 [NOIP2013 提高组] 积木大赛
### 04-11
P1383 高级打字机
### 04-17
P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布
P1351 [NOIP2014 提高组] 联合权值
### 04-24
cf 1513
P2312 [NOIP2014 提高组] 解方程
P2038 [NOIP2014 提高组] 无线网络发射器选址
P2296 [NOIP2014 提高组] 寻找道路
## 05
### 05-01
P2615 [NOIP2015 提高组] 神奇的幻方
P2661 [NOIP2015 提高组] 信息传递
P2668 [NOIP2015 提高组] 斗地主
P2540 [NOIP2015 提高组] 斗地主 加强版
### 05-04
P1270 &amp;ldquo;访问&amp;rdquo;美术馆
P2014 [CTSC1997]选课
P2015 二叉苹果树
### 05-05
cf 1520
cf 1
cf 1512
### 05-14
P2002 消息扩散
### 05-15
P1337 [JSOI2004]平衡点 / 吊打XXX
### 05-21
P2678 [NOIP2015 提高组] 跳石头
P2679 [NOIP2015 提高组] 子串
### 05-22
cf 1521
cf 1525
P1563 [NOIP2016 提高组] 玩具谜题
P1850 [NOIP2016 提高组] 换教室
### 05-26
P5030 长脖子鹿放置
cf 1527
### 05-29
P2822 [NOIP2016 提高组] 组合数问题
P2827 [NOIP2016 提高组] 蚯蚓
P2831 [NOIP2016 提高组] 愤怒的小鸟
## 06
### 06-02
cf 1529
### 06-05
P4243 [JSOI2009]等差数列
P5357 【模板】AC自动机（二次加强版）
P3796 【模板】AC自动机（加强版）
P3808 【模板】AC自动机（简单版）
P3951 [NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目
P3952 [NOIP2017 提高组] 时间复杂度
P3953 [NOIP2017 提高组] 逛公园
### 06-12
P5219 无聊的水题 I
P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G
P4208 [JSOI2008]最小生成树计数
P3387 【模板】缩点
P3958 [NOIP2017 提高组] 奶酪
P3959 [NOIP2017 提高组] 宝藏
P3960 [NOIP2017 提高组] 列队
### 06-13
P3966 [TJOI2013]单词
P1406 方格填数
P1214 [USACO1.4]等差数列 Arithmetic Progressions
P5318 【深基18.例3】查找文献
P2357 守墓人
### 06-14
cf 1538
P1890 gcd区间
P2444 [POI2000]病毒
### 06-16
P1395 会议
### 06-19
P5019 [NOIP2018 提高组] 铺设道路
P5020 [NOIP2018 提高组] 货币系统
P5021 [NOIP2018 提高组] 赛道修建
### 06-20
P3379 【模板】最近公共祖先（LCA）（$3$ 种方法） 
### 06-26
cf 1526
P7075 [CSP-S2020] 儒略日
P7076 [CSP-S2020] 动物园
### 06-30
P3398 仓鼠找sugar
## 07
### 07-12
P3805 【模板】manacher 算法
P3373 【模板】线段树 2
163. 生日礼物
145. 超市
106. 动态中位数
P2024 [NOI2001] 食物链
### 07-13
CF1288E Messenger Simulator
P1966 [NOIP2013 提高组] 火柴排队
P6146 [USACO20FEB]Help Yourself G
244. 谜一样的牛
P3374 【模板】树状数组 1
P3368 【模板】树状数组 2
P7078 [CSP-S2020] 贪吃蛇
P6145 [USACO20FEB]Timeline G
P5836 [USACO19DEC]Milk Visits S
CF1271E Common Number
P2473 [SCOI2008] 奖励关
### 07-14
CF1278D Segment Tree
P7149 [USACO20DEC] Rectangular Pasture S
CF1280A Cut and Paste
6. 多重背包问题 III
CF1290C Prefix Enlightenment
CF1290A Mind Control
CF1290B Irreducible Anagrams
P3834 【模板】可持久化线段树 2（主席树）
CF1283F DIY Garland
### 07-15
144. 最长异或值路径
CF1270D Strange Device
CF1500A Going Home
141. 周期
P7469 [NOI Online 2021 提高组] 积木小赛
P3332 [ZJOI2013]K大数查询
CF1527B1 Palindrome Game (easy version)
CF1527B2 Palindrome Game (hard version)
### 07-16
273. 分级
275. 传纸条
280. 陪审团
CF1500D Tiles for Bathroom
P6280 [USACO20OPEN]Exercise G
CF1310E Strange Function
CF1523D Love-Hate
CF1294F Three Paths on a Tree
CF1295E Permutation Separation
CF1278C Berry Jam
272. 最长公共上升子序列
CF1513C Add One
P7114 [NOIP2020] 字符串匹配
P4555 [国家集训队]最长双回文串
### 07-17
CF1513F Swapping Problem
P7150 [USACO20DEC] Stuck in a Rut S
287. 积蓄程度
P6147 [USACO20FEB]Delegation G
P4084 [USACO17DEC]Barn Painting G
### 07-18
SP4141 ETF - Euler Totient Function
UVA1336 修缮长城 Fixing the Great Wall
P6570 [NOI Online #3 提高组] 优秀子序列
UVA10891 Game of Sum
P3812 【模板】线性基
311. 月之谜
CF1305G Kuroni and Antihype
CF1304F1 Animal Observation (easy version)
CF1304F2 Animal Observation (hard version)
CF1299C Water Balance
CF1303D Fill The Bag
P5490 【模板】扫描线
CF148D Bag of mice
P6625 [省选联考 2020 B 卷] 卡牌游戏
P3367 【模板】并查集
P3378 【模板】堆
CF1296F Berland Beauty
CF1301F Super Jaber
### 07-19
P1886 滑动窗口 /【模板】单调队列
### 07-20
CF1303F Number of Components
CF1284E New Year and Castle Construction
CF508E Arthur and Brackets
P6148 [USACO20FEB] Swapity Swapity Swap S
loj144. DFS 序 1
351. 树网的核
P2491 [SDOI2011]消防
P1099 [NOIP2007 提高组] 树网的核
CF1280C Jeremy Bearimy
P6150 [USACO20FEB] Clock Tree S$\times 2$种解法($O(n^2)$ 和 $O(n)$)
2889. 再探石子合并
P1081 [NOIP2012 提高组] 开车旅行
298. 围栏
P5665 [CSP-S2019] 划分
### 07-21
CF1303E Erase Subsequences
CF1305F Kuroni and the Punishment
CF1286B Numbers on Tree
352. 闇の連鎖
CF1528C Trees of Tranquillity
355. 异象石
### 07-22
P3478 [POI2008]STA-Station
P1967 [NOIP2013 提高组] 货车运输
CF600E Lomsat gelral
P5022 [NOIP2018 提高组] 旅行
P5049 [NOIP2018 提高组] 旅行 加强版
P7077 [CSP-S2020] 函数调用
CF1513D GCD and MST
CF1307F Cow and Vacation
### 07-23
CF1296E2 String Coloring (hard version)
CF1304E 1-Trees and Queries
P5833 [USACO19DEC]Livestock Lineup B
P6185 [NOI Online #1 提高组] 序列
P6569 [NOI Online #3 提高组] 魔法值
CF1270G Subset with Zero Sum
341. 最优贸易
### 07-24
201. 可见的点
CF1512G Short Task
P6185 [NOI Online #1 提高组] 序列
P4768 [NOI2018] 归程
CF1307E Cow and Treats
### 07-25
P5011 水の造题
CF1284C New Year and Permutation
CF1523E Crypto Lights
P6189 [NOI Online #1 入门组] 跑步
P1989 无向图三元环计数
### 07-26
CF1286C1 Madhouse (Easy version)
CF1286C2 Madhouse (Hard version)
P4178 Tree
P3806 【模板】点分治1
### 07-27
P1314 [NOIP2011 提高组] 聪明的质监员
P1311 [NOIP2011 提高组] 选择客栈
P1313 [NOIP2011 提高组] 计算系数
P5835 [USACO19DEC]Meetings S
UVA10881 Piotr's Ants
### 07-28
P1127 词链
P1070 [NOIP2009 普及组] 道路游戏
### 07-29
P1896 [SCOI2005]互不侵犯
P2051 [AHOI2009]中国象棋
P1357 花园
P1879 [USACO06NOV]Corn Fields G
P1278 单词游戏
### 07-30
P1341 无序字母对（初学欧拉回路）
P1262 间谍网络
P4317 花神的数论题
P2518 [HAOI2010]计数
C3-00016 涂格子
### 07-31
P3939 数颜色（解法清奇）
P2416 泡芙（紫题一遍过！！！qwq）
## 08
### 08-01
P5689 [CSP-S2019 江西] 多叉堆
P1549 [NOIP1997 提高组] 棋盘问题
P1053 [NOIP2005 提高组] 篝火晚会
P1041 [NOIP2003 提高组] 传染病控制
P1034 [NOIP2002 提高组] 矩形覆盖
P1013 [NOIP1998 提高组] 进制位
### 08-02
P4157 [SCOI2006]整数划分
P4160 [SCOI2009]生日快乐
P7676 [COCI2013-2014#5] TROKUTI
P3083 [USACO13OPEN]Luxury River Cruise S
P1961 最轻的天平
### 08-03
P2107 小Z的AK计划(不开 long long 见了祖宗)
P1156 垃圾陷阱
P3383 【模板】线性筛素数
P1463 [POI2001][HAOI2007]反素数
P1268 树的重量
P1220 关路灯
### 08-04
P2213 [USACO14MAR]The Lazy Cow S
P2070 刷墙
P1561 [USACO12JAN]Mountain Climbing S
### 08-05
P3195 [HNOI2008]玩具装箱
### 08-06
P2120 [ZJOI2007]仓库建设
### 08-08
P4062 [Code+#1]Yazid 的新生舞会
P1494 [国家集训队]小Z的袜子（初学莫队）
CF1284D New Year and Conference
### 08-09
P3380 【模板】二逼平衡树（树套树）(初学树套树QAQ，其实可以SEG+vector水过)
4320. ShangHai2006 Homework
P3245 [HNOI2016]大数（除了特判，莫队和离散化1A，码力++）
### 08-11
P3807 【模板】卢卡斯定理/Lucas 定理
P3690 【模板】动态树（Link Cut Tree）
CF453E Little Pony and Lord Tirek（颜色段均摊）
P7447 [Ynoi2007] rgxsxrs(倍增分块qwq)
P5367 【模板】康托展开
P3203 [HNOI2010]弹飞绵羊
CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths
### 08-12
P4720 【模板】扩展卢卡斯定理/exLucas
### 08-13
P2257 YY的GCD(莫比乌斯反演+整除分块)
P2522 [HAOI2011]Problem b(莫比乌斯反演)
### 08-14
U163126 魔法森林 hack 数据
P2387 [NOI2014] 魔法森林（LCT 模板真好套 OvO）
P4148 简单题（KDT一点都不简单鸭）
P4168 [Violet]蒲公英（我好菜，数组没开够+忘记反离散化调了90min)
### 08-15
P4211 [LNOI2014]LCA（树剖+线段树+差分）
P5354 [Ynoi2017] 由乃的 OJ（由P2114改编而来，难度&amp;卡时间，sol：树剖+线段树）
P2114 [NOI2014] 起床困难综合症（NOI 宝藏水题）
P3604 美好的每一天（极限卡空间，用上了 short 类型）
P5170 【模板】类欧几里得算法
### 08-16
P1891 疯狂 LCM（线性筛平凡积性函数）
loj6145. 「2017 山东三轮集训 Day7」Easy（淀粉质）
P2495 [SDOI2011]消耗战（虚树）
P1429 平面最近点对（加强版）（1A）
P4197 Peaks
### 08-17
P4172 [WC2006]水管局长（LCT-&gt;动态删点MST，读入时也要判断是否成环qwq调到凌晨0:45）
### 08-18
P4690 [Ynoi2016] 镜中的昆虫(区间动态数颜色，懂了难写~~就抄了~~)
P3810 【模板】三维偏序（陌上花开）(树状数组清空使用 memset 时间复杂度不对，调了90min qwq)
### 08-19
P3703 [SDOI2017]树点涂色(LCT神仙)
P4383 [八省联考2018]林克卡特树(wqs二分)
P3402 可持久化并查集
CF868F Yet Another Minimization Problem(决策单调DP+莫队)
### 08-20
P3803 【模板】多项式乘法（FFT）（调了10hours qwq,原因：1.由于取后继2的幂次，导致数组没开够 2.FFT初学不会写 3.几次单位根忘记变了（此处区间多少大就是取几次单位根））
P1379 八数码难题（IDA*）
### 08-21
P4929 【模板】舞蹈链（DLX）(初学Dancing Links)
### 08-22
P3768 简单的数学题(杜教筛)
P3327 [SDOI2015]约数个数和（整除分块，不开 long long 见祖宗）
P7811 [JRKSJ R2] 你的名字。
P1074 [NOIP2009 提高组] 靶形数独（Dancing Links）
### 08-23
P1891 疯狂 LCM (二刷，$O(n\log n)\to O(n)$)
P1829 [国家集训队]Crash的数字表格 / JZPTAB（被莫比乌斯函数中的负数取模坑惨了qwq）
### 08-24
UVA1655 考试 Exam（巧妙的有序组到无序组的转化）
P2261 [CQOI2007]余数求和（整除分块模板）
P3242 [HNOI2015] 接水果（扫描线+整体二分）
P5445 [APIO2019]路灯（CDQ）
P3804 【模板】后缀自动机 (SAM)（自学了两三天qwq，太难了）
### 08-25
P1171 售货员的难题（状压DP）
P1272 重建道路（树形分组背包）
P1248 加工生产调度（Johnson法则）
P1136 迎接仪式
P1017 [NOIP2000 提高组] 进制转换（复习负进制转换qwq）
P2322 [HNOI2006]最短母串问题（ACAM）
### 08-26
P1333 瑞瑞的木棍(欧拉路)
P1242 新汉诺塔（分类搜索）
P4285 [SHOI2008]汉诺塔(DP)
P2327 [SCOI2005]扫雷（根本不用DP的DP题）
P1282 多米诺骨牌（1A DP）
P1306 斐波那契公约数(1A矩阵快速幂)
P1368 【模板】最小表示法
### 08-27
P1021 [NOIP1999 提高组] 邮票面值设计
P1019 [NOIP2000 提高组] 单词接龙
P1016 [NOIP1999 提高组] 旅行家的预算
P1174 打砖块(1A)
P1275 魔板（1A）
P1266 速度限制（分层图最短路）
CF1562E Rescue Niwen!
CF1562D2 Two Hundred Twenty One (hard version)
CF1562D1 Two Hundred Twenty One (easy version)
CF1562C Rings
CF1562B Scenes From a Memory
CF1562A The Miracle and the Sleeper
### 08-28
CF622F The Sum of the k-th Powers（拉格朗日插值法）
P5431 【模板】乘法逆元2（超级卡常）
P3811 【模板】乘法逆元(线性求逆元)
P4781 【模板】拉格朗日插值（1A）
P7115 [NOIP2020] 移球游戏（细节很多，调了好久qwq）
P7113 [NOIP2020] 排水系统(拓扑排序+分数加乘模板，懒得写高精度？试试__int128)
### 08-29
P5667 拉格朗日插值2(NTT)
P3803 【模板】多项式乘法（FFT）(二刷，初学NTT并使用，1A OvO)
### 08-30
CF587B Duff in Beach
CF587A Duff and Weight Lifting
### 08-31
P6033 [NOIP2004 提高组] 合并果子 加强版（$O(n)$做法：双队列代替优先队列OvO）
P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G
CF587D Duff in Mafia（不会2-SAT，~~直接抄题解~~）
CF587C Duff in the Army(树上倍增)
P3384 【模板】轻重链剖分/树链剖分(初学，1A，OvO)
## 09
### 09-01
P3372 【模板】线段树 1（明明题目说不爆 $int$ 却卡我 $int$ ，不然1A的qwq）
P7116 [NOIP2020] 微信步数(数学好难qwq，高维好难qwq)
CF1244D Paint the Tree
P4171 [JSOI2010] 满汉全席（2-SAT）
P4782 【模板】2-SAT 问题（Tarjan大法好）
### 09-02
P4718 【模板】Pollard-Rho算法
### 09-03
P4718 【模板】Pollard-Rho算法(学了两天，终于搞懂了qwqwq，调代码花了4hours qwq)
### 09-05
CF1556F Sports Betting（状压DP概率期望+竞赛图SCC缩点成链题）
CF1556E Equilibrium(猜结论题)
CF1556D Take a Guess
CF1556C Compressed Bracket Sequence（1A）
### 09-06
CF1556B Take Your Places!（自创题解中没有的想法4min 2A）
CF1556A A Variety of Operations(2min 1A)
### 09-07
CF1562F Tubular Bells（sol:随机数，求大素因子，用 $lcm$ 确定其他数，~~要什么垃圾Pollard-Rho~~）
### 09-11
P5664 [CSP-S2019] Emiya 家今天的饭（容斥DP）
P4719 【模板】"动态 DP"&amp;动态树分治
P1399 [NOI2013] 快餐店（基环树 1A）
CF750E New Year and Old Subsequence（DDP）
### 09-12
P1495 【模板】中国剩余定理(CRT)/曹冲养猪（1A，但需要重修qwq）
P1082 [NOIP2012 提高组] 同余方程（1A，但需要重修qwq）
P3375 【模板】KMP字符串匹配（1A，但需要重修qwq）
CF1187D Subarray Sorting（1A，逆序对问题qwq）
P2347 [NOIP1996 提高组] 砝码称重(1A，试试 $bitset$)
P1315 [NOIP2011 提高组] 观光公交（30min,1A）
P1312 [NOIP2011 提高组] Mayan 游戏（OvO一道非常考验代码能力的模拟爆搜题，1A，共用时 68'03"，调了 20' （只是一个 $check$ 错了qwq））
P1177 【模板】快速排序
U177509 SCP 2021 第一轮（初赛）模拟
### 09-13
P3868 [TJOI2009] 猜数字（扩展中国剩余定理，就是下面那道模板题改了一下输入格式，双倍快乐OvO）
P4777 【模板】扩展中国剩余定理（EXCRT）（2A，需要重修qwq）
P5656 【模板】二元一次不定方程 (exgcd)（1A，但需要重修qwq，分类输出好ex）
### 09-14
CF1567F One-Four Overload（二分图染色 3A）
CF1567E Non-Decreasing Dilemma（线段树套路，区间非降子串个数，细节写错 2A）
CF1567D Expression Evaluation Error（数位贪心 看题解 1A）
CF1567C Carrying Conundrum(3min 1A 十进制奇偶位拆分qwq好难想)
CF1567B MEXor Mixup(7min 1A)
CF1567A Domino Disaster(4min 1A)
### 09-15
CF1566D1 Seating Arrangements (easy version)(贪心 1A)
U134036 CSP2020第一轮模拟
### 09-16
CF1566D2 Seating Arrangements (hard version)（树状数组+贪心 1A）
### 09-17
CF1566E Buds Re-hanging
### 09-19
CF1558C Bottom-Tier Reversals(2A,$assert$ Debug 真好用OvO)
CF1559D1 Mocha and Diana (Easy Version)（1A）
CF1569D Inconvenient Pairs（$long \ long$ 没开全，2A）
CF1569C Jury Meeting
### 09-20
CF1558B Up the Strip($O(n\ln n)$)
CF1561D1 Up the Strip (simplified version)($O(n\sqrt{n})$)
### 09-22
CF1557C Moamen and XOR(1A 自己想出正解qwq)
CF1566B MIN-MEX Cut
CF1551E Fixed Points
CF1551F Equidistant Vertices
CF1552D Array Differentiation(状压qwq)
CF1553D Backspace(贪心qwq)
CF1552C Maximize the Intersections
CF1554D Diane
CF1555D Say No to Palindromes
### 09-23
CF1551D1 Domino (easy version)
### 09-24
CF1550C Manhattan Subarrays(1A 自己想出正解qwq)
CF1551D2 Domino (hard version)(2A)
### 09-25
CF1547F Array Stabilization (GCD version)
CF1547G How Many Paths?（topo）
CF1548B Integers Have Friends(ST)
### 09-26
CF1536D Omkar and Medians(1A 中位数 set 妙用)
CF1537D Deleting Divisors（1A 打表找规律）
CF1539D PriceFixed(2A 不开 long long 见祖宗)
CF1545A AquaMoon and Strange Sort(1A 奇偶判断+unordered_map)
CF1545B AquaMoon and Chess
### 09-27
CF1530D Secret Santa
CF1535C Unstable String
CF1535D Playoff Tournament
### 09-28
CF1506F Triangular Paths(25min 1A)
CF1508A Binary Literature(35min 3A)
CF1508B Almost Sorted(15min 1A)
CF1509C The Sports Festival
CF1515D Phoenix and Socks
### 09-29
CF1486C2 Guessing the Greatest (hard version)（35min 3A）
CF1486C1 Guessing the Greatest (easy version)（15min 1A）
CF1486D Max Median(15min 1A)
CF1487D Pythagorean Triples(10min 1A)
CF1495B Let's Go Hiking
CF1483B Playlist
CF1503B 3-Coloring
CF1499D The Number of Pairs 
### 09-30
CF1493C K-beautiful Strings(60min 3A)
CF1491D Zookeeper and The Infinite Zoo(15min 1A)
CF1491C Pekora and Trampoline(10min 1A)
CF1490G Old Floppy Drive(15min 2A 不开 $long \ long$ 见祖宗)
CF1481D AB Graph(50min 4A)
CF1481E Sorting Books
## 10
### 10-01
CF1476D Journey(纯手推 25min 1A)
CF1478C Nezzar and Symmetric Array(纯手推 25min 3A 不开 long long 见祖宗，只看翻译见祖宗)
CF1479B2 Painting the Array II(15min 1A 贪心)
CF1498D Bananas in a Microwave(40min 3A 精度问题 QwQ)
CF1497E2 Square-free division (hard version)（紫题 40min 4A）
CF1497E1 Square-free division (easy version)（12min 1A）
CF1494D Dogeforces(28min 1A)
### 10-02
CF1475D Cleaning the Phone(40min 2A)
CF1475E Advertising Agency(纯手推 12min 1A)
CF1475F Unusual Matrix(纯手推 20min 1A)
CF1475G Strange Beauty(纯手推 新思路 45min 3A)
CF1476C Longest Simple Cycle(纯手推 12min 2A 不开 $long \ long$ 见祖宗)
### 10-04
CF1572C Paint
CF1572B Xor of 3
CF1572A Book
CF1573B Swaps
CF1579G Minimal Coverage
CF1579F Array Stabilization (AND version)
CF1579E2 Array Optimization by Deque
CF1579E1 Permutation Minimization by Deque
CF1579D Productive Meeting
CF1579C Ticks
CF1579B Shifting Sort
CF1579A Casimir's String Solitaire
### 10-05
CF1574D The Strongest Build
CF1574C Slay the Dragon
CF1574B Combinatorics Homework
CF1574A Regular Bracket Sequences
P7875 「SWTR-07」IOI 2077
P2613 【模板】有理数取余
CF1569B Chess Tournament
CF1566F Points Movement
### 10-06
P7876 「SWTR-07」Scores（hard version）
CF1592A Gamer Hemose
CF1592B Hemose Shopping
CF1592C Bakry and Partitioning
CF1592D Hemose in ICPC ?
CF1592E Bored Bakry
T197746 不想爬坡
P7878 「SWTR-07」My rating is 1064（hard version）
CF1574F Occurrences
### 10-07
CF1279D Santa's Bot
CF1288D Minimax Problem
P6186 [NOI Online #1 提高组] 冒泡排序
### 10-08
P1407 [国家集训队]稳定婚姻
P1392 取数
P1380 T型骨牌
P1377 [TJOI2011]树的序
P1373 小a和uim之大逃离
P1370 Charlie的云笔记序列
CF1553F Pairwise Modulo
P6477 [NOI Online #2 提高组] 子序列问题
### 10-09
P2197 【模板】nim 游戏
### 10-10
P1438 无聊的数列（差分线段树 1A）
P7888 「MCOI-06」Distinct Subsequences（好难的 DP 柿子 QwQ）
P1453 城市环路（二刷，BJ区考试中同样的题没写出来，算报仇了 QwQ，[我的题解](https://www.cnblogs.com/zhangshaojia/p/15390822.html)）
### 10-11
P1654 OSU!
P5142 区间方差（取模一定要步步取 QwQ）
### 10-12
CF1573A Countdown
P2717 寒假作业
P7868 [COCI2015-2016#2] VUDU
P1660 数位平方和（模数是 $10^7+7$ 而不是 $10^9+7$ QwQ）
### 10-13
CF815C Karen and Supermarket（~~小小紫题，可笑可笑~~）
P6748 『MdOI R3』Fallen Lord（`sort(a+1,a+1+n,greater&lt;int&gt;());` 真好用）
P4161 [SCOI2009]游戏
P1707 刷题比赛
### 10-14
P2577 [ZJOI2004]午餐
### 10-15
CF1598A Computer Game
CF1598B Groups
CF1598C Delete Two Elements
CF1598D Training Session
CF1598E Staircases
### 10-16
CF1580B Mathematics Curriculum
P5854 【模板】笛卡尔树
P2709 小B的询问
### 10-17
CF1594E1 Rubik's Cube Coloring (easy version)
CF1594E2 Rubik's Cube Coloring (hard version)
CF1553E Permutation Shift
P7902 「PMOI-0」儒略日
P3125 [USACO15OPEN]Bessie's Birthday Buffet S
CF1304D Shortest and Longest LIS
CF12E Start of the season
### 10-18
CF1598F RBS（CSP 要是我初始值还错了我把左手剁了）
### 10-19
CF1537E1 Erase and Extend (Easy Version)
CF1537E2 Erase and Extend (Hard Version)
P1142 轰炸
P3360 偷天换日
### 10-20
T196684 昕昕的不等式组（复习对拍）
### 10-21
CF1583A Windblume Ode
CF1583B Omkar and Heavenly Tree
CF1583C Omkar and Determination
CF1583D Omkar and the Meaning of Life
CF1583F Defender of Childhood Dreams
T200599 旅行家（边双缩点+树上倍增 LCA+树上差分  写了两天qwq）
### 10-22
CF650C Table Compression
CF788D Finding lines
CF1580C Train Maintenance
### 10-23
打 CSP-S
### 10-24
P7913 [CSP-S 2021] 廊桥分配
P7914 [CSP-S 2021] 括号序列
P7915 [CSP-S 2021] 回文
### 10-25
CF1583E Moment of Bloom
POJ 1390 Blocks
318. 划分大理石
### 10-26
P4198 楼房重建
CF1583H Omkar and Tours
### 10-27
CF1582A Luntik and Concerts
CF1582B Luntik and Subsequences
CF1582C Grandma Capa Knits a Scarf
CF1582D Vupsen, Pupsen and 0
CF1582E Pchelyonok and Segments
CF438D The Child and Sequence
P7909 [CSP-J 2021] 分糖果
P7910 [CSP-J 2021] 插入排序
P7911 [CSP-J 2021] 网络连接
P7912 [CSP-J 2021] 小熊的果篮
### 10-28
CF1582F1 Korney Korneevich and XOR (easy version)
CF1582F2 Korney Korneevich and XOR (hard version)
### 10-29
CF1446D1 Frequency Problem (Easy Version)
CF1446D2 Frequency Problem (Hard Version)
P4592 [TJOI2018]异或
### 10-30
CF1582G Kuzya and Homework
P2633 Count on a tree
P3302 [SDOI2013]森林
P1972 [SDOI2009]HH的项链
### 10-31
P2163 [SHOI2007]园丁的烦恼
CF830E Perpetual Motion Machine
## 11
### 11-01
P1279 字串距离
### 11-02
P3863 序列
CF1604A Era
CF1604B XOR Specia-LIS-t
CF1603A Di-visible Confusion
CF1603B Moderate Modular Mode
CF1603C Extreme Extension
324. 贿赂FIPA
325. 计算机
### 11-03
P4396 [AHOI2013]作业
P7916 [CSP-S 2021] 交通规划
### 11-05
113. 特殊排序
103. 电影
104. 货仓选址
107. 超快速排序
112. 雷达设备
110. 防晒
### 11-06
CF1606D Red-Blue Matrix
CF1601D Difficult Mountain
CF1601C Optimal Insertion
CF1601B Frog Traveler
### 11-07
P1035 [NOIP2002 普及组] 级数求和
P4305 [JLOI2011]不重复数字
P2590 [ZJOI2008]树的统计(树剖半模板 13min 2A 线段树开 $4$ 倍 线段树开 $4$ 倍 线段树开 $4$ 倍)
CF1606F Tree Queries
CF1285D Dr. Evil Underscores
143. 最大异或对
UVA11732 "strcmp()" Anyone?（~~小小紫题，可笑可笑~~）
142. 前缀统计
### 11-08
P3369 【模板】普通平衡树([Link](https://www.cnblogs.com/zhangshaojia/p/15526354.html) 离散化+树状数组 $O(n\log^2 n)$)
P6706 [COCI2010-2011#7] KUGLICE
### 11-09
P3369 【模板】普通平衡树([Link](https://www.cnblogs.com/zhangshaojia/p/15526354.html) pbds 红黑树)
### 11-10
P4054 [JSOI2009]计数问题
P3986 斐波那契数列
P3961 [TJOI2013]黄金矿工
P3369 【模板】普通平衡树([Link](https://www.cnblogs.com/zhangshaojia/p/15526354.html) fhq_treap)
### 11-11
CF1543A Exciting Bets
CF1543B Customising the Track
CF1543C Need for Pink Slips
CF1543D1 RPD and Rap Sheet (Easy Version)
CF1543D2 RPD and Rap Sheet (Hard Version)
P4408 [NOI2003] 逃学的小孩
P6136 【模板】普通平衡树（数据加强版）
P2153 [SDOI2009]晨跑
P3381 【模板】最小费用最大流
P3157 [CQOI2011]动态逆序对
### 11-12
P1257 平面上的最接近点对
326. XOR和路径
323. 战略游戏
### 11-13
P7883 平面最近点对（加强加强版）
### 11-14
CF1584A Mathematical Addition
CF1584B Coloring Rectangles
CF1584C Two Arrays
CF1584D Guess the Permutation
CF1584E Game with Stones
160. 匹配统计
P7947 [??OI R1] 铝锤制作
CF1605A A.M. Deviation
CF1605B Reverse Sort
CF1605C Dominant Character
CF1605D Treelabeling
159. 奶牛矩阵
CF471D MUH and Cube Walls
### 11-15
P5377 [THUPC2019]鸽鸽的分割
P1450 [HAOI2008]硬币购物
P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles
### 11-16
CF340E Iahub and Permutations
P4149 [IOI2011]Race
P4551 最长异或路径
CF1198D Rectangle Painting 1
CF936B Sleepy Game
### 11-17
P3942 将军令
P2279 [HNOI2003]消防局的设立
CF1542A Odd Set
CF1542B Plus and Multiply
CF1542C Strange Function
CF1542D Priority Queue
CF715C Digit Tree
### 11-18
P7950 [??OI R1] 后方之水
CF1516A Tit for Tat
CF1516B AGAGA XOOORRR
CF1516C Baby Ehab Partitions Again
CF1516D Cut
CF1542E1 Abnormal Permutation Pairs (easy version)
CF1542E2 Abnormal Permutation Pairs (hard version)
### 11-19
CF1607A Linear Keyboard
CF1607B Odd Grasshopper
CF1607C Minimum Extraction
CF1607D Blue-Red Permutation
CF1607E Robot on the Board 1
CF1607F Robot on the Board 2
CF1607G Banquet Preparations 1
CF1607H Banquet Preparations 2
CF1559A Mocha and Math
CF1559B Mocha and Red and Blue
CF1559C Mocha and Hiking
CF1569A Balanced Substring
### 11-20
327. 玉米田
329. 围栏障碍训练场
### 11-21
P7960 [NOIP2021] 报数
P7961 [NOIP2021] 数列
139. 回文子串的最大长度
138. 兔子与兔子
### 11-22
CF1612A Distance
CF1612B Special Permutation
CF1612C Chat Ban
CF1612D X-Magic Pair
CF1612E Messages
### 11-23
P7962 [NOIP2021] 方差
P7948 [??OI R1] 前方之风
P7949 [??OI R1] 左方之地
### 11-24
330. 估算
CF1559D2 Mocha and Diana (Hard Version)
### 11-25
P2569 [SCOI2010]股票交易
332. 股票交易
### 11-27
P3287 [SCOI2014]方伯伯的玉米田
CF1611A Make Even
CF1611B Team Composition: Programmers and Mathematicians
CF1611C Polycarp Recovers the Permutation
CF1611D Weights Assignment For Tree Edges
CF1611E1 Escape The Maze (easy version)
CF1611E2 Escape The Maze (hard version)
CF1611F ATM and Students
CF1611G Robot and Candies
P2073 送花
P1503 鬼子进村
CF1610A Anti Light's Cell Guessing
CF1610B Kalindrome Array
CF1610C Keshi Is Throwing a Party
CF1610D Not Quite Lee
### 11-28
CF1614A Divan and a Store
CF1614B Divan and a New Project
CF1614C Divan and bitwise operations
P2486 [SDOI2011]染色
### 11-30
CF1609A Divide and Multiply
CF1609B William the Vigilant
CF1609C Complex Market Analysis
CF1609D Social Network
CF1609E William The Oblivious
CF1614D1 Divan and Kostomuksha (easy version)
CF1614D2 Divan and Kostomuksha (hard version)
## 12
### 12-01
CF1613A Long Comparison
CF1613B Absent Remainder
CF1613C Poisoned Dagger
CF1613D MEX Sequences
CF1613E Crazy Robot
### 12-02
P2375 [NOI2014] 动物园
### 12-03
CF1614E Divan and a Cottage
### 12-04
CF1557A Ezzat and Two Subsequences
CF1557B Moamen and k-subarrays
CF1557D Ezzat and Grid
CF1557E Assiut Chess
CF1266D Decreasing Debts
CF13E Holes
CF777E Hanoi Factory
CF1331F Elementary!
CF1311F Moving Points
CF1041E Tree Reconstruction
### 12-05
P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并
P1099 [NOIP2007 提高组] 树网的核（$O(n)$）
351. 树网的核
### 12-06
arc131_a
arc131_b
arc131_c
### 12-07
arc131_d
### 12-08
P3995 树链剖分
### 12-09
P4428 [BJOI2018]二进制（拿莘哥的代码对拍了上十遍调出来的代码 qwq 一晚上啊~~小小黑题可笑可笑~~）
### 12-11
P1471 方差
P6025 线段树
P5110 块速递推
abc231_a
abc231_b
abc231_c
abc231_d
abc231_e
abc231_f
### 12-12
CF1608A Find Array
CF1608B Build the Permutation
CF1608C Game Master
CF1192B Dynamic Diameter
### 12-13
CF1591A Life of a Flower
CF1591B Array Eversion
CF1591C Minimize Distance
CF1591D Yet Another Sorting Problem
### 12-14
P1054 [NOIP2005 提高组] 等价表达式
P1558 色板游戏
### 12-15
CF1608D Dominoes
arc115_e
CF1591F Non-equal Neighbours
P2622 关灯问题II
CF1618A Polycarp and Sums of Subsequences
CF1618B Missing Bigram
CF1618C Paint the Array
CF1618D Array and Operations
CF1618E Singers' Tour
CF1618F Reverse
### 12-16
CF1617A Forbidden Subsequence
CF1617B GCD Problem
CF1617C Paprika and Permutation
CF1617D1 Too Many Impostors (easy version)
CF1617D2 Too Many Impostors (hard version)
### 12-17
P1600 [NOIP2016 提高组] 天天爱跑步
### 12-18
207. 球形空间产生器
237. 程序自动分析
241. 楼兰图腾
### 12-19
CF1280D Miss Punyverse
219. 剪纸游戏
### 12-20
CF1620A Equal or Not Equal
CF1620B Triangles on a Rectangle
CF1620C BA-String
CF1620D Exact Change
CF1620E Replace the Numbers
### 12-21
102. 最佳牛围栏
202. 最幸运的数字
### 12-22
P4180 [BJWC2010]严格次小生成树
356. 次小生成树
### 12-23
CF1619A Square String?
CF1619B Squares and Cubes
CF1619C Wrong Addition
CF1619D New Year's Problem
CF1619E MEX and Increments
CF1619F Let's Play the Hat?
115. 给树染色
101. 最高的牛
204. 表达整数的奇怪方式
100. 增减序列
### 12-24
CF1615A Closing The Gap
CF1615B And It's Non-Zero
CF1615C Menorah
CF1615D X(or)-mas Tree
### 12-25
CF1619G Unusual Minesweeper
P3211 [HNOI2011]XOR和路径
P2016 战略游戏
abc233_a
abc233_b
abc233_c
abc233_d
abc233_e
abc233_f
abc233_g
P7993 [USACO21DEC] Lonely Photo B
P7994 [USACO21DEC] Air Cownditioning B
P7995 [USACO21DEC] Walking Home B
P7990 [USACO21DEC] Closest Cow Wins S
P7991 [USACO21DEC] Connecting Two Barns S
### 12-26
arc132_a
arc132_b
arc132_c
257. 关押罪犯
### 12-27
arc132_d
P7996 [WFOI - 01] 硬币（coin）
P7997 [WFOI - 01] 刷题 （problem）
P7920 [Kubic] Permutation
CF1276D Tree Elimination
### 12-28
CF1622A Construct a Rectangle
CF1622B Berland Music
CF1622C Set or Decrease
CF1622D Shuffle
### 12-29
CF1623A Robot Cleaner
CF1623B Game on Ranges
CF1623C Balanced Stone Heaps
CF1623D Robot Cleaner Revisit
P7992 [USACO21DEC] Convoluted Intervals S
CF1619H Permutation and Queries
### 12-30
348. 沙漠之王
346. 走廊泼水节
### 12-31
CF1616A Integer Diversity
CF1616B Mirror in the String
CF1616C Representative Edges
CF1616D Keep the Average High</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15467695.html</id>
    <title type="text">2021-8 清北学堂 省选 数据结构 内容回顾-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-11-16T03:31:00Z</published>
    <updated>2021-11-16T03:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15467695.html" />
    <content type="text">### 主讲人：[李欣隆](https://www.luogu.com.cn/user/3296)

# D1:

## 1

Treap(tree+heap)性质:每个点随机分配一个权值，使treap同时满足堆性质和二叉搜索树性质，复杂度 $O(n\log n)$。

旋转(rotate)有单旋和双旋, treap只需要单旋，这一点比较简单。

旋转时最好先记录每个点的编号，再断连，再重构，最后按照点的编号调用函数 `update(x)`。

Splay:每次对一个节点进行操作的时候通过―种方法把这个点旋转至根，称为Splay（伸展）操作。

注意：Splay要双旋

&gt; 用单旋（单旋到根称为move to root）会被卡是常识了……对于单调数据，树会退化成一条链，然后每次move最深的点就被卡掉啦~

Splay：

situation 1:

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211026205439776-640756646.png)

先 fa 后 cur

situation 2:

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211026205554904-947680181.png)

两次 cur

Split：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211026210040371-1873488520.png)

Merge:

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211026210115422-1364781911.png)

先鸽着。

例题：

P4198 楼房重建

斜率预处理+线段树 $O(m\log^2n)$ 维护。

## 2

[Fhq_treap](https://www.cnblogs.com/zwfymqz/p/7151959.html)

[CF453E Little Pony and Lord Tirek](https://www.luogu.com.cn/problem/CF453E)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211027212355424-2132975911.png)

思考：出题人不将询问和清零设为两个 opt，所以说这两个操作有联系。

思路太长，看 Luogu 题解吧……（直接 **ODT** 套别的东西即可）

[P5610 [Ynoi2013] 大学](https://www.luogu.com.cn/problem/P5610)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211027214318013-970163821.png)

对于“倍数”“因数”这种字眼，首先看值域（不然做法差别很大）$5\times 10^5$。

这道题的关键是奇怪的 1 操作+奇怪的值域。

[题解](https://www.luogu.com.cn/blog/0123456-3456789/solution-p5610)

[CF438D The Child and Sequence](https://www.luogu.com.cn/problem/CF438D)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211027220039612-565222940.png)

考虑 $x\%p$ 的情况：

$$\begin{cases}x\%p=x ,x&lt;p\\x\%p\leqslant\dfrac{x}{2} ,x\geqslant p\end{cases}$$

所以一个数的有意义取模（$x\%p\ne x$）最多进行 $\log x$ 次。

线段树暴力（无懒标记）解决即可。

[P7447 [Ynoi2007] rgxsxrs](https://www.luogu.com.cn/problem/P7447)

值域倍增分块。

[奆佬的题解](https://www.luogu.com.cn/blog/111055/solution-p7447)。

# D2:

## 1

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211028211316063-535557294.png)

[P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)

维护数组的前缀值域可持久化线段树，每次按照对应的子树大小之差二分查找。

[P4592 [TJOI2018]异或](https://www.luogu.com.cn/problem/P4592)

对于 1 操作，用 DFS 序+可持久化 01trie 维护。

对于 2 操作，可持久化 01trie 维护到根节点的所有值。

## 2

[P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)

对每个位置 $x$ 存前一个颜色相同的位置 $pre_x$。

顺序遍历数组，当前为 $a_x$，维护树状数组，每次 $add(x,1)$ 并且 $add(pre_x,-1)$。

当遍历到了某一个询问 $[l_i,r_i]$ 的右端点 $r_i$，$ans$ 为 $sum(r_i)-sum(l_i-1)$。

[P2163 [SHOI2007]园丁的烦恼](https://www.luogu.com.cn/problem/P2163)

**二维静态数点模板题**

先对 $y$ 坐标进行离散化。

对于每一个矩形询问，拆分成四个二维前缀和询问。

从左往右扫，维护一个树状数组存目前扫过的各个 $y$ 上的点的个数。

当扫到一个二维前缀和询问 $(x,y)$ 的 $x$ 时求树状数组中 $pre(y)$ 的值即为该询问的答案。

[对 $x,y$ 两维都离散化了的屑程序](https://www.luogu.com.cn/record/61434702)

扫描线：

P5490 【模板】扫描线

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031175415688-1271957207.png)

思路：二维静态问题 $\to$ 一维动态问题

从左往右扫，碰到矩形左边时区间加 $1$，碰到矩形右边时区间减 $1$，实时求整体 $\geqslant 1$ 的区间长度。

如果这样而已，单次是无法做到 $O(\log n)$ 的，但本题有一个显然的条件：

**任何时刻扫描线上不可能有负数**

问题就转化成动态求扫描线上值为 $0$ 的长度。

做法是在扫描线上建一棵线段树（$y$ 坐标离散化后），每一个节点存区间 $\min$ 和 $\min$ 的个数。

$O(\log n)$ 的做法就出来了。

[CF997E Good Subsegments](https://www.luogu.com.cn/problem/CF997E)

[题解](https://www.luogu.com.cn/blog/litble-blog/solution-cf997e)

# D3:

## 1

KDT：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031190219197-1713212602.png)

2DT

我们讲二维情况

给定n个二维平面点，建立其KDT

按 $x,y$ 两维交替建树，每次把所有点按当前维排序，然后找到当前维坐标中位数的点，以这个点做为基准，进行分治。

有两种写法，第一种是每个非叶节点都有一个基准点，这里写法是类似 BST 的，另一种是每个非叶节点没有二维平面上的点，所有给定的点都在叶子上，这里写法是类似线段树的。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031190634860-2051133774.png)

求矩形内的点数时，直接递归即可（直到一个子树全部被覆盖/全部不被覆盖时递归停止）。

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031191136382-20124148.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031214952120-473494437.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215059363-1572511558.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215130512-374022529.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215142897-1344385687.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215401273-1766064083.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215618534-1132698812.png)

所以说 KDT 是二维矩形操作的理论最优算法。

但……

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031215723902-1745302289.png)

lxl 的毒瘤数据：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031222623303-1435171098.png)


![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031220050042-2073770493.png)

类似替罪羊树的重构。

时间复杂度玄学。

推荐：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031220543334-410025313.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031220556633-219883863.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031222549432-512409041.png)

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031222741727-104659895.png)

本题 KDT 本质上是：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031222825265-1063517443.png)

而之后要讲的莫队是：

![](https://img2020.cnblogs.com/blog/2213867/202110/2213867-20211031222935532-271035654.png)

分块：

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211101194650108-1550004012.png)

对每一个块进行块内排序。

询问时对每一个整块求 lower_bound，对零散块暴力枚举，求和即可，时间复杂度 $O(\sqrt{n})$。

修改时对每一个整块 lazy 加 $1$，对零散块暴力枚举，重排即可，时间复杂度 $O(\sqrt{n}\log \sqrt{n})$，但两侧可以使用归并排序的思想重排，优化到 $O(\sqrt{n})$。

总时间复杂度 $O(q\sqrt{n})$。

[P3863 序列](https://www.luogu.com.cn/problem/P3863)

将区间修改和单点查询离线下来。

扫描线按序列 $1\to n$ 顺序扫描。

如果碰到修改的左端点，则扫描线上该时刻及以后的时刻加上对应的值。

如果碰到修改的右端点，则扫描线上该时刻及以后的时刻减去对应的值。

如果碰到一个询问，则求扫描线上该时刻以前的时刻中询问值的 rank。

扫描线上用分块即可。

莫队：

基础太简单，不讲。

复杂度 $O(n\sqrt{m})$。

[P4396 [AHOI2013]作业](https://www.luogu.com.cn/problem/P4396)

经典**莫队**的变形。

sol 1:

莫队区间移动时实时维护一个数组表示某个值在区间内出现的次数和是否出现。

再用树状数组维护它。

最终复杂度 $O(n\sqrt{m}\log n+m\log n)$。

跑得慢，不知道能不能过。

sol 2:

在 sol 1 的基础上将树状数组换成分块维护，实现 $O(1)$ 修改，$O(\sqrt{n})$ 查询。

最终复杂度 $O(n\sqrt{m}+m\sqrt{n})$，能过。

## 2

根号分治：

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104213336780-1607889259.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104213348886-386252088.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104213406975-334446301.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104213431784-1873068585.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104214529541-1236789387.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211104215406895-963230807.png)

树链剖分：

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106212044297-1236307331.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106212056351-748132320.png)

其实树链剖分就是将每个点连重儿子后每条链铺到数组里用线段树维护。

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106212518125-938374378.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106212532230-228505176.png)

# D4:

## 1

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106220716431-1846637032.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106220735583-1803936015.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106220743889-479995033.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106220812258-1237928064.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106220821604-1330830747.png)

静态树分治：

为了更好得理解~~淀粉质~~点分治，先以求逆序对的归并排序方法为引子：

1. 将序列平分

2. 求出左半和右半各取一个构成的逆序对个数

3. 递归进两个子串分别求解

（实际上步骤 2 应该在步骤 3 后面，但便于理解写反了）

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106222642948-1934530341.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106222717020-1628170496.png)

自行去 Luogu 找模板题……

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106223937890-1006290103.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106223957366-1004700292.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106224009654-629899070.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106224021557-584959132.png)

这个是点权，就需要树分治了。

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106224237137-1215659012.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211106224331077-828181599.png)

启发式合并实际上就是链分治。

[P6626 [省选联考 2020 B 卷] 消息传递](https://www.luogu.com.cn/problem/P6626)

经典淀粉质。

## 2

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110211020237-89271277.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110211331680-1976304016.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110212413128-1385155160.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110212419587-1724959745.png)

[P4054 [JSOI2009]计数问题](https://www.luogu.com.cn/problem/P4054)

注意到值域只有 $100$，可以作 $100$ 个数据结构来二维单点修改，矩阵查询。

而且 $n\times m$ 很小（否则就要用树套树或 CDQ 分治了 qwq），直接二维树状数组（本蒟蒻初学）维护每一种值即可。

时间 $O(100nm\log(nm))$。

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110231109055-1051919160.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110231526620-899422242.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110231543083-2121476454.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110231600719-2127535831.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110231845812-2068269058.png)

↑ 本蒟蒻自己画的图

[P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)

CDQ 分治。

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115130515147-364137554.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115130531600-1331783453.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115131659817-1980371112.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115131708597-1182401106.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115131717297-157213451.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115131726300-185501660.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115225648023-783546695.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211115225659127-1799284608.png)

# D5:

## 1

(empty)

## 2

LCT:

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112624526-194636435.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112612591-138127086.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112548252-1689346241.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112559521-1728133489.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112705553-1881480307.png)

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211116112718093-1988525265.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15520224.html</id>
    <title type="text">关于树形背包时间复杂度为什么会比想象中少一阶-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-11-07T09:21:00Z</published>
    <updated>2021-11-07T09:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15520224.html" />
    <content type="text">## Upd 2022年10月3日

对于树上的任意一点 $x$，我们设其贡献的时间复杂度为 $T(x)$。

设 $x$ 的儿子大小分别是 $p_1,\dots,p_c$，设 $x$ 的大小为 $p_0=1+\sum_{i=1}^cp_i$，则
$$
\begin{aligned}
T(x)=&amp;1
\\&amp;+p_1
\\&amp;+p_2(1+p_1)
\\&amp;+p_3(1+p_1+p_2)
\\&amp;+\dots
\\&amp;+p_c(1+p_1+\dots+p_{c-1})
\\=&amp;1+\frac{(1+\sum_{i=1}^cp_i)^2-1-\sum_{i=1}^cp_i^2}{2}
\\=&amp;\frac{1}{2}
(1+p_0^2-\sum_{i=1}^cp_i^2)\end{aligned}
$$
发现不论以什么顺序合并儿子复杂度都是相同的。

总复杂度
$$
\sum_{i=1}^n T(i)=\frac{1}{2}(n+n^2)
$$
相当于把 $-p_i^2$ 这部分负贡献给这个儿子，抵消后只剩根节点 $\text{size}$ 的平方了。

## 远古

**下面的东西太 naive 了，差不多别看了，谢谢。**

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211107152735609-1454619.png)

思路来自 Konata，有删改~~及本作者的想法~~。

如果正常想，每个节点都要进行 $O(n^2)$ 的背包，则时间复杂度为 $O(n^3)$，其实不然。

假设 $n$ 个节点的树形背包的时间复杂度为 $f(n)$。

那么假设根节点下面的子树大小分别为 $p_1,p_2,\dots,p_k$，子树大小 $p_i$ 对应的子树根节点下面的子树大小分别为 $g_{i,1},g_{i,2},\dots,g_{i,s_i}$。

$$\begin{aligned}f(n)
&amp;=\sum\limits^k_{i=1}f(p_i)+\sum\limits^k_{i=2}\left(p_i\times\sum\limits^{i-1}_{j=1}p_j\right)
\\
&amp; = \sum\limits^k_{i=1}f(p_i)+\sum\limits_{1\leqslant i&lt;j\leqslant k}p_i\times p_j
\\
&amp; = \sum\limits^k_{i=1}f(p_i)+\dfrac{\left(\sum\limits^k_{i=1}p_i\right)^2-\sum\limits^k_{i=1}p_i^2}{2}
\\
&amp; = \dfrac{1}{2}(n-1)^2+\sum\limits^k_{i=1}f(p_i)-\dfrac{1}{2}\sum\limits^k_{i=1}p_i^2
\\
&amp; \leqslant \dfrac{1}{2}n^2+\sum\limits^k_{i=1}(f(p_i)-\dfrac{1}{2}p_i^2)
\\
&amp; = \dfrac{1}{2}n^2+\sum\limits^k_{i=1}(\dfrac{1}{2}(p_i-1)^2+\sum\limits^{s_i}_{j=1}(f(g_{i,j})-\dfrac{1}{2}g_{i,j}^2)-\dfrac{1}{2}p_i^2)
\\
&amp; \leqslant \dfrac{1}{2}n^2+\sum\limits^k_{i=1}\sum\limits^{s_i}_{j=1}(f(g_{i,j})-\dfrac{1}{2}g_{i,j}^2)
\\
&amp; \leqslant \dfrac{1}{2}n^2+\sum\sum\dots\sum(f(\dots)-\dfrac{1}{2}(\dots)^2)
\\
&amp; \leqslant \dots
\\
&amp; \leqslant \dfrac{1}{2}n^2
\\
&amp; =O(n^2)
\end{aligned}$$

特殊得，如果背包的容量上限为 $V$，则总时间复杂度为 $O(nV)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15526354.html</id>
    <title type="text">平衡树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-05T08:10:00Z</published>
    <updated>2022-06-05T08:10:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15526354.html" />
    <content type="text"># P3369 【模板】普通平衡树 算法比较

| 名称 | 码长 | 用时 | 内存 | 记录 | 备注 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| Splay（指针版） | 2.26KB | 324ms | 2.75MB | [Link](https://www.luogu.com.cn/record/77371340) | 跑得比普通 struct 的快，而且写起来短，甚至不用开数组~~但是指针 64 位~~ |
| Splay | 3.23KB | 386ms | 2.63MB | [Link](https://www.luogu.com.cn/record/62082510) | 无 |
| 离散化+树状数组 | 1.49KB | 270ms | 1.92MB | [Link](https://www.luogu.com.cn/record/62075226) | 离线做法 小常数 $O(n\log^2 n)$ ~~其实本不能算在这里的~~ |
| FHQ Treap | 1.46KB | 359ms | 1.61MB | [Link](https://www.luogu.com.cn/record/62180624) | 无 |
| __gnu_pbds | 0.94KB | 307ms | 3.75MB | [Link](https://www.luogu.com.cn/record/62128528) | 红黑树 |
| Treap | 2.43KB | 294ms | 2.73MB | [Link](https://www.luogu.com.cn/record/62082759) | 无 |
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15533589.html</id>
    <title type="text">FHQ Treap-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-11-10T07:36:00Z</published>
    <updated>2021-11-10T07:36:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15533589.html" />
    <content type="text">## 2022年10月3日

这波我吹爆 fhq treap，代码简短功能强大不易写错。

据说常数大一点？我不知道啊，反正能写出来就是胜利（？）。

[SP4487 GSS6 - Can you answer these queries VI](https://www.luogu.com.cn/problem/SP4487)

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-03 21:28:32
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
#define N 200010
mt19937 rgen(time(0)+size_t(new(char)));
struct node{
	int sz,l,r,sum,ans;
	node(){}
	node(int x){ sz=1,l=r=sum=ans=x; }
	node(int x,int y,int z,int w,int aa){ sz=x,l=y,r=z,sum=w,ans=aa; }
	friend node operator+(const node&amp; x,const node&amp; y){
		return node(x.sz+y.sz,
			max(x.l,x.sum+y.l),
			max(y.r,y.sum+x.r),
			x.sum+y.sum,
			max({x.ans,y.ans,x.r+y.l})
		);
	}
}t[N];
int ls[N],rs[N],w[N],v[N],root=0,tot=0;
void upd(int rt){
	t[rt]=node(v[rt]);
	if(ls[rt]) t[rt]=t[ls[rt]]+t[rt];
	if(rs[rt]) t[rt]=t[rt]+t[rs[rt]];
}
int nnd(int val){
	t[++tot]=node(val);
	v[tot]=val;
	ls[tot]=rs[tot]=0;
	w[tot]=rgen();
	return tot;
}
int merge(int x,int y){
	// cout&lt;&lt;x&lt;&lt;"~"&lt;&lt;y&lt;&lt;"\n";
	if(!x || !y) return x^y;
	if(w[x]&gt;w[y]){
		rs[x]=merge(rs[x],y);
		upd(x);
		return x;
	}else{
		ls[y]=merge(x,ls[y]);
		upd(y);
		return y;
	}
}
void split(int rt,int k,int &amp;l,int &amp;r){
	if(!rt) return l=r=0,void();
	if(k&lt;=t[ls[rt]].sz) r=rt,split(ls[rt],k,l,ls[rt]);
	else l=rt,split(rs[rt],k-t[ls[rt]].sz-1,rs[rt],r);
	upd(rt);
}
void print(int rt){
	if(!rt) return ;
	print(ls[rt]);
	cout&lt;&lt;v[rt]&lt;&lt;" ";
	print(rs[rt]);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int cnt,x,y,a,b,c,tmp;
	char opt;
	cin&gt;&gt;cnt;
	while(cnt--){
		cin&gt;&gt;x;
		// print(root); cout&lt;&lt;"\n";
		root=merge(root,nnd(x));
	}
	cin&gt;&gt;cnt;
	while(cnt--){
		// print(root);
		// cout&lt;&lt;"\n";
		cin&gt;&gt;opt&gt;&gt;x;
		if(opt=='I'){
			cin&gt;&gt;y;
			split(root,x-1,a,b);
			root=merge(merge(a,nnd(y)),b);
		}else if(opt=='D'){
			split(root,x,c,b);
			split(c,x-1,a,tmp);
			root=merge(a,b);
		}else if(opt=='R'){
			cin&gt;&gt;y;
			split(root,x,c,b);
			split(c,x-1,a,tmp);
			root=merge(a,merge(nnd(y),b));
		}else{
			cin&gt;&gt;y;
			split(root,y,tmp,c);
			split(tmp,x-1,a,b);
			// print(b); cout&lt;&lt;"----\n";
			cout&lt;&lt;t[b].ans&lt;&lt;"\n";
			root=merge(a,merge(b,c));
		}
	}
return 0;}
```
&lt;/details&gt;

## 远古

本质：**无 rotate 平衡树**。

一旦没了 rotate，代码就短好多，思路也清晰。

&gt; 首先说一下，这个东西可以搞一切 bst ， treap ， splay 所能搞的东西。
&gt; ——自为风月马前卒

例题：[P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

[我的提交](https://www.luogu.com.cn/record/62180624)

树的基本东西（正常）：

```cpp
struct node{
	int sz;//树的大小
	int w;//随机数满足大顶堆
	int val;//Key_value
	int ls,rs;//左右儿子
}t[N];
int root=0;//整棵树的根
int tot=0;//类似前向星，存最大下标
void upd(int rt){//更新 sz
	t[rt].sz=t[t[rt].ls].sz+t[t[rt].rs].sz+1;
}
int nwnd(int x){//新建节点
	t[++tot]={1,rand(),x,0,0};
	return tot;
}
```

整个数据结构中只有 $2$ 种操作、$1$ 种询问:

* $\mathtt{split}$ 把一棵树分成两棵树。

```cpp
//将 rt 为根的树分成 &lt;=val 和 &gt;val 两部分，两个根节点存入 l 和 r
void split(int rt,int val,int &amp;l,int &amp;r){
	if(!rt){l=r=0;return ;}//没了！？
	if(t[rt].val&lt;=val)	l=rt,split(t[rt].rs,val,t[rt].rs,r);//右边开裂
	else			r=rt,split(t[rt].ls,val,l,t[rt].ls);//左边开裂
	upd(rt);
}
```

* $\mathtt{merge}$ 把两棵树合成一棵树。

```cpp
//将根为 x 和 y 的树合并
int merge(int x,int y){
	if(!x || !y) return x+y;//一方没了
	if(t[x].w&gt;t[y].w)	{t[x].rs=merge(t[x].rs,y);upd(x);return x;}//x 为根
	else			{t[y].ls=merge(x,t[y].ls);upd(y);return y;}//y 为根
}
```

* $\mathtt{kth}$ 查找一棵树里的第 $k$ 小（二分查找）。

```cpp
//查找根为 rt 的树内 val 第 x 小的位置
int kth(int rt,int x){
	int rk;
	while(true){
		rk=t[t[rt].ls].sz+1;
		if(x==rk) return rt;
		if(x&lt;rk)	rt=t[rt].ls;
		else x-=rk,	rt=t[rt].rs;
	}
}
```

**就结束了……**

我们看看各项操作是如何通过上述操作实现的：

* 插入 $x$。

```cpp
split(root,x,a,b);
root=merge(merge(a,nwnd(x)),b);
```

* 删除 $x$(若有多个相同的数，只删除一个)。

```cpp
split(root,x,a,c);
split(a,x-1,a,b);
root=merge(merge(a,t[b].ls),merge(t[b].rs,c));
```

* 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$)。

```cpp
split(root,x-1,a,b);
cout&lt;&lt;t[a].sz+1&lt;&lt;endl;
root=merge(a,b);
```

* 查询排名为 $x$ 的数。

```cpp
cout&lt;&lt;t[kth(root,x)].val&lt;&lt;endl;
```

* 求 $x$ 的前驱。

```cpp
split(root,x-1,a,b);
cout&lt;&lt;t[kth(a,t[a].sz)].val&lt;&lt;endl;
root=merge(a,b);
```

* 求 $x$ 的后继。

```cpp
split(root,x,a,b);
cout&lt;&lt;t[kth(b,1)].val&lt;&lt;endl;
root=merge(a,b);
```

最后说一下，FHQ 其实是可以处理区间问题的（像 Splay 一样）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15536069.html</id>
    <title type="text">初学 二维树状数组-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-11-10T14:40:00Z</published>
    <updated>2021-11-10T14:40:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15536069.html" />
    <content type="text">二维树状数组可以高效解决二维动态矩形计数问题。

我先带你回顾一下一维树状数组是怎样的：

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110215516468-636436990.png)

$$c_n=\sum\limits^n_{i=n-lowbit(n)+1}a_i$$

设 $\{d^{(n)}\}$ 为

$$\begin{cases}d_1=n\\ d_i=d_{i-1}-lowbit(d_{i-1}) &amp; i&gt;1  \\ d_i&gt;0 &amp; i\in\mathbb{N}^+\end{cases}$$

设 $\{f^{(n)}\}$ 为

$$\begin{cases}f_1=n\\ f_i=f_{i-1}+lowbit(f_{i-1}) &amp; i&gt;1  \\ f_i\leqslant V &amp; i\in\mathbb{N}^+\end{cases}$$

其中 $V$ 为下标的最大值。

则前缀和为

$$\sum\limits^n_{i=1}a_i=\sum\limits_{j\in d^{(n)}}c_j$$

而改变了 $a_n$ 后，$\forall x\in f^{(n)}$，$c_x$ 都要改变。

让我们升一维，二维：

由于本蒟蒻不会做 3D 演示图片，2D 凑合看吧 qwq。

当查询

$$\sum\limits_{i=1}^7\sum\limits_{j=1}^7a_{i,j}$$

时，会用到这些 $c$（相同颜色为其管辖范围，感谢四色定理）：

![](https://img2020.cnblogs.com/blog/2213867/202111/2213867-20211110220940250-1310175430.png)

即

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1}a_{i,j}=\sum\limits_{x\in d^{(n)}}\sum\limits_{y\in d^{(m)}}c_{x,y}$$

而改变了 $a_{n,m}$ 后，$\forall x\in f^{(n)},y\in f^{(m)}$，$c_{x,y}$ 都要改变。

单点修改和矩形（二维前缀的容斥）查询单次均为 $O(\log(nm))$。

其实扩展到多维也是类似的……
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15576550.html</id>
    <title type="text">用生成函数求斐波那契数列（及所有线性递推数列）的通项公式-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-11-20T14:08:00Z</published>
    <updated>2021-11-20T14:08:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15576550.html" />
    <content type="text">斐波那契数列的定义：

$$\begin{cases}f_0=0 \\ f_1=1 \\ f_i=f_{i-1}+f_{i-2}&amp; (i&gt;1)\end{cases}$$

求出特征多项式

$$C(x)=x^2-x-1$$

&gt; 递推关系
&gt; $$f_n=\sum\limits^k_{i=1}c_if_{n-i}$$
&gt; 的特征多项式为
&gt; $$C(x)=x^k-\sum\limits^k_{i=1}c_ix^{k-i}$$

设

$$S=\sum\limits^{\infty}_{i=0} f_ix^i$$

为其生成函数。

推导：

$$\begin{aligned}
S&amp;
=\sum\limits^{\infty}_{i=0} f_ix^i
\\&amp;
=f_0+f_1x+\sum\limits^{\infty}_{i=2} (f_{i-1}+f_{i-2})x^i
\\&amp;
=x+\sum\limits^{\infty}_{i=2} f_{i-1}x^i+\sum\limits^{\infty}_{i=2} f_{i-2}x^i
\\&amp;
=x+x\sum\limits^{\infty}_{i=0} f_ix^i+x^2\sum\limits^{\infty}_{i=0} f_ix^i
\\&amp;
=x+xS+x^2S
\end{aligned}$$

求解：

$$\begin{aligned}
(x^2+x-1)S&amp;=-x
\\
S&amp;=\dfrac{x}{1-x-x^2}
\end{aligned}$$

由于斐波那契数列的特征方程

$$\begin{aligned}
C(x)&amp;=0
\\
x^2-x-1&amp;=0
\end{aligned}$$

的根为

$$x_1=\dfrac{1+\sqrt{5}}{2} \quad x_2=\dfrac{1-\sqrt{5}}{2}$$

所以 $S$ 一定可以分解成

$$\dfrac{A}{1-x_1x}+\dfrac{B}{1-x_2x}$$

的形式。

待定系数法（中间过程太长，故略去）：

$$\begin{aligned}
\dfrac{A}{1-x_1x}+\dfrac{B}{1-x_2x}&amp;=\dfrac{x}{1-x-x^2}
\\
\dfrac{(1-x_2x)A+(1-x_1x)B}{(1-x_1x)(1-x_2x)}&amp;=\dfrac{x}{1-x-x^2}
\\
(1-x-x^2)((1-x_2x)A+(1-x_1x)B)&amp;=x(1-x_1x)(1-x_2x)
\\
\dots
\\
A=\dfrac{\sqrt{5}}{5}
\\
B=-\dfrac{\sqrt{5}}{5}
\end{aligned}$$

所以

$$S=\sum\limits^{\infty}_{i=0} (Ax_1^i+Bx_2^i)x^i$$

对比系数，得：

$$\begin{aligned}
f_n&amp;=Ax_1^n+Bx_2^n
\\&amp;
=\dfrac{\sqrt{5}}{5}\left(
\left(\dfrac{1+\sqrt{5}}{2}\right)^n
-
\left(\dfrac{1-\sqrt{5}}{2}\right)^n
\right)
\end{aligned}$$

觉得整个过程太麻烦？

线性递推通用公式：

设 $C(x)=0$ 有根 $q_1,q_2,\dots,q_t$，重数分别为 $m_1,m_2,\dots,m_t \quad(\sum m=k)$。

$$f_n=\sum\limits^t_{i=1}\sum\limits^{m_i}_{j=1}d_{i,j}\binom{j+n-1}{n}q_i^n$$

其中 $d_{i,j}$ 为自由常量，通过数列的前几项列方程可确定她们。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15700062.html</id>
    <title type="text">关于 Eratosthenes 埃氏筛法的时间复杂度-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-12-16T13:16:00Z</published>
    <updated>2021-12-16T13:16:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15700062.html" />
    <content type="text">这货居然是 $O(n\ln\ln n)$ 的！！！（我一直以为是 $O(n\ln n)$）

[证明](https://www.zhihu.com/question/35112789/answer/61271955)

就是说已经很接近线性了 qwq。

| $n$ | $\ln\ln n$ |
| :------------: | :------------: |
| $10^4$ | $2.2$ |
| $10^5$ | $2.4$ |
| $10^6$ | $2.6$ |
| $10^7$ | $2.8$ |
| $10^8$ | $2.9$ |
| $10^9$ | $3.0$ |
| $10^{18}$ | $3.7$ |
| $10^{100}$ | $5.4$ |
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15731380.html</id>
    <title type="text">重修 二分图-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-07T13:57:00Z</published>
    <updated>2022-07-07T13:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15731380.html" />
    <content type="text">[TOC]

# 匈牙利算法

[别人的博客](https://blog.csdn.net/u013384984/article/details/90718287)

设二分图两边的点集分别为 $X,Y$，边集为 $E$。

## 基本思想

二分图的匹配 $M$ 是最大匹配 $\iff$ 二分图内没有 $M$ 的增广路径。

## 证明

见《图论导引》第 85~86 页。

## 时间复杂度

每次 $X$ 中选一个顶点 $x_i$ 作为起点搜索增广路径，搜索需要遍历 $E$ 内的所有边。因此算法的整体时间复杂度是 $O(|E|\min(|X|,|Y|))$，总的来说是一个相当高效的算法。

# 网络流解决二分图最大匹配

$O(m\sqrt{n})$ 过于简单不再赘述。[网络流](https://www.cnblogs.com/zhangshaojia/p/15915775.html)

# 二分图最大匹配的可行/必经点/边

## 可行边

在残量网络上跑 tarjan 求强联通分量。

若这条边流量为 $1$，或两端点在强联通分量中，则为可行边。

## 必经边

若这条边流量为 $1$，且两端点不在强联通分量中，则为必须边。

## 可行点

存在一条可行边或者必经边就是可行点。

## 必经点

只需求出非必经点即可。

从 $S$ 开始，走 $cap=1$ 的边，走到所有 $X$ 部的点都是答案；从 $T$ 开始，走 $cap=0$ 的边，走到所有 $Y$ 部的点都是答案。

感性理解：首先一个不在匹配的点一定会被走到，这些点都是非必经点。一个最大匹配中的点如果是非必经点，一定可以被一个不在匹配中的点替代掉。从某个不在匹配中的 $X$ 部点出发走非匹配边到 $Y$ 部，如果能走匹配边回来，那么翻转所有匹配边和非匹配边，就能用不在匹配中的那个点代替掉匹配中的 $X$ 部点。

# 二分图最大多重匹配

## 多重匹配定义

给定⼀张包含 $n$ 个左部节点、$m$ 个右部节点的二分图。从中选出尽量多的边，使第 $i$ 个左部节点至多与 $kl_i$ 条选出的
边相连，第 $j$ 个右部节点至多与 $kr_j$ 条选出的边相连。这个问题被称为二分图的多重匹配。

## 解法

依然是网络流大法好 $O(n^2m)$。

# 二分图最大权完备匹配

KM 算法。具体去看 Konata 的 PDF。[或是 OI wiki](https://oi-wiki.org/graph/graph-matching/bigraph-weight-match/)

# 二分图最大权匹配

在 KM 中加虚点让两边的点数相同，然后再把不存在的边的边权都设为 $0$ 即可。

# 一些 NB 克拉斯的定理和等式

$$\Large{
二分图最大匹配=最小点覆盖=总点数-最大独立集
}$$

## Konig 定理

### 内容

二分图的最小点覆盖等于二分图最大匹配。

### 具体构造

#### cxy说

建求最大匹配的网络流，将两部之间的边容量改为 $\inf$（其实改为 $2$ 足矣）（若用 $\inf$ 实现 Dinic 复杂度有保证吗？），求出一个最小割，【源点到左部】或【右部到汇点】的边属于割集则该点属于我们构造的最小点覆盖。

首先将边权改为 $2$ 求得的最大流大小不变，其次两部之间的边不可能满流，所以最小割中的任意边一定有一端是源点或汇点，而且这是一个点覆盖。

#### 远古

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220502191940343-1929405206.png)

## 二分图最大独立集的构造

$$全体点-最小点覆盖点集=最大独立集点集$$

# DAG 的最小路径点覆盖

## 定义

给定⼀张 DAG，要求用尽量少的不相交的简单路径，覆盖 DAG 的所有顶点（也就是每个顶点恰好被覆盖⼀次）。

## 为啥放在「二分图」这里？

因为要拆点后二分图最大匹配做的啊。

## 具体咋做

将 DAG 每个点 $x$ 拆成一个入点 $ix$ 和一个出点 $ox$。对于原来的有向边 $x\to y$，连接 $ox\to iy$。

注意，这种拆点二分图的形式很常见。

## NB 的等式

$$\Large{
DAG 的最小路径点覆盖 = 总点数-拆点二分图最大匹配。
}$$

## 证明

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220503102925079-1594606861.png)

# DAG 的最小路径可重复点覆盖

## 啥叫「可重复」？

也就是上面的问题修改为路径可相交。

形象地，我们要给不干净的墙面喷漆。上一章要求每个不干净的区域恰好被一次喷漆，而这里只要喷过漆就行——多喷几层无妨。

## 咋做？

求 DAG 的最小路径可重复点覆盖 等价于 对原 DAG 求**传递闭包**，再求其拆点二分图的最大匹配。

## Dilworth 定理

$$\Large{
DAG 的最小路径可重复点覆盖=最长反链
}$$

## 例子

### P1020 [NOIP1999 普及组] 导弹拦截

[题面](https://www.luogu.com.cn/problem/P1020)

我们关注第二问：求最少用多少个非升子序列能合成整个给定的序列 $n\le 10^5$。

我们将序列中 $i\to j$ 连边当且仅当 $i&lt;j \land a_i\ge a_j$，我们要求最小路径覆盖，等价于最小路径可重复点覆盖，等价于最长反链，等价于原序列的最长上升子序列长度。

「有的时候，真的就是站得高望得远。」

### CF590E Birthday

[题面](https://www.luogu.com.cn/problem/CF590E)

题解我写在 2022 简思 里了。

# 二分图博弈

## 介绍

两人在一二分图上进行决策，初始状态为二分图的一个点，两人轮流沿边行动，不允许重复访问节点，无法移动者输。

这样的问题称为二分图博弈。

## 求解

**起点 $v$ 是先手必胜的当且仅当其在所有最大匹配上。**

必要性：如果存在一个最大匹配 $M$ 使得 $v$ 不在其上，那么先手每次操作时，要么无路可走，要么走到了某个匹配点上（否则就找到了一条增广路），于是后手只需要每次走到 $M$ 中与之相匹配的节点即可。

充分性：当 $v$ 在所有最大匹配上时，我们取任意最大匹配 $M$，将 $v$ 移动到对应匹配点。可以证明此时 $M$ 删去点 $v$ 和走的匹配后仍是最大匹配，就回到了证明必要性中的情况。

有增广路定理的一下推论：对于无向图 $G$ 和任一最大匹配 $M$，点 $v$ 必定在最大匹配上当且仅当对于 $M$，$v$ 在匹配上且不存在以 $v$ 为一端的偶数长度交错路。（否则可以沿着偶数长度交错路平移匹配方案，就得到了一个 $v$ 不是匹配点的匹配 $M’$，矛盾）。

所以移动并删除点 $v$ 的图中也不存在增广路，充分性得到证明。

## Dinic 实现

考虑用一般网络流算法求解此类问题，我们需要优化判断一个点 $v$ 是否必定在所有最大匹配中的算法。

**点 $v$ 必定在所有最大匹配中当且仅当在某个最大流中 $S$ 到 $v$ 的边有流量，且残量网络上不存在 $S$ 到 $i$ 的路径。**

充分性：$v$ 在最大匹配 $M$ 中当且仅当 $S$ 到 $v$ 的边有流量。若残量网络上存在 $S$ 到 $v$ 的路径，则将这条路径和 $S$ 到 $v$ 的边取反即可得到一个新的，$S$ 到 $v$ 无流量的最大流。

必要性：假设存在一个 $S$ 到 $v$ 无流量的最大流，考虑该最大流与现在的最大流之差，每个点的流量必定平衡。于是由欧拉回路定理，该图必定可被分解为若干简单环的和，取其中包含 $S$ 到 $v$ 的边即可构造出一个残量网络上 $S$ 到 $v$ 的路径。

## 例题

### P4617 [COCI2017-2018#5] Planinarenje

真·模板

[代码](https://www.luogu.com.cn/record/97401519)

### P1971 [NOI2011] 兔兔与蛋蛋游戏

变了一下形。

发现每个位置作为空格只会一次（考虑回来形成的偶环推至矛盾）。

所以将初始的空格看作黑子，他们其实在玩这个游戏：

* 兔兔每次走到相邻的、没走到过的白格。
* 蛋蛋每次走到相邻的、没走到过的黑格。
* 不能操作的人输。

为了判兔兔的失误，我们时光倒流，每次加点在残量上跑流。

若兔兔一次操作前是先手必胜，操作后也是先手必胜（此时先手是蛋蛋），她就失误了。

[代码](https://www.luogu.com.cn/record/97404253)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15734223.html</id>
    <title type="text">线性规划之单纯形法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-12-26T13:38:00Z</published>
    <updated>2021-12-26T13:38:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15734223.html" />
    <content type="text">[超级棒的 blog](https://www.hrwhisper.me/introduction-to-simplex-algorithm/)

[ylwang](https://www.luogu.com.cn/blog/YLWang/post-1111-post)

先鸽着 qwq。

CF671D Roads in Yusland [这里有我的题解](https://www.cnblogs.com/shaojia/p/2022_solution_middle.html)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15742862.html</id>
    <title type="text">FastIO 模板-ShaoJia</title>
    <summary type="html"></summary>
    <published>2021-12-28T13:00:00Z</published>
    <updated>2021-12-28T13:00:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15742862.html" />
    <content type="text">```cpp
#define gc getchar
#define pc putchar
inline int read(){
	int x=0;char c=gc();bool f=0;
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=gc();}
	if(f)x=-x;
	return x;
}
inline void write(int x){
	if(x&lt;0){pc('-');x=-x;}
	if(x&gt;9)write(x/10);
	pc(x%10+'0');
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15754290.html</id>
    <title type="text">2022 做题记录-ShaoJia</title>
    <summary type="html">题目标号规则请见 2021 做题记录 的摘要（https://www.cnblogs.com/zhangshaojia/p/2021_my.html）</summary>
    <published>2022-02-14T06:37:00Z</published>
    <updated>2022-02-14T06:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15754290.html" />
    <content type="text"># July（要不咱 CF 过的题就不在 luogu 交了？LOJ UOJ HDU ATC ACW POJ HYDRO 就都咕了吧/kel）
## 3
arc140_a
arc140_b
arc140_c
arc140_e
## 6
gym/103687/problem/A
gym/103687/problem/B
gym/103687/problem/C
gym/103687/problem/F
gym/103687/problem/G
gym/103687/problem/I
gym/103687/problem/L
gym/103687/problem/M
## 17
abc260_e
Loj2321. 「清华集训 2017」无限之环



# 以下是上个月或更久的：（注：从 April 开始只记录站外题（Luogu 太多了 qwq））
# Jan
## 1
P4609 [FJOI2016]建筑师
349. 黑暗城堡
377. 泥泞的区域
## 2
P4381 [IOI2008] Island
358. 岛屿
359. 创世纪
252. 树
## 3
P3224 [HNOI2012]永无乡
1063. 永无乡
CF1621A Stable Arrangement of Rooks
CF1621B Integers Shop
CF1621C Hidden Permutations
CF1621D The Winter Hike
## 4
CF1621E New School
## 5
P5844 [IOI2011]ricehub
CF1615E Purple Crayon
P4279 [SHOI2008]小约翰的游戏
## 6
P2150 [NOI2015] 寿司晚宴
P8007 「Wdsr-3」永远须臾的走廊
P8008 「Wdsr-3」迷途竹林
P8010 「Wdsr-3」令人感伤的红雨
1003. 寿司晚宴
## 7
P8001 Easy Strings Merging
## 8
P1072 [NOIP2009 提高组] Hankson 的趣味题
P1071 [NOIP2009 提高组] 潜伏者
P1941 [NOIP2014 提高组] 飞扬的小鸟
agc023_d
AT3955 [AGC023D] Go Home
abc234_a
abc234_b
abc234_c
abc234_d
abc234_e
abc234_f
abc234_g
abc234_h
## 9
UVA12716 GCD等于XOR GCD XOR
198. 反素数
196. 质数距离
199. 余数之和
203. 同余方程
## 10
UVA11440 帮帮Tomisu Help Tomisu
UVA1642 魔法GCD Magical GCD
## 11
UVA1393 （抽象问题）高速公路 Highways
CF1622E Math Test
## 12
P3381 【模板】最小费用最大流
P1006 [NOIP2008 提高组] 传纸条
275. 传纸条
382. K取方格数
## 13
P3216 [HNOI2011]数学作业
## 15
CF1622F Quadratic Set
P7998 [WFOI - 01] 猜数（guess）
P6366 特殊的翻转
P7852 「EZEC-9」Yet Another Easy Problem
abc235_a
abc235_b
abc235_c
abc235_d
abc235_e
abc235_g
## 16
P5427 [USACO19OPEN]Left Out S
## 17
CF1624A Plus One on the Subset
CF1624B Make AP
CF1624C Division by Two and Permutation
CF1624D Palindromes Coloring
CF1624E Masha-forgetful
CF1624F Interacdive Problem
CF1624G MinOr Tree
## 18
CF1627A Not Shading
CF1627B Not Sitting
CF1627C Not Assigning
CF1627D Not Adding
CF1627E Not Escaping
## 19
UVA1648 商业中心 Business Center
## 20
P4780 Phi的反函数
UVA10837 一个研究课题 A Research Problem
P1574 超级数
P2634 [国家集训队]聪聪可可
## 21
P4536 [CQOI2007]三角形
P2158 [SDOI2008] 仪仗队
P4302 [SCOI2003]字符串折叠
P8054 A 质因数
P8050 [ZYOI Round1] Chessboard game/棋盘游戏
P8051 [ZYOI Round1] Bird/鸟
P8052 [ZYOI Round1] Truth/真心话大冒险
## 22
P7518 [省选联考 2021 A/B 卷] 宝石
167. 木棒
## 23
CF446C DZY Loves Fibonacci Numbers
CF1555E Boring Segments
P7322 「PMOI-4」排列变换
CF1593G Changing Brackets
P2202 [USACO13JAN]Square Overlap S
## 24
P2132 小Z的队伍排列
271. 杨老师的照相排列
abc236_a
abc236_b
abc236_c
abc236_d
abc236_e
abc236_f
## 25
CF1629A Download More RAM
CF1629B GCD Arrays
CF1628A Meximum Array
CF1628B Peculiar Movie Preferences
CF1628C Grid Xor
CF1628D1 Game on Sum (Easy Version)
CF1628D2 Game on Sum (Hard Version)
## 26
UVA1025 城市里的间谍 A Spy in the Metro
UVA10934 装满水的气球 Dropping water balloons
UVA1347 旅行 Tour
UVA1625 颜色的长度 Color Length
CF1404D Game of Pairs
UVA12099 书架 The Bookcase
P3599 Koishi Loves Construction
## 27
306. 杰拉尔德和巨型象棋
291. 蒙德里安的梦想
## 28
P1439 【模板】最长公共子序列
CF1151F Sonya and Informatics
277. 饼干
274. 移动服务
## 29
P2657 [SCOI2009] windy 数
arc134_a
arc134_b
arc134_c
## 30
UVA1292 Strategic game
UVA10859 放置街灯 Placing Lampposts
# Feb
## 1
arc134_a
arc134_b
arc134_c
abc237_a
abc237_b
abc237_c
abc237_d
abc237_e
abc237_f
abc237_g
310. 启示录
## 2
CF1631A Min Max Swap
CF1631B Fun with Even Subarrays
CF1630A And Matching
CF1630B Range and Partition
CF1630D Flipping Range
CF1632A ABC
CF1632B Roof Construction
CF1632C Strange Test
CF1632D New Year Concert
CF1632E1 Distance Tree (easy version)
CF1632E2 Distance Tree (hard version)
CF1633A Div. 7
CF1633B Minority
CF1633C Kill the Monster
CF1633D Make Them Equal
309. 装饰围栏
P2824 [HEOI2016/TJOI2016]排序
## 3
CF1616E Lexicographically Small Enough
P2168 [NOI2015] 荷马史诗
149. 荷马史诗
## 4
UVA10004 Bicoloring
UVA1394 And Then There Was One
P3239 [HNOI2015]亚瑟王
P8090 [USACO22JAN] Herdle B
P8091 [USACO22JAN] Non-Transitive Dice B
P8092 [USACO22JAN] Drought B
P8093 [USACO22JAN] Searching for Soulmates S
P8094 [USACO22JAN] Cow Frisbee S
arc134_d
P3067 [USACO12OPEN]Balanced Cow Subsets G
P4799 [CEOI2015 Day2]世界冰球锦标赛
## 5
P8109 [Cnoi2021]幻想乡程序设计大赛
P8095 [USACO22JAN] Cereal 2 S
abc238_a
abc238_b
abc238_c
abc238_d
abc238_e
abc238_f
## 6
CF13C Sequence
P2893 [USACO08FEB]Making the Grade G
P4331 [BalticOI 2004]Sequence 数字序列
CF713C Sonya and Problem Wihtout a Legend
P4597 序列 sequence
273. 分级
P8097 [USACO22JAN] Farm Updates G
P8115 Table
P8116 魔理沙的计算器
P8118 Mystery
## 7
P1168 中位数
## 8
P5788 【模板】单调栈
CF1470E Strange Permutation
239. 奇偶游戏
## 9
P7771 【模板】欧拉路径
CF1634A Reverse and Concatenate
CF1634B Fortune Telling
CF1634C OKEA
CF1634D Finding Zero
CF1634E Fair Share
## 10
P8111 [Cnoi2021]区间
CF1634F Fibonacci Additions
P7071 [CSP-J2020] 优秀的拆分
P7072 [CSP-J2020] 直播获奖
P7073 [CSP-J2020] 表达式
P7074 [CSP-J2020] 方格取数
P1075 [NOIP2012 普及组] 质因数分解
P1077 [NOIP2012 普及组] 摆花
P1981 [NOIP2013 普及组] 表达式求值
P2010 [NOIP2016 普及组] 回文日期
P2118 [NOIP2014 普及组] 比例简化
P2141 [NOIP2014 普及组] 珠心算测验
P2669 [NOIP2015 普及组] 金币
P2670 [NOIP2015 普及组] 扫雷游戏
P2671 [NOIP2015 普及组] 求和
P2239 [NOIP2014 普及组] 螺旋矩阵
P2058 [NOIP2016 普及组] 海港
P1076 [NOIP2012 普及组] 寻宝
P1078 [NOIP2012 普及组] 文化之旅
P4139 上帝与集合的正确用法
P2572 [SCOI2010]序列操作
## 11
P1158 [NOIP2010 普及组] 导弹拦截
P1179 [NOIP2010 普及组] 数字统计
P1190 [NOIP2010 普及组] 接水问题
P1199 [NOIP2010 普及组] 三国游戏
P1307 [NOIP2011 普及组] 数字反转
P1308 [NOIP2011 普及组] 统计单词数
P1309 [NOIP2011 普及组] 瑞士轮
P1310 [NOIP2011 普及组] 表达式的值
P5023 [NOIP2018 提高组] 填数游戏
P2258 [NOIP2014 普及组] 子矩阵
CF1633E Spanning Tree Queries
## 12
P2680 [NOIP2015 提高组] 运输计划
P8143 [JRKSJ R4] Stirling
P8148 声海 | Sea of Voices
P8149 泪光 | Tears
## 13
P8152 「PMOI-5」破译の论
P8153 「PMOI-5」送分题/Yet Another Easy Strings Merging
## 14
arc135_a
arc135_b
arc135_c
arc135_d
P4213 【模板】杜教筛（Sum）
## 15
CF1637A Sorting Parts
CF1637B MEX and Array
CF1637C Andrew and Stones
CF1637D Yet Another Minimization Problem
CF1637E Best Pair
CF1638A Reverse
CF1638B Odd Swap Sort
CF1638C Inversion Graph
CF1638D Big Brush
CF1638E Colorful Operations
## 16
CF896C Willem, Chtholly and Seniorious
P4979 矿洞：坍塌
P8113 [Cnoi2021] 自我主义的平衡者
CF808G Anthem of Berland
## 17
CF915E Physical Education Lessons
P2787 语文1（chin1）- 理理思维
## 18
CF817F MEX Queries
## 19
P1637 三元上升子序列
P8114 [Cnoi2021] 六边形战士
CF1638C Inversion Graph
CF1626E Black and White Tree
P5666 [CSP-S2019] 树的重心
abc239_a
abc239_b
abc239_c
abc239_d
abc239_e
abc239_f
## 20
abc239_g
abc239_h
P3376 【模板】网络最大流
P1999 高维正方体
P5194 [USACO05DEC]Scales S
CF379F New Year Tree
## 21
CF1635A Min Or Sum
CF1635B Avoid Local Maximums
CF1635C Differential Sorting
CF1635D Infinite Set
CF1635E Cars
CF1635F Closest Pair
abc240_a
abc240_b
abc240_c
abc240_d
abc240_e
abc240_f
## 22
abc240_g
UVA12805 Raiders of the Lost Sign
CF1278F Cards
## 23
CF1642A Hard Way
CF1642B Power Walking
CF1641A Great Sequence
CF1641B Repetitions Decoding
CF1641C Anonymity Is Important
## 24
P8096 [USACO22JAN] Drought G
P8098 [USACO22JAN] Tests for Haybales G
CF1637F Towers
CF1630C Paint the Middle
## 25
P6066 [USACO05JAN]Watchcow S
P5894 [IOI2013]robots 机器人
P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包
## 26
P1349 广义斐波那契数列
P1939 【模板】矩阵加速（数列）
P3389 【模板】高斯消元法
P2344 [USACO11FEB]Generic Cow Protests G
abc241_a
abc241_b
abc241_c
abc241_d
abc241_e
abc241_f
## 27
arc136_a
arc136_b
arc136_c
arc136_d
## 28
P8177 「EZEC-11」等差数列
P3829 [SHOI2012]信用卡凸包
297. 赤壁之战
# Mar
## 1
P1880 [NOI1995] 石子合并
P1775 石子合并（弱化版）
P5782 [POI2001] 和平委员会
P3387 【模板】缩点（Kosaraju &amp; Tarjan）
## 2
P2119 [NOIP2016 普及组] 魔法阵
P5681 [CSP-J2019 江西] 面积
P5682 [CSP-J2019 江西] 次大值
P5683 [CSP-J2019 江西] 道路拆除
P5684 [CSP-J2019 江西] 非回文串
P5686 [CSP-S2019 江西] 和积和
P5687 [CSP-S2019 江西] 网格图
P5690 [CSP-S2019 江西] 日期
P1912 [NOI2009] 诗人小G
304. 诗人小G
## 3
P3879 [TJOI2010] 阅读理解
P1447 [NOI2010] 能量采集
P3455 [POI2007]ZAP-Queries
## 4
CF348D Turtles
P6378 [PA2010] Riddle
## 5
CF1625A Ancient Civilization
CF1625B Elementary Particles
CF1625C Road Optimization
CF1625D Binary Spiders
CF1625E1 Cats on the Upgrade (easy version)
## 6
P8187 [USACO22FEB] Robot Instructions S
UVA1636 决斗 Headshot
UVA11181 条件概率 Probability|Given
UVA1639 糖果 Candy
P8190 [USACO22FEB] Cow Camp G
## 7
P8191 [USACO22FEB] Moo Network G
P8189 [USACO22FEB] Redistributing Gifts G
UVA11297 Census
96. 奇怪的汉诺塔
## 8
P2325 [SCOI2005]王室联邦
P8183 [USACO22FEB] Sleeping in Class B
P8184 [USACO22FEB] Photoshoot 2 B
P8185 [USACO22FEB] Blocks B
P3660 [USACO17FEB]Why Did the Cow Cross the Road III G
UVA11021 Tribles
## 9
P4767 [IOI2000]邮局
UVA11427 Expect the Expected
UVA10648 Chocolate Box
P8186 [USACO22FEB] Redistributing Gifts S
## 10
CF1039D You Are Given a Tree
## 11
abc242_a
abc242_b
abc242_c
abc242_d
abc242_e
abc242_g
​​212. 计数交换
CF1646A Square Counting
CF1646B Quality vs Quantity
CF1646C Factorials and Powers of Two
CF1646D Weight the Tree
CF1646E Power Board
CF1649A Game
CF1649B Game of Ball Passing
CF1648A Weird Sum
CF1648B Integral Array
CF1648C Tyler and Strings
CF1650A Deletions of Two Adjacent Letters
CF1650B DIV + MOD
CF1650C Weight of the System of Nested Segments
CF1650D Twist the Permutation
CF1650E Rescheduling the Exam
CF1650F Vitaly and Advanced Useless Algorithms
CF1650G Counting Shortcuts
P1462 通往奥格瑞玛的道路
## 12
P1058 [NOIP2008 普及组] 立体图
P6190 [NOI Online #1 入门组] 魔法
T229470 A. 小智的疑惑
T229471 B. 三元组
T229472 C. 排排队
T229473 D. 背单词的小智
T229475 F1. 生活在树上（easy version）
T229476 F2. 生活在树上（hard version）
## 14
P1903 [国家集训队] 数颜色 / 维护队列
CF1647A Madoka and Math Dad
CF1647B Madoka and the Elegant Gift
CF1647C Madoka and Childish Pranks
CF1647D Madoka and the Best School in Russia
CF1647E Madoka and the Sixth-graders
CF1651A Playoff
CF1651B Prove Him Wrong
CF1651C Fault-tolerant Network
CF1651D Nearest Excluded Points
## 17
P8208 [THUPC2022 初赛] 骰子旅行
P8217 [THUPC2022 初赛] 数正方体
P8207 [THUPC2022 初赛] 最小公倍树
P8210 [THUPC2022 初赛] 造计算机
P8216 [THUPC2022 初赛] 画图
## 18
CF165E Compatible Numbers
P2869 [USACO07DEC]Gourmet Grazers G
CF383E Vowels
## 19
P4774 [NOI2018] 屠龙勇士
P8219 [WFOI - 02] I wanna a feasitor（化验器）
P8220 [WFOI - 02] I wanna win the race（比赛）
P1226 【模板】快速幂||取余运算
P5960 【模板】差分约束算法
P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈
P3385 【模板】负环
P4549 【模板】裴蜀定理	
P3846 [TJOI2007] 可爱的质数/【模板】BSGS
P5091 【模板】扩展欧拉定理
arc137_a
arc137_b
arc137_c
arc137_d
​​abc243_a
​​abc243_b
​​abc243_c
​​abc243_d
​​abc243_e
​​abc243_f
​​abc243_g
## 21
CF1500B Two chandeliers
CF1278E Tests for problem D
P2233 [HNOI2002]公交车路线
## 23
P2579 [ZJOI2005]沼泽鳄鱼
P4884 多少个 1？
P3306 [SDOI2013] 随机数生成器
P2485 [SDOI2011]计算器	
P2151 [SDOI2009]HH去散步
P4159 [SCOI2009] 迷路
P1031 [NOIP2002 提高组] 均分纸牌
P2512 [HAOI2008]糖果传递
P8225 「Wdoi-5」天才⑨与天才拆分
P4550 收集邮票
P4861 按钮
## 24
P4318 完全平方数
CF1270F Awesome Substrings
P6348 [PA2011]Journeys
CF1654A Maximum Cake Tastiness
CF1654B Prefix Removals
CF1654C Alice and the Cake
CF1654D Potion Brewing Class
CF1654E Arithmetic Operations
## 25
CF1656A Good Pairs
CF1656B Subtract Operation
CF1656C Make Equal With Mod
CF1656D K-good
CF1656E Equal Tree Sums
## 26
P8251 [NOI Online 2022 提高组] 丹钓战
P8252 [NOI Online 2022 提高组] 讨论
P6026 餐馆
P6042 「ACOI2020」学园祭
P8254 [NOI Online 2022 入门组] 王国比赛
P8255 [NOI Online 2022 入门组] 数学游戏
abc245_a
abc245_b
abc245_c
abc245_d
abc245_e
abc245_f
abc245_g
## 27
T230132 [愚人节比赛 2022] 等待
T230302 [愚人节比赛 2022] 辉光之针的小人族 ~ Little Princess
T230828 [愚人节比赛 2022] The Luogu Tree
CF797E Array Queries
## 28
CF5E Bindian Signalizing
CF109C Lucky Tree
CF711D Directed Roads
P6007 [USACO20JAN]Springboards G
P6626 [省选联考 2020 B 卷] 消息传递
## 29
P5906 【模板】回滚莫队&amp;不删除莫队
AT1219 歴史の研究
P3047 [USACO12FEB]Nearby Cows G
P4137 Rmq Problem / mex
CF1092F Tree with Maximum Cost
P2986 [USACO10MAR] Great Cow Gathering G
P1763 埃及分数
P2886 [USACO07NOV]Cow Relays G
## 30
P4454 [CQOI2018]破解D-H协议
UVA11212 编辑书稿 Editing a Book
CF833B The Bakery
## 31
CF449D Jzzhu and Numbers
179. 八数码
# April
## 15
​​170. 加成序列
​​171. 送礼物
​​294. 计算重复​​
​​340. 通信线路
​​344. 观光之旅
​​342. 道路与航线
​​383. 观光
## 21
abc247_a
abc247_b
abc247_c
abc247_d
abc247_e
abc247_f
abc247_g
abc242_a
abc242_b
abc242_c
abc242_d
abc242_e
abc242_g
abc246_a
abc246_b
abc246_c
abc246_d
abc246_e
abc246_f
abc246_g
abc248_a
abc248_b
abc248_c
abc248_d
abc248_e
abc248_f
abc248_g
​​292. 炮兵阵地
## 22
arc138_a
arc138_b
arc138_c
arc138_d
## 25
abc236_g
abc249_e
abc249_f

# May
## 4
​​379. 捉迷藏
​​376. 机器任务
​​378. 骑士放置​​
374. 导弹防御塔
​​373. 車的放置
​​372. 棋盘覆盖
## 5
405. 将他们分好队
407. 稳定的牛分配
## 11
​​375. 蚂蚁
​​410. 排版幻灯片
​​381. 有线电视网络
## 12
abc250_a
abc250_b
abc250_c
abc250_d
abc250_e
abc250_f
abc250_g
abc250_h</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15795622.html</id>
    <title type="text">重修 MCMF 最小费用最大流-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-12T14:43:00Z</published>
    <updated>2022-01-12T14:43:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15795622.html" />
    <content type="text"># Primal-Dual 原始对偶算法

Upd 2023年10月24日

我们尝试将 $f$ 次 spfa 改成 dijkstra 来优化复杂度。

但是边权不一定是非负的，考虑搬用全源最短路（Johnson）的做法（[这里能找到](https://www.cnblogs.com/shaojia/p/2023sol3.html)），给每个点设一个势能 $h_i$（$h_S=0$）使得每条边加上势能差后都非负。

但是网络流的图是会变的，会有反向边出现，我们只需要每次增广之后将所有点势能 $h_i$ 加上 $dis_i$，其中 $dis_i$ 为新边权跑出来的最短路。

证明略，可看 [OI-wiki](https://oi-wiki.org/graph/flow/min-cost/#primal-dual-%E5%8E%9F%E5%A7%8B%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95)

[Code](https://www.luogu.com.cn/record/131376837)

由于初始求势能要一次 spfa，复杂度 $O(nm+mf\log)$。

# 用途

求**在满足最大流的情况下最小的费用**。

# 算法思路

每次找到一条**费用之和最小**的增广路径增广（反向边的费用是正向边的相反数）。

易证明贪心正确，或参考 [OI Wiki 的证明](https://oi-wiki.org/graph/flow/min-cost/)。

# 具体实现

每次在**残量网络中跑 Bellman-Ford 或 SPFA**（**按费用跑最短路**），取**路径**上流量最小值增广，修改答案并改动网络上的这条路径。

注意我们不像 Dinic 一样按树形增广，而是**像 EK 一样单条路径**。~~树形也行，不过时间一样，何必呢。~~

# 时间复杂度

$O(nmf)$ 点数、边数、最大流的积。

最坏可以到达 $O(n^32^{n/2})$，其实不刻意卡的话是**伪多项式复杂度**的。

~~由于 SPFA 已经玄学了，MCMF 时间复杂度更是玄学。~~

# 例题 &amp; Code

## P3381 【模板】最小费用最大流

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define N 5010
#define M 50010
#define inf 0x7fffffff
struct edge{int to,flow,cost,nxt;}e[2*M];//2 times of edges!!!
int head[N],tot=1;
int n,m,S,T;
inline void adde(int x,int y,int flow,int cost){
	e[++tot]=(edge){y,flow, cost,head[x]}; head[x]=tot;
	e[++tot]=(edge){x,0   ,-cost,head[y]}; head[y]=tot;
}
int dis[N];//min toll to i (which SPFA works)
int flow[N];//the flow of the path with the min toll from S to i (just ONE path)
int pre[N],lst[N];//the last node and edge of the path with the min toll
queue&lt;int&gt; q;//for SPFA
bool ins[N];//in the queue or not to reduce the useless 'q.push()'
bool spfa(){
	while(!q.empty()) q.pop();
	For(i,1,n) ins[i]=pre[i]=0;
	For(i,1,n) dis[i]=inf;
	dis[S]=0;
	ins[S]=1;
	flow[S]=inf;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		ins[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int to=e[i].to;
			assert(e[i].flow&gt;=0);
			if(e[i].flow==0 || dis[to]&lt;=dis[x]+e[i].cost) continue;
			dis[to]=dis[x]+e[i].cost;
			pre[to]=x;
			lst[to]=i;
			flow[to]=min(flow[x],e[i].flow);
			if(!ins[to]){
				ins[to]=1;
				q.push(to);
			}
		}
	}
	return dis[T]&lt;inf;
}
void mcmf(){
	int mf=0;
	int mc=0;
	while(spfa()){//find ONE augmentation path at a time to augment
		mf+=flow[T];
		mc+=flow[T]*dis[T];
		int x=T;
		while(x!=S){
			e[lst[x]  ].flow-=flow[T];
			e[lst[x]^1].flow+=flow[T];
			x=pre[x];
		}
	}
	cout&lt;&lt;mf&lt;&lt;" "&lt;&lt;mc&lt;&lt;endl;
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;
	int x,y,w,c;
	while(m--){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;c;
		adde(x,y,w,c);
	}
	mcmf();
return 0;}
```

去注释版：

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define N 5010
#define M 50010
#define inf 0x7fffffff
struct edge{int to,flow,cost,nxt;}e[2*M];
int head[N],tot=1;
int n,m,S,T;
inline void adde(int x,int y,int flow,int cost){
	e[++tot]=(edge){y,flow, cost,head[x]}; head[x]=tot;
	e[++tot]=(edge){x,0   ,-cost,head[y]}; head[y]=tot;
}
int dis[N];
int flow[N];
int pre[N],lst[N];
queue&lt;int&gt; q;
bool ins[N];
bool spfa(){
	while(!q.empty()) q.pop();
	For(i,1,n) ins[i]=pre[i]=0;
	For(i,1,n) dis[i]=inf;
	dis[S]=0;
	ins[S]=1;
	flow[S]=inf;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		ins[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int to=e[i].to;
			assert(e[i].flow&gt;=0);
			if(e[i].flow==0 || dis[to]&lt;=dis[x]+e[i].cost) continue;
			dis[to]=dis[x]+e[i].cost;
			pre[to]=x;
			lst[to]=i;
			flow[to]=min(flow[x],e[i].flow);
			if(!ins[to]){
				ins[to]=1;
				q.push(to);
			}
		}
	}
	return dis[T]&lt;inf;
}
void mcmf(){
	int mf=0;
	int mc=0;
	while(spfa()){
		mf+=flow[T];
		mc+=flow[T]*dis[T];
		int x=T;
		while(x!=S){
			e[lst[x]  ].flow-=flow[T];
			e[lst[x]^1].flow+=flow[T];
			x=pre[x];
		}
	}
	cout&lt;&lt;mf&lt;&lt;" "&lt;&lt;mc&lt;&lt;endl;
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;
	int x,y,w,c;
	while(m--){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&gt;&gt;c;
		adde(x,y,w,c);
	}
	mcmf();
return 0;}
```

## AcWing382. K取方格数

算是 传纸条 的加强版吧。

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define cerr cerr&lt;&lt;'_'
#define debug cerr&lt;&lt;"Passed line #"&lt;&lt;__LINE__&lt;&lt;endl
template&lt;typename T&gt;T ov(T x){cerr&lt;&lt;"Value: "&lt;&lt;x&lt;&lt;endl;return x;}
#define N 52
#define inf 0x3f3f3f3f
//Since the algorithm template is the minimum cost flow, 
//and the topic requires the maximum value, 
//the edge weights take the opposite number. 
struct edge{int to,flow,cost,nxt;}e[8*N*N];
int head[2*N*N],tot=1;
int n,k,S,T,lim;
inline int num(int x,int y,bool z){return (((x-1)*n+y)&lt;&lt;1)+z;}
inline void adde(int x,int y,int flow,int cost){
	e[++tot]=(edge){y,flow, cost,head[x]}; head[x]=tot;
	e[++tot]=(edge){x,0   ,-cost,head[y]}; head[y]=tot;
}
int dis[2*N*N];//min toll to i (which SPFA works)
int flow[2*N*N];//the flow of the path with the min toll from S to i (just ONE path)
int pre[2*N*N],lst[2*N*N];//the last node and edge of the path with the min toll
queue&lt;int&gt; q;//for SPFA
bool ins[2*N*N];//in the queue or not to reduce the useless 'q.push()'
bool spfa(){
	while(!q.empty()) q.pop();
	For(i,1,lim) ins[i]=pre[i]=0;
	For(i,1,lim) dis[i]=inf;
	dis[S]=0;
	ins[S]=1;
	flow[S]=inf;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		ins[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int to=e[i].to;
			assert(e[i].flow&gt;=0);
			if(e[i].flow==0 || dis[to]&lt;=dis[x]+e[i].cost) continue;
			dis[to]=dis[x]+e[i].cost;
			pre[to]=x;
			lst[to]=i;
			flow[to]=min(flow[x],e[i].flow);
			if(!ins[to]){
				ins[to]=1;
				q.push(to);
			}
		}
	}
	return dis[T]&lt;inf;
}
int mcmf(){
	int mf=0;//useless in this problem
	int mc=0;
	while(spfa()){//find ONE augmentation path at a time to augment
		mf+=flow[T];
		mc+=flow[T]*dis[T];
		int x=T;
		while(x!=S){
			e[lst[x]  ].flow-=flow[T];
			e[lst[x]^1].flow+=flow[T];
			x=pre[x];
		}
	}
	return mc;
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;k;
	int x;
	For(i,1,n) For(j,1,n){
		cin&gt;&gt;x;
		adde(num(i,j,0),num(i,j,1),1,-x);
		adde(num(i,j,0),num(i,j,1),k,0);//'k' means inf 
	}
	For(i,1,n) For(j,1,n-1) adde(num(i,j,1),num(i,j+1,0),k,0);
	For(i,1,n-1) For(j,1,n) adde(num(i,j,1),num(i+1,j,0),k,0);
	S=1,lim=T=num(n,n,1)+1;
	adde(S,num(1,1,0),k,0);//but only here not,JUST k 
	adde(num(n,n,1),T,k,0);
	cout&lt;&lt;(-mcmf())&lt;&lt;endl;//DONT forget to *(-1)
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15805706.html</id>
    <title type="text">IO 时间比较-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-14T14:27:00Z</published>
    <updated>2022-01-14T14:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15805706.html" />
    <content type="text"># Input

先鸽着。

# Output

输出 $10^5$ 个 `"1"`（每个后换行）。

每个数据都测 $20$ 次取平均值。

`ios` 表示 `ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)`。
| 方式 | 时间（秒） |
| :------------: | :------------: |
| puts() | 0.110 |
| printf() | 0.591 |
| cout+'\n' | 0.126 |
| cout+endl | 2.202 |
| ios+cout+'\n' | 0.123 |
| ios+cout+endl | 2.152 |
| 交替 cout+endl printf() | 1.510 |</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15841285.html</id>
    <title type="text">线性基-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-25T14:34:00Z</published>
    <updated>2022-01-25T14:34:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15841285.html" />
    <content type="text">[Luogu 例题](https://www.luogu.com.cn/problem/P3812)

[Someone's Blog](https://www.luogu.com.cn/blog/xzc/xian-xing-ji)

[洛谷日报](https://www.luogu.com.cn/blog/RP-INT-MAX/qian-tan-xian-xing-ji)

[sooke 正交线性基](https://www.luogu.com.cn/blog/Sooke/orthogonal-linear-basis)

## 概念

（自己总结的）

大小 $\log n$ 的数组来表述一个大小为 $n$ 的原数组的异或问题的数据结构。

## 本质

多维向量的作为基底的特殊形式，可用高斯消元理解。

## 构造

本构造线性基中每一个数 $x$ 都对应了原来每一个二进制位，即 $upperbit(x)$，所以线性基的二进制最高位互不相同。

我们构造 $\{a\}$ 的线性基 $\{p\}$。

每次插入一个数 $x\in\{a\}$，如果 $\exists y\in\{p\}\ |\ upperbit(x)=upperbit(y)$（即若 $y$ 想加入线性基，她所属的二进制位已被占），则 $x'=x\operatorname{xor} y$，这使得 $upperbit(x')&lt;upperbit(x)$，递推即可。当然若 $x$ 最后为 $0$ 则他与前面的线性基线性有关，废掉 $x$。

```
void insert(int x){
    for(int i = 63;i&gt;=0;i--){
        if(x&amp;(1ll&lt;&lt;i)){
            if(!p[i]){
                p[i]=x;
                return ;
            }
            x^=p[i];
        }
    }
}
```

## 实战

### 开头的例题：查询一个数集的任意子集的异或最大值

建立线性基，贪心从高位到低位。

```
for(long long i=62;i&gt;=0;i--)
    if((p[i]^ans)&gt;ans)
        ans^=p[i];
```

[My Record](https://www.luogu.com.cn/record/53508627)

### AtCoder：给定 $\{a_1,\dots,a_{2^n-1}\}$，求一组 $S=\{1,\dots,2^n-1\}$ 的线性基 $\{p\}$ 使得 $\sum_{x\in p}a_x$ 最小

[链接](https://atcoder.jp/contests/abc236/tasks/abc236_f)

贪心：按 $a_x$ 将 $S$ 排序，顺序遍历贪心取入答案，具体见代码。

[My Record](https://atcoder.jp/contests/abc236/submissions/28797771)

### CF1100F Ivan and Burgers

给一个数组 $a_1,\dots,a_n$，值域 $m$，$q$ 次询问 $a[l,r]$ 中取任意个数的异或最大值。

可强制在线，$O((n+q)\log m)$ 做法。

对于每一个前缀维护其线性基，但是线性基不支持减。

所以对于每个线性基的每个位，存一下这个位在 $a$ 中的下标（称为时间）。

查询即为在 $r$ 的线性基里只用时间 $\ge l$ 的位置能组成的最大值。

但是我们对于每个前缀要贪心地将每一位的时间更大，更高位优先。

所以我们线性基插入 $(x,t)$ 时，设当前位是 $(x',t')$：

* 若 $x'=0$，则直接赋为 $(x,t)$，退出函数。
* 若 $t'&lt;t$，则 swap $t,t'$，swap $x,x'$。
* 将 $x$ 异或上 $x'$，转至下一位。

[Code](https://codeforces.com/contest/1100/submission/191845237)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15852179.html</id>
    <title type="text">重修 概率期望-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-28T06:29:00Z</published>
    <updated>2022-01-28T06:29:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15852179.html" />
    <content type="text">&gt; Konata28：遇到概率期望题不要怕！

两种方向：**写出 Dp 转移式后直接套原公式算**和**算贡献**。

# Dp

这种 Dp 基本上是**倒推的**（也许记忆化搜索写起来更方便？）。

因为是数学公式，前面状态的期望需要后面的推回来。

# 贡献

这种情况就没用统一的解题格式了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15855657.html</id>
    <title type="text">重修 数位Dp-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-01-29T11:14:00Z</published>
    <updated>2022-01-29T11:14:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15855657.html" />
    <content type="text">[P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657)

[submission](https://www.luogu.com.cn/record/68296282)

先鸽着</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15866192.html</id>
    <title type="text">2022 简思短解（上）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-02T07:57:00Z</published>
    <updated>2022-08-02T07:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15866192.html" />
    <content type="text">## CF633H Fibonacci-ish II

&gt; 给定一个长度为 $n$ 的序列 $\{a\}$，$q$ 次询问，每次给出 $[l,r]$ 要你求 $a[l,r]$ 中的元素**去重排序**后的序列分别乘上 $1,1,2,3,5,\dots$（Fib）后的乘积和。
&gt; 
&gt; 允许离线，答案对 $m$ 取模。
&gt;
&gt; $n,q,m\le 3\times 10^4$

先将值离散化（记得存离散化后到原值的映射）。

考虑莫队，维护区间内出现的值，存入权值线段树。

线段树维护单点改，区间矩阵乘（Fib 转移矩阵）即可，细节较多，看代码。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pi pair&lt;int,int&gt;
#define pso emplace_soack
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define desoug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
const int N=30005,V=15*N,gap=300;
int mod,a[N],so[N],lim,n,q,b[N],ans[N],cnt[N];
pi operator+(pi x,pi y){ return mkp((x.fir+y.fir)%mod,(x.sec+y.sec)%mod); }
struct ma{
	int a[2][2];
	void clear(){ For(i,0,1) For(j,0,1) a[i][j]=0; }
	void init(){  For(i,0,1) For(j,0,1) a[i][j]=(i==j); }
	ma mul(ma x){
		ma res; res.clear();
		For(i,0,1) For(j,0,1) For(k,0,1) (res.a[i][j]+=a[i][k]*x.a[k][j])%=mod;
		return res;
	}
	pi don(pi x){//matrix mul lie
		return mkp(
			(a[0][0]*x.fir+a[0][1]*x.sec)%mod,
			(a[1][0]*x.fir+a[1][1]*x.sec)%mod
		);
	}
}f[V&lt;&lt;1|1],F,iF;
pi t[N&lt;&lt;2];//fir : the F_{now}*val, sec : the F_{now-1}*val
int lz[N&lt;&lt;2];//the power of matrix F(for reduce the constant)
struct qwq{
	int id,l,r;
	friend bool operator&lt;(qwq x,qwq y){
		if(b[x.l]!=b[y.l]) return x.l&lt;y.l;
		else return b[x.l]&amp;1 ? x.r&lt;y.r : x.r&gt;y.r;
	}
}Q[N];
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
#define mid ((l+r)&gt;&gt;1)
void build(int rt,int l,int r){
	t[rt]=mkp(0,0);
	if(l==r){
		lz[rt]=-2;//we extract F_{n+1}, and we want F_1 initial
		return ;
	}
	lz[rt]=0;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void pd(int rt){
	if(lz[rt]!=0){
		lz[ls]+=lz[rt];
		lz[rs]+=lz[rt];
		t[ls]=f[lz[rt]+V].don(t[ls]);
		t[rs]=f[lz[rt]+V].don(t[rs]);
		lz[rt]=0;
	}
}
void modi(int rt,int l,int r,int id,bool val){
	if(l==r){
		if(val) t[rt]=f[lz[rt]+V].don(mkp(so[l],so[l]));
		else t[rt]=mkp(0,0);
		return ;
	}
	pd(rt);
	if(id&lt;=mid) modi(ls,l,mid,id,val);
	else modi(rs,mid+1,r,id,val);
	t[rt]=t[ls]+t[rs];
}
void add(int rt,int l,int r,int x,int y,int val){
	if(x&lt;=l &amp;&amp; r&lt;=y){
		t[rt]=f[val+V].don(t[rt]);
		lz[rt]+=val;
		return ;
	}
	pd(rt);
	if(x&lt;=mid) add(ls,l,mid,x,y,val);
	if(y&gt;mid) add(rs,mid+1,r,x,y,val);
	t[rt]=t[ls]+t[rs];
}
void Add(int x){
	if(!cnt[x]) modi(1,1,lim,x,1),add(1,1,lim,x,lim,1);
	cnt[x]++;
}
void Del(int x){
	cnt[x]--;
	if(!cnt[x]) modi(1,1,lim,x,0),add(1,1,lim,x,lim,-1);
}
signed main(){
	n=read(),mod=read();
	F={{{1,1},{1,0}}},iF={{{0,1},{1,mod-1}}};
	f[V].init();
	For(i,V+1,2*V) f[i]=F.mul(f[i-1]);
	Rof(i,V-1,0) f[i]=iF.mul(f[i+1]);
	For(i,1,n) b[i]=(i-1)/gap+1;
	For(i,1,n) a[i]=so[i]=read();
	sort(so+1,so+1+n);
	lim=unique(so+1,so+1+n)-so-1;
	For(i,1,n) a[i]=lower_bound(so+1,so+1+lim,a[i])-so;
	For(i,1,lim) so[i]%=mod;
	q=read();
	For(i,1,q) Q[i]=(qwq){i,read(),read()};
	sort(Q+1,Q+1+q);
	build(1,1,lim);
	int L=1,R=0;
	For(i,1,q){
		while(R&lt;Q[i].r) Add(a[++R]);
		while(L&gt;Q[i].l) Add(a[--L]);
		while(R&gt;Q[i].r) Del(a[R--]);
		while(L&lt;Q[i].l) Del(a[L++]);
		ans[Q[i].id]=t[1].fir;
	}
	For(i,1,q) printf("%d\n",ans[i]);
return 0;}
```
&lt;/details&gt;

## HDU 7186.Jo loves counting

&gt; 给定 $M\le 10^{12}$，要你求
&gt; $$\frac{1}{M}\sum_{n=1}^{M}\frac{n}{\alpha(n)}$$
&gt; 的值 $\bmod 29\times 2^{57}+1$（素数）。其中 $\alpha(n)$ 为 $n$ 分解素因数后幂的乘积（e.g. $\alpha(144)=\alpha(2^4\times 3^2)=4\times 2=8$）。

注意到 $\alpha(n)$ 为积性函数，所以 $\frac{n}{\alpha(n)}$ 也为积性函数，简记为 $f(n)$。

[可能需要的链接](https://www.cnblogs.com/shaojia/p/15138057.html)

$p$ 为素数，由于 $f(p)=p$，我们拿来 $Id(n)=n$，有 $f(p)=Id(p)$。

基于此，我们可以构造一个积性函数 $h(n)$ 使得 $f(n)=\sum_{d|n}h(d)Id(\frac{n}{d})$。

由于 $f(p)=h(p)Id(1)+h(1)Id(p)$，得到 $h(p)=0$。

进一步的，由于 $h$ 积性，$h(x)&gt;0$ 只有可能 $x\text{ is Powerful Number}$（具体见上面的链接）。

设 $PN$ 为 $\text{Powerful Number}$ 集合。

同时 $[1,M]$ 中的 $PN$ 只有 $O(\sqrt M)$ 个（具体见上面的链接）。

我们再通过求出 $h(p^k)$ 求出所有的 $h(n)$：

对于 $k&gt;1$ 有
$$\begin{aligned}
\frac{p^k}{k}&amp;=f(p^k)
\\&amp;=\sum_{i=0}^k h(p^i)\cdot Id(p^{k-i})
\\&amp;=h(p^k)+\sum_{i=0}^{k-1} h(p^i)\cdot p^{k-i}
\\&amp;=h(p^k)+p\cdot \sum_{i=0}^{k-1} h(p^i)\cdot p^{k-i-1}
\\&amp;=h(p^k)+p\cdot f(p^{k-1})
\\&amp;=h(p^k)+\frac{p^k}{k-1}
\end{aligned}$$
得到
$$
h(p^k)=-\frac{p^k}{k(k-1)}
$$
我们可以暴力求得所有 $h(p^k)(p^k\in [1,M])$，然后暴力转移到所有 $PN$。

答案简化为

$$\begin{aligned}
\frac{1}{M}\sum_{n=1}^{M}\frac{n}{\alpha(n)}&amp;=\frac{1}{M}\sum_{n=1}^{M}f(n)
\\&amp;=\frac{1}{M}\sum_{n=1}^{M}\sum_{d|n} h(d)Id(\frac{n}{d})
\\&amp;=\frac{1}{M}\sum_{d=1}^{M}h(d)\sum_{n=1}^{\lfloor M/d\rfloor} Id(n)
\\&amp;=\frac{1}{M}\sum_{d=1}^{M}h(d)\frac{(\lfloor M/d\rfloor+1)\lfloor M/d\rfloor}{2}
\\&amp;=\frac{1}{M}\sum_{d\in PN}[d\le M]h(d)\frac{(\lfloor M/d\rfloor+1)\lfloor M/d\rfloor}{2}
\end{aligned}$$

因此，我们对每一个 $d\in PN$，$O(1)$ 地计算其
对应的 $h(d)$，则可以在 $O(\sqrt M)$ 的时间内通过本题。

## P4899 [IOI2018] werewolf 狼人

设边权为两点点权 $\max$，建 Kruskal（边权小优先）重构树。

再设边权为两点点权 $\min$，建 Kruskal（边权大优先）重构树。

将两棵树倍增预处理，接下来问题转化为：

&gt; 给定两颗叶子数均为 $n$ 的树，每棵树的叶子权值都构成 $n$ 元排列。
&gt; 
&gt; 每次询问分别在两棵树上选一个点，问两个点子树内是否有相同的权值。

接下来我们将两棵树的叶子按 dfs 序排列，然后对于第一棵树的每一个叶子存第二棵树与其权值相同的叶子编号，这样我们问题转化为：

&gt; 给定排列 $p_1,p_2,\dots,p_n$，每次询问 $(L,R,l,r)$，问 $p_l,\dots,p_r$ 中是否有权值 $\in[L,R]$ 的元素。

这样我们主席树维护即可。

$O(n\log n)$（$N,M,Q$ 视为同阶）

（本做法可强制在线）

## CF888G Xor-MST

&gt; 给你一个 $n$ 个节点的完全图，第 $i$ 个点的权值为 $a_i$，两点的之间边权为这两点权的异或值，求最小生成树。

提供一种类 Borvuka 算法。

我们先把点权的 01trie 建好。

对于 trie 中一个节点的两个儿子，他们分别的点集设为 $A,B$（不妨设均非空），我们证明 $A,B$ 点集之间只会连一条边，且一定是连边权最小的边，设此边为 $e$。

&lt;details&gt;
&lt;summary&gt;点击查看证明&lt;/summary&gt;

我们将 $A,B$ 分别内部用最小生成树连通，再加上 $e$ 即为生成树，而不存在 $[A,B]$ 间的边权 $&lt;e$ 的边权，所以没有可以替代的边，得证。
&lt;/details&gt;

因此我们只需要遍历 trie，每次合并两子树时用小的树里的点权去大的树里查询。

这样总复杂度 $O(30n\log n)$。

[Code](https://codeforces.com/contest/888/submission/166300830)

## qbxt

[Link](https://noip.ac/rs/show_problem/3835)

发现就是一个 K-Nim + 树形 DP 的问题。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ll long long
const ll mod=1e9+7;
const int N=1002,V=6561;//V=3^8
int id[N],tim=0,n,a[N],sz[N];
vector&lt;int&gt; e[N];
ll f[N][V];
int calc(int x,int y){//x ternary y binary 
	int res=0,p=1;
	For(i,0,7){
		res+=(x%3+(y&amp;1))%3*p;
		p*=3,x/=3;
		y&gt;&gt;=1;
	}
	return res;
}
void dfs(int rt,int fa){
	id[++tim]=rt,sz[rt]=1;
	for(int i:e[rt]) if(i!=fa) dfs(i,rt),sz[rt]+=sz[i];
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i];
	int x,y;
	For(i,1,n-1){
		cin&gt;&gt;x&gt;&gt;y;
		e[x].pb(y);
		e[y].pb(x);
	} 
	dfs(1,0);
	f[n+1][0]=1;
	Rof(i,n,1)
		For(j,0,V-1)
			(f[i][j]+=f[i+1][calc(j,a[id[i]])]+f[i+sz[id[i]]][j])%=mod;
	int ans=(mod+f[1][0]-1)%mod;
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## qbxt

[Link](https://noip.ac/rs/show_problem/3807)

若 $n=10^6,m=10^4$，我们可以用矩阵快速幂 + segtree 维护三种颜色的概率。

但是现在 $n,m$ 约束换了一下，所以我们需要更快的询问。

考察到**精度要求为 $10^{-2}$ 非常低**，而且每次 $0.01\le p\le 0.99$，所以**经尝试一个位置通过 $300$ 次操作必然会变成 $(0.33,0.33,0.33)$**。

我们通过 DSU 维护没有收敛的位置，这样做总体 $O(300n+m)$。

## HDU 7155.Bowcraft

&gt; 你现在等级为 $0$，想要到等级 $K\le 1000$，通过购买和使用增强书。
&gt;
&gt; $2\le A,B\le 100$ 是题目给定的常数。每次买书的时候店员都会在 $[0,A-1]$ 和 $[0,B-1]$ 分别等概率随机一个整数 $a,b$，然后把一本书给你。这本书使用时有 $a/A$ 的概率将你的等级 $+1$，否则，有 $b/B$ 的概率将你的等级置为 $0$。
&gt;
&gt; 因为等级可能置 $0$，所以你买了一本书知道 $a,b$ 的值后可以选择扔掉。
&gt;
&gt; 问你在最优策略下买书的期望数量。

设 $dp(i)$ 表示从 $0$ 升到 $i$ 级的期望买书数量。

假设现在买了一本书 $(a,b)$，记 $\alpha=a/A,\beta=b/B$。

若使用这本书，则从 $0$ 到 $i+1$ 的期望为
$$\begin{aligned}
X=&amp;dp(i)+1
\\&amp;+(1-\alpha)(1-\beta)\cdot(dp(i+1)-dp(i))
\\&amp;+(1-\alpha)\beta\cdot dp(i+1)
\end{aligned}$$

若不使用，则从 $0$ 到 $i+1$ 的期望为
$$
Y=dp(i+1)+1
$$
（很奇怪的柿子不是吗）

整合一下
$$
dp(i+1)=\frac{1}{AB}\sum_{a,b}\min\{X,Y\}
$$

对于当前的等级 $i$ 和一本书 $(a,b)$，如果要使用这本书，那么升到 $i+1$ 级，不使用的期望 $\ge$ 使用的期望（$Y\ge X$）。

化简得到
$$
dp(i+1)\ge dp(i)\cdot \frac{\alpha+\beta-\alpha\beta}{\alpha}
$$

从这个式子可以看出，一本书的 $\frac{\alpha+\beta-\alpha\beta}{\alpha}$ 越小越容易被使用。即 $\frac{\beta(1-\alpha)}{\alpha}$ 越小越好。

将所有书按 $\frac{\beta(1-\alpha)}{\alpha}$ 排序，枚举所有的 $k\in[0,AB]$，代表我们只取前 $k$ 小的 $(a,b)$，设前 $k$ 小的集合为 $S$，则（省略了部分推导）
$$
dp(i+1)=\frac{AB+dp(i)\sum_{(a,b)\in S}\alpha+\beta-\alpha\beta}{k-\sum_{(a,b)\in S}1-\alpha}
$$
↑ 官方题解这柿子写错了 OvO。

枚举 $k$，就可以 $O(AB)$ 从 $dp(i)$ 转移到 $dp(i+1)$，所以总时间 $O(ABK)$。

## HDU 7154.Slayers Come

前面太冗长了，只讲后面我想讲的。

&gt; $n\le 10^5$ 个位置排成一排下标 $1\sim n$，$m\le 10^5$ 个区间。
&gt;
&gt; 问 $2^m$ 种方案中有几种选区间的方案使得每一个位置都有被覆盖过。

非常经典。

设 $f_i(i\in[0,n])$ 表示目前前缀 $i$ 个位置均已被覆盖过，第 $i+1$ 个位置没有覆盖过的方案数。

初始化 $f_i=[i=0]$。

将区间按右端点升序，每次对于区间 $[l,r]$ 操作：

* $f_{0\dots l-1}$ 区间 $\times 2$，表示 $[l,r]$ 不对这些极长前缀长度产生影响。

* $f_{l\dots r-1}$ 区间查询和，并把加给 $f_r$，表示这一段接上了。

* $f_r$ 单点 $\times 2$，这就是区间按右端点排序的原因。

最后答案为 $f_n$。

## HDU 7157.Keyboard Warrior

&gt; 给定字符串 $S(n\le 2\times 10^5)$，你现在有一个空的写字板，按顺序你进行 $m\le 2\times 10^5$ 次操作，每次 $c,k$ 表示你按键盘 $c$ 字符按键按了 $0\le k\le 10^9$，注意当 $c=\text{'-'}$ 的时候代表按 Backspace。
&gt;
&gt; 自始至终光标在文本的末尾，删空后按 Backspace 无效。
&gt; 
&gt; 求问是否存在一个时刻，使得 $S$ 是写字板上的字符串的子串。

将字符串改写成多个 `pair&lt;char,int&gt;` 的形式，表示这么多的相同字符。

第一个 $S$ 是写字板的子串的时刻必然满足 $S$ 是她的后缀。

所以我们 hash 每一个 pair，再把这些 hash 值进行序列 hash，每次加入时判断即可。

当然每次加入一堆相同的字符时我们从倒数第二个 pair 开始往左判 hash，然后再判两头。

细节有些小问题，看代码。

[code](http://acm.hdu.edu.cn/viewcode.php?rid=37726126)

## HDU 7150.Static Query on Tree

&gt; 给定一棵有根树 $n\le 2\times 10^5$，$q\le 2\times 10^5$ 次询问，每次给定点集（可能相同或有交或为空） $A,B,C$，请计数树上满足条件的点 $x$ 的个数：
&gt;
&gt; &gt; 存在 $a\in A,b\in B,c\in C$，使得 $c$ 是 $x$ 的祖先，且 $x$ 是 $a,b$ 的公共祖先。
&gt;
&gt; 所有询问的 $|A|+|B|+|C|$ 之和 $\le 2\times 10^5$。

我们对于每一个 $a\in A$，找到她最高的在 $C$ 里的祖先 $c$（没有则退出），然后将 $path(a,c)$ 的点全部染红。同理 $B$ 集合的操作是染蓝。

我们最后的答案是两种颜色都染过的点数。

我们树剖，建立两棵形状一模一样的线段树，第一棵的节点存区间最靠左的 $1$ 出现的位置，第二棵每个叶子的值域 $0\sim 3$，节点存区间每种值出现的次数。

每一个询问，我们先在第一棵线段树上 $C$ 集合对应的 dfn 位置 $+1$。

对于 $A$ 集合，通过第一个线段树找到最高（浅）的 $C$ 集合元素，然后线段树区间 $\text{OR}$ 上 $1$。

$B$ 同理，不过是区间 $\text{OR}\ 2$。

最后答案就是第二棵线段树上值为 $3$ 的个数。

时间双 $\log$。

[code](http://acm.hdu.edu.cn/viewcode.php?rid=37726052)

## P6476 [NOI Online #2 提高组] 涂色游戏 &amp; CF1260C Infinite Fence

&gt; 给定无限长的数轴，其中 $r$ 整数倍的点染红色，$b$ 整数倍的点染蓝色，$\text{lcm}(r,b)$ 整数倍的点随你染其中一个。问你是否有可能，删掉所有未染色的点后，不存在连续的 $k$ 个颜色相同的点。
&gt;
&gt; $1\le r,b,k\le 10^9$

我们先特判掉 $k=1$ 的平凡情况，然后约定 $r\le b$。

由于 $r\le b$，所以我们红蓝均可的点我们选择蓝色（因为蓝色间隔大）。

由于 $r,b$ 同时放缩不影响答案，所以我们将 $r,b$ 同时除以 $\gcd(r,b)$，这样 $r\perp b$。

然后就是大名鼎鼎的裴蜀定理：存在 $x,y$ 使得 $rx-by=1$。

也就是说，在我们这个数轴上，存在蓝色后面紧接的那个位置染红色。

这样我们在下一个蓝色之前会有
$$
P=\left\lceil\frac{b-1}{r}\right\rceil
$$
个红色的点。

所以我们只要 $P&lt;k$ 即 YES，否则为 NO。
$$
P&lt;k\iff (k-1)r+1\ge b
$$
## HDU 7144.Treasure

[原题链接](http://acm.hdu.edu.cn/showproblem.php?pid=7144)

&gt; $n(\le 10^5)$ 点 $m(\le 2\times10^5)$ 边的无向连通带边权（$w\le 10^5$，其实无所谓）图。
&gt;
&gt; 每个点上都有一个宝物，宝物有两个属性 $c_i,v_i$，表示种类和价值。
&gt;
&gt; 注意**一个人每种种类的宝物最多只能拿一个（也就是拿的 $c_i$ 各不相同）**。
&gt;
&gt; $q(\le 10^5)$ 次操作 $op,x(1\sim n),y(1\sim 10^5)$，每次
&gt;
&gt; * $op=0$，将 $x$ 位置上的宝物的 $v_x$ **增加** $y$（**$y$ 为正整数**）。
&gt;
&gt; * $op=1$，询问假设在 $x$ 点上出现了一个人，他只能走边权 $\le y$ 的边，他能拿宝物的**最大价值和**。
&gt;
&gt; 还有关键的一点：**每种 $c_i$ 最多对应 $10$ 个宝物。**

先把 Kruskal 重构树建好。

对于每一个 $op=0$，我们先找到 $c_i$ 与她相同的至多 $9$ 个位置，分别与她作 LCA，接下来就是 $10$ 条链（两端为祖孙关系）的链上加。

所以问题转化为：

* 树上某链全加 $val$。

* 查询单点的值。

我这里本来直接树剖做了，但是会多带 $\log$。

[$O(10n\log^2 n)$ 写法，看起来长，写起来烦，调起来吐，但理解起来好](http://acm.hdu.edu.cn/viewcode.php?rid=37726900)

其实我们可以树上差分，然后转化成：

* 树上某点权值加 $val$。

* 查询子树权值和。

dfs 序平摊开，用 Fenwick 维护即可。

时间 $O(10n\log n)$。

写了没调出来，咕咕咕（永久）。

## P4003 无限之环 &amp; Loj#2321. 「清华集训 2017」无限之环

[游戏游玩](https://poki.com/en/g/infinity-loop)

&gt; 你面前有一个无限之环的游戏局面（大小 $n\cdot m\le 2000$），问你最少需要几次旋转（旋转指正负 $90^{\circ}$，**直线型的不让旋转**）才能通关。

废话不多说，**费用流**。

每个点我们拆成五个：**上下左右中**。

我们将局面黑白染色，白的为出点，黑的为入点。

我们这样连边：

相邻的两点之间出点连向入点（流量为 $1$）：

![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719221850961-379463377.png)

出点的“中”连向对应的方向，入点反过来。（流量为 $1$）

对于一个完成状态

![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719222022570-237779259.png)

![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719222133611-55026331.png)

我们发现最大流 $=$ 每个位置的度数之和 $/2$。

接下来我们进行旋转操作：

* 对于 $+$、$-$、空点，没法旋转，不用再建边。

* 对于 $Q$ 形点，我们这样连边（数字为费用，流量均为 $1$）
![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719222919392-177338526.png)

* 对于 $L$ 点（这个好好想想）
![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719223038353-145406860.png)

* 对于 丁 点
![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220719223338476-924916214.png)

然后跑费用流。

若最大流 $\times 2\ne$ 点的度数和，则输出 $-1$。

否则，最小费用即为答案。

**回顾：** 我们发现如果**直线型允许旋转**我们**无法像上述这样建图**。

[luogu record](https://www.luogu.com.cn/record/80019744)

[Loj](https://loj.ac/s/1518713)

## abc260_e At Least One

&gt; 在一个长度 $m(\le 2\times 10^5)$ 的序列中，问你满足以下条件的长度为 $k$ 区间个数 $f(k)$：给定 $n$ 个条件 $1\le A_i\le B_i\le m$，表示你的区间必须覆盖到 $A_i,B_i$ 下标中的一个。
&gt;
&gt; 输出 $f(1),\dots,f(m)$。

我们固定右端点，发现可行的左端点为一段序列的前缀。

我们预先将 $A_i$ 通过 vector 挂在 $B_i$ 位置上。

我们将右端点从小到大枚举，用 multiset 维护限制的位置，若右端点碰到某个 $B_i$ 则将 multiset 中的 $A_i$ 改为 $B_i$，设此时 multiset 中的最小值为 $L$，当前的右端点为 $R$，则这里对 $f(R-L+1),\dots,f(R)$ 都有 $1$ 的贡献，我们差分做，最后输出前缀和即可。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define N 200010
int n,m,a[N],b[N],ans[N];
vector&lt;int&gt; e[N];
multiset&lt;int&gt; s;
inline void add(int x,int y){ ans[x]++,ans[y+1]--; }
int main(){
	ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	int z=0,x,y;
	For(i,1,n){
		cin&gt;&gt;x&gt;&gt;y;
		e[y].push_back(x);
		s.insert(x);
		if(x&gt;z) z=x;
	}
	For(i,1,z) for(int j:e[i]) s.erase(s.find(j)),s.insert(i);
	add(z-*s.begin()+1,z);
	For(i,z+1,m){
		for(int j:e[i]) s.erase(s.find(j)),s.insert(i);
		add(i-*s.begin()+1,i);
	}
	For(i,1,m) ans[i]+=ans[i-1];
	For(i,1,m) cout&lt;&lt;ans[i]&lt;&lt;" "; cout&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## CF590E Birthday

&gt; 给定 $n\le 750$ 个字符串（字符集 $\{\text{a},\text{b}\}$），问最多能保留多少个字符串，使得不存在某一个串是另一个串的子串，并构造一组方案。
&gt;
&gt; 字符串长度之和 $S\le 10^7$

首先，我们通过建 AC 自动机求出字符串两两之间是否有子串关系，这一步 $O(S+n^2)$，再加上 $O(n^3)$ 的传递闭包。

然后就转化成了 DAG 的最长反链问题了。我们 $O(n^{2.5})$ Dinic 求出最小可重点链覆盖（因为原图已经传递闭包，所以可不可重一样）。然后我们从每条链底选点，向上爬直到全部可行，即为构造。

总时间 $O(S+n^3)$。

[record](https://www.luogu.com.cn/record/78861936)

~~写 + 调了两天。~~

## P3338 [ZJOI2014]力

发现这个柿子可以分成两部分计算，我们以第一部分为例。
$$
E_i=\sum_{j=1}^{i-1}\frac{q_j}{(i-j)^2}
$$
我们变一下形式
$$
E_i=\sum_{j=0}^{i}q_jh_{i-j}
\\
q_0=h_0=0
\\
h_i=\frac{1}{i^2}
$$

发现就是一个多项式乘法。

然后就 FFT $O(n\log n)$ 解决。

## arc140_e

只能说是数据范围的迷惑性。

&gt; 让你构造一个 $500\times 500$ 的矩阵，其中整数的值域 $[1,25]$，满足一个条件：
&gt;
&gt; 对于任意的 $1\le x&lt;x'\le 500,1\le y&lt;y'\le 500$，有 $a_{x,y},a_{x',y},a_{x,y'},a_{x',y'}$ **不全相等**。

其实这道题用到的不是也不能用 $25$，得用 $\le 25$ 的最大素数 $23$。

我们设 $23$ 个拉丁方 $M^{(0)}$ 到 $M^{(22)}$（$+$ 为模 $23$ 意义下）
$$
M^{(i)}=
\begin{bmatrix}
0&amp;1&amp;2&amp;\cdots&amp;22
\\
1&amp;2&amp;3&amp;\cdots&amp;0
\\
2&amp;3&amp;4&amp;\cdots&amp;1
\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots
\\
22&amp;0&amp;1&amp;\cdots&amp;21
\end{bmatrix}
+
i\cdot\begin{bmatrix}
1&amp;1&amp;\cdots&amp;1
\\
1&amp;1&amp;\cdots&amp;1
\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots
\\
1&amp;1&amp;\cdots&amp;1
\end{bmatrix}
$$
然后我们就得到了一个 $529\times 529$ 的答案，其中任意截取 $500\times 500$ 都可作为本题的答案
$$
A=
\begin{bmatrix}
M^{(0)}&amp;M^{(0)}&amp;M^{(0)}&amp;\cdots&amp;M^{(0)}
\\
M^{(0)}&amp;M^{(1)}&amp;M^{(2)}&amp;\cdots&amp;M^{(22)}
\\
M^{(0)}&amp;M^{(2)}&amp;M^{(4)}&amp;\cdots&amp;M^{(44)}
\\
\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots
\\
M^{(0)}&amp;M^{(22)}&amp;M^{(44)}&amp;\cdots&amp;M^{(484)}
\end{bmatrix}
$$
其中 $M$ 的顶标为两坐标乘积。

```cpp
int n,m;
signed main(){
	cin&gt;&gt;n&gt;&gt;m;
	For(i,1,n){
		For(j,1,m){
			cout&lt;&lt;((i/23)*(j/23)+i+j)%23+1&lt;&lt;" ";
		}
		cout&lt;&lt;endl;
	} 
return 0;}
```

接下来证明为啥是对的。

简单来说，就是以素数 $23$ 为模数任何 $[1,22]$ 均有逆元。

所以对于 $x\ne y(\in[1,22])$，有
$$
kx\not\equiv ky\quad(\forall k\in[1,22])
$$

~~好我就讲这么多。~~

## P3600 随机数生成器

~~居然是黑题~~

&gt; 随机生成值域为 $[1,k]$ 的整数序列 $a_1,\dots,a_n$，然后给出 $(l_1,r_1),(l_2,r_2),\dots,(l_q,r_q)$，求
&gt; $$
&gt; S=\max_{i=1}^q\min_{j=l_i}^{r_i}a_j
&gt; $$
&gt; 的期望对 $666623333$（素数）取模的结果。

我们先将**大套小的「大」区间**全部删去，因为她的最小值一定不大于「小」区间，所以无意义。

这样我们的区间没有包含关系了，也就是说**将区间按左 / 右端点排序的结果相同**。

**算贡献**：我们目标是分别求 $S$ 取**不大于** $1,2,\dots,k$ 的概率，设为 $p_1,p_2,\dots,p_k$，则答案为（设 $p_0=0$）
$$
\sum_{i=1}^ki(p_i-p_{i-1})
$$
而
$$
p_i=\frac{\sum_{x=1}^n i^x(k-i)^{n-x}cnt_x}{k^n}
$$
其中 $cnt_x$ 表示这 $n$ 个数中选出 $x$ 个使得每个区间 $(l,r)$ 中至少有一个元素被取到（设为 A 条件）。这个式子相当于 $n$ 个里钦定 $x$ 个是 $\le i$ 的，其他 $&gt;i$，求方案数后**古典概型**除以 $k^n$ 总数。

于是问题只要求出 $cnt_1,cnt_2,\dots,cnt_n$。

我们有 simple 的 **DP**：

设 $f_{i,j}$ 表示数组中前 $i$ 个位置取了 $j$ 个位置，其中第 $i$ 个位置必须取，已经让左端点 $\le i$ 的区间全部满足 A 条件的方案数。

$L_i$ 表示**右端点 $&lt;i$ 的区间中左端点的最大值**。

$R$ 表示**全体区间中左端点的最大值**。
$$
f_{i,j}=\sum_{p=L_i}^{i-1}f_{p,j-1}
\\
cnt_i=\sum_{p=R}^n f_{p,i}
$$
最后将前式子的 $O(n^3)$ DP **前缀和优化**即可（easy）。

时间 $O(\dots+n^2)$。

## P3978 [TJOI2015]概率论

这种题一般打表。

首先，设 $f_n$ 为 $n$ 个节点的不同二叉树个数，$g_n$ 为这 $f_n$ 个二叉树的叶子节点个数总和。

答案就是 $\dfrac{g_n}{f_n}$。 

$$f_n=\sum_{i=0}^{n-1}f_if_{n-1-i},f_0=1$$

不难看出（或打表）为 catalan 数，即：

$$f_n=\frac{\binom{2n}{n}}{n+1}$$

$g_n$ 的求法就更加玄学了，用到了双射（或者说图论的握手定理）：

**引理 A：**

&gt; 任意的二分图，设两部为 $S,T$，则
&gt; $$\sum_{x\in S}\text{deg}(x)=\sum_{x\in T}\text{deg}(x)$$

**引理 B：**

&gt; 对于任意一棵 $n$ 个节点的二叉树，有 $n+1$ 个位置可以增挂叶子。

* 对于 $f_n$ 棵树中的每一棵，设当前这棵有 $k$ 个叶子，我们分别删去 
$1$ 个叶子，产生 $k$ 个 $n-1$ 个节点的二叉树。

* 对于任意一棵 $n-1$ 个节点的二叉树，我们分别在 $n$ 个可挂叶子的地方挂，产生 $n$ 个 $n$ 个节点的二叉树。

显然这是一种双射，得到 $g_n=nf_{n-1}$，所以答案为：
$$
\frac{g_n}{f_n}=\frac{nf_{n-1}}{f_n}=\frac{\binom{2n-2}{n-1}}{\binom{2n}{n}/(n+1)}=\frac{n(n+1)}{2(2n-1)}
$$

## P2949 [USACO09OPEN]Work Scheduling G

带反悔的贪心。

首先思路就是先按截止时间排序任务，然后如果一个工作有时间去做，就先做了它，然后把它的价值压入一个小根堆。

当我们找到一个没法做却价值比当前堆顶高的工作时，我们就放弃那个最小的工作，用做它的时间去做这个价值更高的工作。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
struct node{
	int tim,val;
	friend bool operator&lt;(node x,node y){return x.val&gt;y.val;}
}a[100010];
bool cmp(node x,node y){return x.tim&lt;y.tim;}
priority_queue&lt;node&gt; q;
int n,ans=0;
signed main(){IOS;
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i].tim&gt;&gt;a[i].val;
	sort(a+1,a+1+n,cmp);
	For(i,1,n){
		if(a[i].tim&lt;=q.size()){
			if(!q.empty() &amp;&amp; q.top().val&lt;a[i].val){
				ans-=q.top().val;
				q.pop();
				ans+=a[i].val;
				q.push(a[i]); 
			} 
		}else{
			ans+=a[i].val;
			q.push(a[i]);
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
```
&lt;/details&gt;

## agc057_b

因为序列中的位置不影响结果，我们将原序列升序排序 $a_1\le a_2\le \dots\le a_n$。

记最优解中每个位置被操作的次数为 $o_1,o_2,\dots,o_n$。

设 $d=min\{o\},p_i=o_i-d$。

若操作次数序列为 $\{p\}$ 的极差最小值为 $Y$，则 $\{o\}$ 的极差最小值为：

* 当 $Y&lt;X$，为 $0$，因为每次「全局操作一次」都可以让极差减小，直至 $0$。

* 当 $Y\ge X$，为 $Y$，因为最小值和最大值之间的差不会因为同时操作而减小。

所以我们只需求出 $Y$，也就是存在「没有操作的位置」的最小极差。

我们证明 $p_n=0$。反证法：若 $p_n\ne 0$，设最小值的位置为 $x$（必然 $x&lt;n$ 因为还存在 $p_i=0$ 的位置，值比 $a_n$ 小），将 $p_n$ 改为 $0$，我们得到了一个极差更小（或相等）（$a_?-a_x\le a_n-a_x$）的方案，矛盾，原命题得证。

所以，$O(n\log n)$ 求出每个 $a_i$ 能变换到的值中 $a_n$ 的 lower/upper_bound，设为 $L_i,R_i$。

接下来问题就转化成每个 $i$ 选 $L$ 或 $R$，再加入 $a_n$，极差最小是多少。

可以用简单的贪心实现。

## P5610 [Ynoi2013] 大学

一个长为 $n$ 的非负整数序列 $a$，支持以下两个操作：

`1 l r x`：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。

`2 l r`：查询区间 $[l,r]$ 的和。

强制在线，$1\le n,q\le 10^5,0\le a_i\le 5\times 10^5$。

发现值域不大。若我们把每个数的每个因子存起来，最多也就 $200n$ 个（5e5 内因子个数最多 $200$）。

所以我们开 5e5 个数组，第 $i$ 个数组里存的是初始序列是 $i$ 倍数的数的位置（下标），数组内排好序。

对于操作 1，我们在数组 $x$ 中二分找到 $[l,r]$ 内的值的段。然后暴力遍历，若一个位置现在已经不是 $x$ 的倍数了，那我们跳过，并用并查集标记，表示下次遍历直接跳过这个，否则暴力修改。

这部分是均摊复杂度 $O(q+200n\log n)$（反阿克曼算常数）。

对于操作 2，我们在操作 1 的时候用树状数组维护序列，那区间和就迎刃而解。

代码就不放了，因卡常而面目全非。

## P1776 宝物筛选

**​​单调队列优化多重背包**。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define N 101
#define V 40010 

const int inf=1e9;
int n,m,f[V],g[V];
deque&lt;int&gt; q;
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;m;
	f[0]=0;
	For(i,1,m) f[i]=-inf;
	int val,w,cnt;
	For(i,1,n){
		cin&gt;&gt;val&gt;&gt;w&gt;&gt;cnt;
		For(j,0,m) g[j]=f[j];
		For(j,0,w-1){
			q.clear();
			for(int k=j;k&lt;=m;k+=w){
				while(!q.empty() &amp;&amp; q.front()+cnt*w&lt;k) q.pop_front(); 
				if(!q.empty()) ckmx(g[k],f[q.front()]+(k-q.front())/w*val);
				while(!q.empty() &amp;&amp; f[q.back()]+(k-q.back())/w*val&lt;f[k]) q.pop_back();
				q.push_back(k);
			}
		}
		For(j,0,m) f[j]=g[j];
	}
	int ans=0;
	For(i,0,m) ckmx(ans,f[i]);
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## CF1662D Evolution of Weasels

[wsyear's sol](https://www.luogu.com.cn/blog/wsyear/solution-cf1662d)

## abc249_e RLE

设 $f_{i,j}$ 表示原串长度为 $i$，压缩后长度为 $j$ 的方案数。

由于 压缩的位数 和 连续字母长度的十进制位数有关，所以我们设
$$
g(x)=\lfloor\log_{10}x\rfloor+2
$$
为 $x$ 个相同的字符会压缩成的长度。

显然 $f_{i,g(i)}=26$。

有递推式
$$
f_{i+k,j+g(k)}+\!=25f_{i,j}
$$
答案为
$$
\sum_{i=1}^{n-1}f_{n,i}
$$
但是这样是 $O(n^3)$ 的，过不了，我们考虑优化。

对 $j$ 相同的 $f_{i,j}$ 维护树状数组，由于 $g(k)$ 只有 $4$ 种取值，求完一个 $f_{i,j}$ 后四次区间加即可。

时间 $O(n^2\log_{10} n)$。

代码实现 $f_{i,j}$ 中的两维交换一下。

[Code](https://atcoder.jp/contests/abc249/submissions/31265948)

## abc245_g Foreign Friends

首先多个 Idol 多源最短路 Dij 可以解决。然后有「不同国家的 Idol」要求，所以每个点存最近 Idol 的国家和次近的，这样总有一个可以异国。

可以证明这样的 Dij 还是 $O(m+n\log n)$ 的。

[Code](https://atcoder.jp/contests/abc245/submissions/30478626)

## CF1473F Strange Set

**最大权闭合子图**模板题。

[Code](https://codeforces.com/contest/1473/submission/154450406)

## abc246_g Game on Tree 3

题意：一棵树 $n\le 2\times 10^5$ 点有点权 $A_i$，有一个棋子在根节点 $1$。Alice 先手，可以将任意一个 $A_i:=0$，Bob 后手，可以将棋子移向当前节点的任意一个儿子。Bob 可以在任何时候停止游戏，这时 Bob 的得分为当前棋子所在的 $A_i$，而 Alice 想让 Bob 得分最小。两人聪明绝顶，求最终 Bob 的分数。

**二分答案**，这样问题就转化为黑白棋问题了：

每个节点有一个颜色黑/白，Alice 操作是让一个黑 $\to$ 白，问她是否能不让 Bob 进入黑节点。

这个可以用简单的 DP 解决。

具体地，设 $f_i$ 表示当前棋子在 $i$ 节点（下一步该 Alice 了），Alice 最少在之前操作几次此子树内的点，才会让 Bob 不进黑。

$$f_i=\max\left\{0,\left(\sum\limits_{j\in son_i}f_j\right)-1\right\}+c_i$$

其中 $c_i$ 表示 $i$ 节点是（$1$）否（$0$）是黑的。

时间 $O(n\log V)$。

[Code](https://atcoder.jp/contests/abc246/submissions/31133993)

## abc248_g GCD cost on the tree

给一棵树（$n\le 10^5$），点有点权 $A_i\le 10^5$，定义 $C(x,y)$ 为 $x,y$ 两点**树上距离乘上路径上（包括 $x,y$）点权 $\gcd$**，求 $\sum\limits_{i&lt;j}C(i,j)\ \bmod 998244353$。

先 $O(V\ln V)$ 预处理出 $1\to 10^5$ 的因数。设 $G_i$ 为点集 $\{x\ |\ A_x\ \bmod i=0\}$ 的诱导子图（森林）。求出 $B_i$ 表示 $G_i$ 每棵树上 $\sum\limits_{i&lt;j\ i,j\in Tree}cnt(i,j)$ 之和。其中 $cnt(x,y)$ 表示 $x,y$ 在树上路径经过的点数，即 $dis(x,y)+1$。

由容斥得 $C_i=B_i-\sum\limits_{i\ |\ j,j&gt;i}C_j$，表示那些 $\gcd=i$ 的路径经过的点数总和。

答案即为 $\sum i\times C_i$

时间 $O(V\ln V+n\sqrt{V})$，因为每条树边 $(x,y)$ 会在处理 $G_d(d\ |\ A_x\lor d\ |\ A_y)$ 时被遍历，最多是 $O(\sqrt{V})$ 级别的。

[Code](https://atcoder.jp/contests/abc248/submissions/31120957)

## P5304 [GXOI/GZOI2019]旅行者

题目：一个图 $n$ 点 $m$ 条边，里面有 $k$ 个特殊点，问这 $k$ 个点之间两两最短路的最小值是多少？$n \leq 10^5, m \leq 5 * 10 ^5$。

用到的性质：两个数不相同当且仅当两个二进制表示至少有一位不同。

我们枚举这个不同的二进制位，即将 $k$ 个点的点集划分成两部分，跑多源最短路即可（Dijkstra）。

## P5278 算术天才⑨与等差数列 / P3792 由乃与大母神原型和偶像崇拜

单点修改，区间 $l,r,k$ 表示询问 $a[l,r]$ 是否为公差为 $k$ 的等差序列。

这是乱搞但是有用的 Hash 做法：

维护区间 min、max、sum、sos（这个要 ull），判断是否与应得的等差序列一一吻合即可。

## P3980 [NOI2008] 志愿者招募

**MCMF** 好题。

将每一天拆为两个点。以下 $(w,c)$ 表示一条流量为 $w$，费用为 $c$ 的边。

* 每天的上午向下午连一条 $(\inf-a_i,0)$。

* 每天下午向第二天上午连一条 $(\inf,0)$。

* 对于花费为 $C$ 的志愿者，从开始工作的上午向结束工作的下午连一条 $(\inf,C)$。

$\inf$ 开到流量全非负即可。

从第一天上午到最后一天下午跑 MCMF 即可。

感性正确性：最终 MF 一定是 $\inf$，先将天与天之间的边流满，再用志愿者将不足的补上，每一天拆点的原因是防止志愿者之间直接连通~~短路~~。

## AT1219 歴史の研究

其实这才应该是**回滚莫队**模板。

## arc137_d Prefix XORs

发现当且仅当 $\binom{(N-i)+(k-1)}{k-1}$ 为奇数时 $a_i$ 才对第 $k$ 次有 xor 的贡献。而上述二项式为奇数的充要条件为 $N-i$ 和 $k-1$ 的 $\&amp;$（二进制与）为 $0$。

设 $S$ 为 $\ge \max(n,m)$ 的最小 $2$ 的次幂，也就是说 $S-1-(N-i)$ 的二进制要包含 $k-1$ 才会在第 $k$ 次对答案有一个 $a_i$ xor 的贡献，类似二进制高维前缀和的处理。

## arc137_c Distinct Numbers

如果 $a_{n-1}+1&lt;a_n$，我们断言这是必胜局面，因为：

* 如果存在一个 $&lt;a_{n-1}$ 的空位置使得先手将 $a_n$ 移到该位置后是必败局面，那当前就是必胜局面。

* 否则，不存在这样的位置，即将 $a_n$ 移到任何 $&lt;a_{n-1}$ 的空位置均产生必胜局面，我们将 $a_n$ 移动到 $a_{n-1}+1$，这样对手不管怎样都给我们留了必胜局面，即对手是必败局面，当前就是必胜局面。

所以，如果 $a_{n-1}+1=a_n$，那这个等式在游戏过程中一直成立，因为取 $&lt;$ 时就有一方必胜了，在这之前另一方必然会规避掉。所以判断 $&lt;a_n$ 的空位置个数的奇偶即可。

## abc240_g Teleporting Takahashi

设 $a=|x|,b=|y|,c=|z|,s=\frac{n-a-b-c}{2}$，若 $s&lt;0$ 或 $2\nmid s$ 则 $ans=0$，否则：

$$\begin{aligned}
ans&amp;=\sum_{i=0}^s\sum_{j=0}^{s-i}\binom{n}{a+i\quad i\quad b+j\quad j\quad c+(s-i-j)\quad (s-i-j)}
\\&amp;=\sum_{i=0}^s\binom{n}{a+i\quad i\quad n-a-2i}\sum_{j=0}^{s-i}\binom{n-a-2i}{b+j\quad j\quad c+(s-i-j)\quad (s-i-j)}
\\&amp;=\sum_{i=0}^s\binom{n}{a+i\quad i\quad n-a-2i}\sum_{j=0}^{s-i}\binom{n-a-2i}{s-i}\binom{s-i}{j}\binom{b+c+s-i}{b+j}
\\&amp;=\sum_{i=0}^s\binom{n}{a+i\quad i\quad n-a-2i}\binom{n-a-2i}{s-i}\sum_{j=0}^{s-i}\binom{s-i}{s-i-j}\binom{b+c+s-i}{b+j}
\\&amp;=\sum_{i=0}^s\binom{n}{a+i\quad i\quad n-a-2i}\binom{n-a-2i}{s-i}\binom{b+c+2(s-i)}{b+s-i}
\\&amp;\text{接下来是一些没必要但让柿子好看的步骤}
\\&amp;=\sum_{i=0}^s\binom{n}{a+i\quad i\quad n-a-s-i\quad s-i}\binom{b+c+2(s-i)}{b+s-i}
\\&amp;=\sum_{i=0}^s\binom{n}{s}\binom{s}{i}\binom{n-s}{a+i}\binom{b+c+2(s-i)}{b+s-i}
\\&amp;=\binom{n}{s}\sum_{i=0}^s\binom{s}{i}\binom{n-s}{a+s-i}\binom{b+c+2i}{b+i}
\end{aligned}$$

## P1080 [NOIP2012 提高组] 国王游戏

结论：将大臣按照 $a\times b$ 升序排序求答案（要高精度）即可。

证明（排序贪心证明模板）：如果有一个大臣序列 $p'$ 比按照 $a\times b$ 排序的 $p$ 要优。考虑 $p'$ 冒泡排序至 $p$ 的过程，对于一次邻项逆序对，下一段证明答案不劣，通过连不等式得 $p$ 不比 $p'$ 劣，而 $p'$ 比 $p$ 优，矛盾，得 $p$ 取到最优解。

若 $a_i\times b_i&gt;a_{i+1}\times b_{i+1}$，则 $\max\{\dfrac{1}{b_i},\dfrac{a_i}{b_{i+1}}\}&gt;\max\{\dfrac{1}{b_{i+1}},\dfrac{a_{i+1}}{b_i}\}$ 也就是说 $i,i+1$ 交换不会让获得奖赏更多的大臣出现，即不劣。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15893202.html</id>
    <title type="text">重修 杜教筛-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-21T07:05:00Z</published>
    <updated>2022-06-21T07:05:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15893202.html" />
    <content type="text">## 看之前要知道啥？

[狄利克雷卷积重要公式及定义](https://www.cnblogs.com/zhangshaojia/p/15138057.html)

## 干蛤的？

在 $O(n^{2/3})$ 内求积性函数 $f$ 的前缀和 $F(n)=\sum\limits_{i=1}^nf(i)$。

## 杜教筛の正确用法

我的 QQ 号（放在主页上）：
$$
\sum_{i=1}^{\text{QQ}}\varphi(i)=1168588503224828144
$$

由于 QQ 号位数不超过 $11$ 位（据说在增加），那我们二分即可 $O(10^{22/3}\log 10^{11})$ 内求出 QQ 号：

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define db long double
#define ll long long
#define N 10000000
db f[N+1];
bool vis[N+1];
vector&lt;int&gt; p;
void init(){
	f[1]=1;
	For(i,2,N){
		if(!vis[i]){
			f[i]=i-1;
			p.pb(i);
		} 
		for(int j:p){
			if(i*j&gt;N) break;
			vis[i*j]=1;
			if(i%j==0){
				f[i*j]=f[i]*j;
				break;
			}else{
				f[i*j]=f[i]*(j-1);
			}
		}
		f[i]+=f[i-1];
	}
}
map&lt;ll,db&gt; F;
inline db check(ll x){
	if(F.find(x)!=F.end()) return F[x];
	if(x&lt;=N) return f[x];
	db ans=(db)x*(x+1)/2;
	for(ll l=2,r;l&lt;=x;l=r+1){
		r=x/(x/l);
		ans-=(r-l+1)*check(x/l);
	}
	return F[x]=ans;
}
int main(){
	init(); 
	db n;
	cout&lt;&lt;"Input number:";
	cin&gt;&gt;n;
	cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;"target: "&lt;&lt;n&lt;&lt;endl;
	ll l=1e5,r=1e11,mid;
	db res;
	while(r-l&gt;2){
		mid=(l+r)&gt;&gt;1;
		res=check(mid);
		cout&lt;&lt;"guess "&lt;&lt;mid&lt;&lt;":"&lt;&lt;res&lt;&lt;endl;
		if(res&gt;n) r=mid;
		else l=mid;
	}
	cout&lt;&lt;"Finished"&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## 咋弄？

首先找到一个积性函数 $g$ 使得 $g$ 和 $h(=f*g)$ 的前缀和能够快速求出。

$$\begin{aligned}
\sum\limits_{i=1}^nh(i)&amp;=\sum\limits_{i=1}^n\sum\limits_{d\ |\ i}f(\frac{i}{d})g(d)
\\&amp;=\sum\limits_{d=1}^n\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}f(i)g(d)
\\&amp;=\sum\limits_{d=1}^ng(d)\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}f(i)
\\&amp;=\sum\limits_{d=1}^ng(d)F(\left\lfloor\frac{n}{d}\right\rfloor)
\\&amp;=g(1)F(n)+\sum\limits_{d=2}^ng(d)F(\left\lfloor\frac{n}{d}\right\rfloor)
\\&amp;=F(n)+\sum\limits_{d=2}^ng(d)F(\left\lfloor\frac{n}{d}\right\rfloor)
\end{aligned}$$

$$\Huge{F(n)=\sum\limits_{i=1}^nh(i)-\sum\limits_{d=2}^ng(d)F(\left\lfloor\frac{n}{d}\right\rfloor)}$$

整除分块递归即可。

## 时间？

[别人的时间复杂度证明](https://blog.csdn.net/luositing/article/details/103726680)

（记得预处理出 $F(i)(1\le i\le n^{2/3})$）

## 练练手？

### $\varphi$

取 $g=I,h=\varphi*I=id$。

$$\begin{aligned}
\sum\limits_{i=1}^n\varphi(i)&amp;=F(n)
\\&amp;=\sum\limits_{i=1}^ni-\sum\limits_{d=2}^nF(\left\lfloor\frac{n}{d}\right\rfloor)
\\&amp;=\dfrac{n(n+1)}{2}-\sum\limits_{d=2}^nF(\left\lfloor\frac{n}{d}\right\rfloor)
\end{aligned}$$

### $\mu$

取 $g=I,h=\mu*I=\varepsilon$。

$$\begin{aligned}
\sum\limits_{i=1}^n\mu(i)&amp;=F(n)
\\&amp;=\sum\limits_{i=1}^n[i=1]-\sum\limits_{d=2}^nF(\left\lfloor\frac{n}{d}\right\rfloor)
\\&amp;=1-\sum\limits_{d=2}^nF(\left\lfloor\frac{n}{d}\right\rfloor)
\end{aligned}$$

### 例题

[P4213 【模板】杜教筛（Sum）](https://www.luogu.com.cn/problem/P4213)

[Submission](https://www.luogu.com.cn/record/69372187)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15915775.html</id>
    <title type="text">重修 网络最大流-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-02-20T09:51:00Z</published>
    <updated>2022-02-20T09:51:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15915775.html" />
    <content type="text"># 基础

本蒟蒻只讲一些我常常出错的部分，具体还要靠 [OI-wiki:Dinic](https://oi-wiki.org/graph/flow/max-flow/#dinic) 的帮助。

## 啥是最大流？

相当于有一个供水站，一个用户，中间有复杂的水管（每一根单向且有单位时间传输量限制）网络，求用户单位时间内获得的最大水量。

## Dinic 咋弄？

每次先 BFS 按照离原点 $S$ 的距离将图分层，再在分层图上 DFS，终止条件为 BFS 时候汇点 $T$ 与 $S$ 不连通。DFS 时每次找一条通的管道注水，当然一次 DFS 整体看起来像打通了一棵树（多路增广）。

如果一条边已经被增广过，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边（当前弧优化）。

## 时间？

$O(n^2m)$（前提是加上多路增广和当前弧优化）(事实上在一般的网络上，Dinic 算法往往达不到这个上界。)

特别地，在求解二分图最大匹配问题时，Dinic 算法的时间复杂度是 $O(m\sqrt{n})$。

## 建议？

建议一遍写对，难调的很 qwq。

## 我的代码？

[Luogu 模板题](https://www.luogu.com.cn/problem/P3376):

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```
//Said no more counting dollars. We'll be counting stars.
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize("unroll-loops")//DONT use rashly,I have suffered
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")//DONT use rashly,I have suffered
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define cerr cerr&lt;&lt;'_'
#define debug cerr&lt;&lt;"Passed line #"&lt;&lt;__LINE__&lt;&lt;endl
template&lt;typename T&gt;T ov(T x){cerr&lt;&lt;"Value: "&lt;&lt;x&lt;&lt;endl;return x;}
#define ll long long
const ll mod=1000000007;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
inline void mad(ll &amp;a,ll b){a=(a+b)%mod;while(a&lt;0)a+=mod;}
inline void mmu(ll &amp;a,ll b){a=a*b%mod;while(a&lt;0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N 202
#define M 5002
const int inf=1e17;
struct edge{int nxt,to,flow;}e[2*M];//反向边空间开两倍！！！ 
int n,m,S,T,tot=1,head[N],cur[N],dis[N];
void adde(int x,int y,int z){
	e[++tot]=(edge){head[x],y,z}; head[x]=tot;
	e[++tot]=(edge){head[y],x,0}; head[y]=tot;
}
queue&lt;int&gt; q; 
bool bfs(){
	For(i,1,n) dis[i]=0;
	dis[S]=1;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		cur[x]=head[x];
		for(int i=head[x],to;i;i=e[i].nxt){
			to=e[i].to;
			if(!e[i].flow || dis[to]) continue;
			dis[to]=dis[x]+1;
			q.push(to);
		}
	}
	return dis[T];
}
int dfs(int x,int flow){
	if(x==T) return flow;
	int res=0,tmp,to;
	for(int&amp; i=cur[x];i;i=e[i].nxt){
		to=e[i].to;
		if(!e[i].flow || dis[to]!=dis[x]+1) continue;
		tmp=dfs(to,min(flow,e[i].flow));
		e[i].flow-=tmp;
		e[i^1].flow+=tmp;
		flow-=tmp;
		res+=tmp;
		if(!flow) break;
	}
	return res;
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;
	int x,y,z;
	For(i,1,m){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
		adde(x,y,z);
	} 
	int ans=0;
	while(bfs()) ans+=dfs(S,inf);
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

最小点割（要拆点）[原题](https://atcoder.jp/contests/abc239/tasks/abc239_g)：

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```
//Said no more counting dollars. We'll be counting stars.
#pragma GCC optimize(2,3)//For Web Contests
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define pb emplace_back
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define int long long
#define N 220
#define endl '\n'
const int inf=1e12;
struct node{int to,c,nxt;}e[N*N];
int head[N],cur[N],tot=1,n,m,s,t,dep[N],col[N];
inline void adde(int x,int y,int c){
	e[++tot]={y,c,head[x]};head[x]=tot;
	e[++tot]={x,0,head[y]};head[y]=tot;
}
queue&lt;int&gt; q;
bool bfs(){
	For(i,1,2*n+2) dep[i]=0;
	dep[s]=1;
	while(!q.empty()) q.pop();
	q.push(s);
	int x;
	while(!q.empty()){
		x=q.front();
		cur[x]=head[x];
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			if(!e[i].c || dep[e[i].to]) continue;
			dep[e[i].to]=dep[x]+1;
			q.push(e[i].to);
		}
	}
	return dep[t];
}
int dfs(int rt,int flow){
	if(rt==t) return flow;
	int res=0,tmp;
	for(int &amp;i=cur[rt];i;i=e[i].nxt){//当前弧优化&amp;多路增广 
		if(!e[i].c || dep[e[i].to]!=1+dep[rt]) continue;
		tmp=dfs(e[i].to,min(flow,e[i].c));
		e[i].c-=tmp;
		e[i^1].c+=tmp;
		flow-=tmp;
		res+=tmp;
		if(!flow) break;
	}
	return res;
}
int dinic(){
	int res=0;
	while(bfs()) res+=dfs(s,inf);
	return res;
}
void color(int rt){
	col[rt]=1;
	for(int i=head[rt];i;i=e[i].nxt){
		if(!e[i].c || col[e[i].to]) continue;
		color(e[i].to);
	}
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;m;
	int x,y;
	while(m--){
		cin&gt;&gt;x&gt;&gt;y;
		adde(x,y+n,inf);
		adde(y,x+n,inf);
	} 
	For(i,1,n){
		cin&gt;&gt;x;
		if(i==1 || i==n) x=inf;
		adde(i+n,i,x);
	}
	s=n*2+1,t=n*2+2;
	adde(s,1,inf);
	adde(n*2,t,inf);
	cout&lt;&lt;dinic()&lt;&lt;endl;
	color(s);
	vector&lt;int&gt; ans;
	For(i,2,n-1)
		if(col[i]!=col[i+n])
			ans.pb(i);
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(int i:ans) cout&lt;&lt;i&lt;&lt;" "; cout&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

# 最小割的可行边与必须边

就是在残量网络上跑tarjan

可行边：

满流并且残量网络上不能存在入点到出点的路径

必须边：

满流并且残量网络上入点能从源点到达，出点能到汇点。

 

任意一种最小割求法：

跑一边最大流

残量网络上从S开始BFS，标记能到达的点

如果一个边的入点能从S到达，出点不能从S到达，这条边就在最小割里

证明：

1. 不能到出点，所以这些边一定都满流

2. 由于一定不在同一条路径上，所以之和一定是最大流

3. 找出的边一定是割集，否则有增广路还可以增加最大流

转载自 *Miracle* 的blog

# 退流

## 解决啥问题

跑完网络流之后，要减边，然后问你最大流（最大费用）。

## 咋做

设要删掉的边为 $u\to v$。我们从 $u$ 到 $S$ 跑最大流（退流），再从 $T$ 到 $v$ 跑最大流。最后将 $u\to v$ 及其反向边 flow 归零（删除）即可。

## 例题

[P3308 [SDOI2014]LIS](https://www.luogu.com.cn/problem/P3308)

请看代码↓

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//Said no more counting dollars. We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define int long long
#define N 1410
#define M 247200
#define endl '\n'
struct edge{int nxt,to,flow;}e[2*M];
const int inf=1e9;
int n,a[N],b[N],c[N],f[N],L,S,T,tot,head[N],cur[N],dis[N],all;
void adde(int x,int y,int z){
	e[++tot]=(edge){head[x],y,z};head[x]=tot;
	e[++tot]=(edge){head[y],x,0};head[y]=tot;
}
struct node{
	int num,id,w;
	friend bool operator&lt;(node x,node y){return x.w&lt;y.w;}
}g[N];
queue&lt;int&gt; q;
bool check(int S,int T){//其实就是弱化版的 bfs()，bfs() 当 check() 太慢过不去 
 	For(i,1,all) dis[i]=0;
	dis[S]=1;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		for(int i=head[x],to;i;i=e[i].nxt){
			to=e[i].to;
			if(!e[i].flow || dis[to]) continue;
			if(to==T){
				while(!q.empty()) q.pop();//记得清空 
				return true;
			}
			dis[to]=1;
			q.push(to);
		}
	}
	return false;
}
bool bfs(int S,int T){
	For(i,1,all) dis[i]=0;
	dis[S]=1;
	q.push(S);
	int x;
	while(!q.empty()){
		x=q.front();
		q.pop();
		cur[x]=head[x];
		for(int i=head[x],to;i;i=e[i].nxt){
			to=e[i].to;
			if(!e[i].flow || dis[to]) continue;
			dis[to]=dis[x]+1;
			q.push(to);
		}
	}
	return dis[T];
}
int dfs(int x,int T,int flow){
	if(x==T) return flow;
	int res=0,tmp,to;
	for(int &amp;i=cur[x];i;i=e[i].nxt){
		to=e[i].to;
		if(dis[to]!=dis[x]+1 || !e[i].flow) continue;
		tmp=dfs(to,T,min(flow,e[i].flow));
		e[i].flow-=tmp;
		e[i^1].flow+=tmp;
		res+=tmp;
		flow-=tmp;
		if(!flow) break;
	}
	return res;
} 
int Dinic(int S,int T){
	int res=0;
	while(bfs(S,T)) res+=dfs(S,T,inf);
	return res; 
}
int ans,out[N],oc;
void work(){
	scanf("%lld",&amp;n);
	For(i,1,n) scanf("%lld",a+i);
	For(i,1,n) scanf("%lld",b+i);
	For(i,1,n) scanf("%lld",c+i);
	int S=n*2+1;T=S+1;
	all=T;tot=1;
	For(i,1,all) head[i]=0;
	For(i,1,n){
		f[i]=1;
		For(j,1,i-1) if(a[j]&lt;a[i]) ckmx(f[i],f[j]+1);
	}
	L=f[1];
	For(i,2,n) ckmx(L,f[i]);
	For(i,1,n){
		if(f[i]==1) adde(S,i,inf);
		if(f[i]==L) adde(i+n,T,inf);
	} 
	For(i,2,n) For(j,1,i-1) if(f[i]==f[j]+1) adde(j+n,i,inf);
	For(i,1,n){
		adde(i,i+n,b[i]);
		g[i]=(node){i,tot-1,c[i]};//id 为正向边边权 
	}
	sort(g+1,g+1+n);//按照附加属性排 
	ans=Dinic(S,T);
	oc=0;
	int x;
	For(i,1,n){
		x=g[i].num;
		if(check(x,x+n)) continue;//废了，不是可行割
		out[++oc]=x;
		Dinic(x,S);//退流 
		Dinic(T,x+n);//这两步骤后流平衡 
		e[g[i].id].flow=e[g[i].id^1].flow=0;//删边 
	} 
	printf("%lld %lld\n",ans,oc);
	sort(out+1,out+1+oc); 
	For(i,1,oc) printf("%lld ",out[i]); puts("");
}
signed main(){
	int C;scanf("%lld",&amp;C);
	while(C--)work();
return 0;}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/15933160.html</id>
    <title type="text">皮克定理证明-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-02-24T10:55:00Z</published>
    <updated>2022-02-24T10:55:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/15933160.html" />
    <content type="text">[Link](https://www.cnblogs.com/ylxn/p/11681808.html)

大概就分 $4$ 步：

1. 证明对长方形是成立的

2. 证明对直角三角形是成立的

3. 证明对任意三角形也是成立的

4. 证明对于两个图形的组合还是成立的</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16131456.html</id>
    <title type="text">2022 跳坑（或妙计）记录-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-26T14:52:00Z</published>
    <updated>2022-08-26T14:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16131456.html" />
    <content type="text">## CF1758E Tick, Tock

调出一个 bug 后不要激动地删调试程序！！！qwq

多测题读入没读完不要 return 掉。

带权并查集写法要多想。

## CF1764F Doremy's Experimental Tree

Prim 和 非堆优化 dij 的 dis 数组是不一样的！！！！！！！！

Prim 是

```cpp
if(dis[i]&gt;w[x][i]) dis[i]=w[x][i],lst[i]=x;
```

dij 是

```cpp
if(dis[i]&gt;dis[x]+w[x][i]) dis[i]=dis[x]+w[x][i];
```

是否加 `dis[x]` 的区别。

[Code](https://codeforces.com/contest/1764/submission/184677343)

## [ABC281E] Least Elements

在保证实现没问题之前追求代码的简洁、合并分讨、无意义压行都是罪恶的。

![](https://img2023.cnblogs.com/blog/2213867/202212/2213867-20221210232125841-1733003036.png)

血的教训。

错误点：权值线段树（本题是主席树）每个叶子存这个值有多少个，然后有一个操作是求前 $k$ 小个值之和。

我以为可以像线段树区间查和一样询问，但其实是不同的。

可以想一想不同点在哪里。

&lt;details&gt;
&lt;summary&gt;不同点&lt;/summary&gt;

当询问递归到一个叶子的时候可能是取这个叶子的部分个数。

如果像原来那样搞就会 WA 或者数组越界啥的。

反正就很寄。
&lt;/details&gt;

[ACcode](https://atcoder.jp/contests/abc281/submissions/37190019)

## P1933 [NOI2010] 旅行路线

把 `iota` 写成了 `fill`。

## P6302 [NOI2019] 回家路线 加强版 &amp; P5468 [NOI2019] 回家路线

经典老番：

```cpp
typedef pair&lt;int,int&gt; pi;
#define int ll
```

## stringstream

[Link](https://blog.csdn.net/pfl_327/article/details/104034779)

没讲到的地方自行百度。

## long double

在数后面加一个 `'L'`。

```cpp
2.4L
3.L
.5L
```

## 龟速乘 快速乘 光速乘 long double 写法

不用带 $\log$ 了！

```cpp
typedef long long ll;
ll mul(ll x,ll y){
	return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;
}
```

## 任何一道卡精度的题

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221019213427079-1447418370.png)

## P5395 第二类斯特林数·行

好多次将 FFT &amp; NTT 的多项式上界（$2$ 的幂）和真实数组大小搞混了。

## CF1738A Glory Addicts

为啥一个 A 题也会跳坑呢，因为 `vector.size()` 类型是 `ull`，和 `int` 或 `ll` 运算后的结果类型仍然是 `ull`，所以若是负数就会出锅。

所以以下头文件：
```cpp
#define siz(x) ((int)(x).size())
```

## P2704 [NOI2001] 炮兵阵地

char 数组读入时数组至少要**多开一位**，因为有 `'\0'` 符号，可能会数组溢出。

## P7752 [COCI2013-2014#2] PALETA

$k$ 为常数，设 $f_n$ 表示 $n$ 个点形成的环给每个点染 $[1,k]\cap \Z$ 中的颜色，要求一条边两端不同色，的方案数。

**递推式：**
$$
f_n=\begin{cases}
0 &amp; n=0
\\
k(k-1) &amp; n=1
\\
(k-2)f_{n-1}+(k-1)f_{n-2} &amp; \text{otherwise.}
\end{cases}
$$
原因是考虑在 $n-1$ 元环中 $1$ 和 $n-1$ 之间插入第 $n$ 个元素。

* 当 $1$ 和 $n-1$ 颜色不同，则原先的计数是 $f_{n-1}$，再乘上第 $n$ 个元素有 $k-2$ 种取法。

* 否则颜色相同，得到 $[2,n-1]$ 段的计数为 $f_{n-2}$（相当于 $1$ 位置是 $n-1$ 位置的克隆，相当于 $n-2$ 元环），再乘上 $n$ 可选 $k-1$ 种颜色。

## P3973 [TJOI2015]线性代数

wssbwssbwssb数据太水数据太水数据太水。

网络流建边双向都有流量，我该怎么办？？？？

## P8360 [SNOI2022] 军队

空间不够可以考虑离线下来，分开做。

## P7323 [WC2021] 括号路径

并查集一定要判是否 `gf(x)==gf(y)`，不然会有蜜汁错误。

## UOJ3. 【NOI2014】魔法森林

LCT 判两个点是否在同一个树内最好用 dsu，用 findrt 可能超时。

## P8496 [NOI2022] 众数

[摩尔投票求绝对众数法](https://zhuanlan.zhihu.com/p/387744743) 合并时忘记判 `val` 相同了/qd

正确的写法：

```cpp
struct tou{
	int val,cnt;
	tou(){}
	tou(int x,int y){val=x,cnt=y;}
	friend tou operator+(const tou&amp; x,const tou&amp; y){
		if(x.val==y.val) return tou(x.val,x.cnt+y.cnt);
		else if(x.cnt&gt;y.cnt) return tou(x.val,x.cnt-y.cnt);
		else return tou(y.val,y.cnt-x.cnt);
	}
};
```

## P1501 [国家集训队]Tree II

平衡树的区间加、区间乘、区间和操作。

但是我下传懒标记时写成了 `sum=sum*mul+add;`。

如果你一下子没看出来错误，那就寄了，因为正确的写法是 `sum=sum*mul+sz*add;`，`sz` 是子树大小。

## P4314 CPU 监控

线段树 lztag 真的繁杂，调了 30min 快吐了，然后向 Konata 求调，然后

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220827192931839-662578743.png)

我就继续调，然后 3min 之内发现错误，典中典。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220827193029355-1552115816.png)

是不是在代码末尾新建一个假的对话框（

```cpp
/*
ShaoJia: Konata，求调/kel
&lt;对方已接收 "1.cpp"&gt;
Konata: 等等哈，你先自己调调，我晚点看看。
ShaoJia: 好的。
ShaoJia: 调出来了，sb 问题，打扰了/jie
Konata: /tp
*/
```

直接搞出人格分裂。

## P7143 [THUPC2021 初赛] 线段树

有恒等式
$$
\sum_{i=1}^n i(n+1-i)=\binom{n+2}{3}
$$
左式为 $n$ 长度所有子串长度和。

组合理解：

我们将 $[0,n+1]$ 共 $n+2$ 个位置设为可以放置的，我们共要放 $3$ 个石子（每个位置只能放一个）。

先放最左和最右的石子，设位置为 $0\le x&lt;z\le n+1$，则我们选择的子串为 $[x+1,z-1]$。

若 $z-x=1$，则 $y$ 无地放，贡献为 $0$，否则，$y$ 的可放置位置数正好为子串的长度，原式得证。

## P6630 [ZJOI2020] 传统艺能

传统艺能：指两个小时调两个没有取模的 sb 错误。

## P4097 [HEOI2013]Segment

把带 eps 的浮点比较返回 -1,0,1 的函数写成 bool 类型。

## P3388 【模板】割点（割顶）

一行带空格输出的东西不要换行输出，注意输出格式。

## P5491 【模板】二次剩余

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int x,y;
	node(int xx=0,int yy=0){ x=xx,y=yy; }
	friend bool operator==(node x,node y){ return x.x==y.x &amp;&amp; x.y==y.y; }
};
signed main(){
	node tmp=1;
	cout&lt;&lt;(tmp==1)&lt;&lt;endl;//Yes
	cout&lt;&lt;(tmp==2)&lt;&lt;endl;//No
return 0;}
```

这是可以编译过的。/jy

## CF1712D Empty Graph

二分答案 $[1,2\times 10^9]$ 时 `mid=(l+r)&gt;&gt;1;` 得开 long long，不然祖宗。

## P3332 [ZJOI2013]K大数查询

对拍的时候一定要保证 `make.cpp` 造出来的数据是合法的。/ll

## P3249 [HNOI2016] 矿区

`mkp(read(),read())` 是会反过来的。

但是 `(node){read(),read()}` 是正的。

构造函数 `node(read(),read())`  又是反的。

对于计算几何知道向量 $(x,y)$ 求与 $x$ 轴正方向夹角，用 `atan2(y,x)`（结果为弧度）不会有除数为 $0$ 的问题。

## P2617 Dynamic Rankings

不要把函数命名为 `move()`，std 有了这个函数了，而且好像不报错。

## arc145_d Non Arithmetic Progression Set

long long 、祖宗、懂？

## CF1250N Wires

离散化后解决后输出方案时记得还原回离散化前的值！

## P2481 [SDOI2010]代码拍卖会

$f(x)=10x+1\bmod p$ 一直递归可能不是环，而是 $\rho$ 形的，所以环长不等于总长度。

然后还要判余数，和 $n$ 根本走不到 $\rho$ 的环的情况，反正难调 + 对拍长 + 写得丑。

## P1997 faebdc 的烦恼

不要把小于号给重定义成小于等于啊啊啊，会有 TLE 到 WA 不等的蜜汁错误。

## gym/103687/problem/M

不要把前缀和数组直接单点求值来取单点的值 qwq。

## P4238 【模板】多项式乘法逆

做多项式题**输入数组和输出数组尽量不要相同**，说不定打架了，况且不好调试。

## P3307 [SDOI2013]项链

新科技：[Lambda 匿名函数](http://c.biancheng.net/view/433.html)

## P4980 【模板】Pólya 定理

将一个数 $n$ 用 $O(\sqrt{n})$ 质因数分解算法后记得判 $n'\ne 1$ 的情况。

## P5356 [Ynoi2017] 由乃打扑克

一道分块题。

块长设为 $B=400$，数列长度为 $10^5$，开了 $N=10^5+3$。

然后存每一个块的 delta，数组开了 $\frac{N}{B}$，但是从 $1$ 开始下标，少开一位！一——位——啊——！（调了 4h 写了对拍）。

下次再这种 sb 错误我就是歌姬。

## P4569 [BJWC2011]禁忌

kasumi 前建初始矩阵时要 `+=` 不能 `=`（懂我意思吧）。

也就是说，AC 自动机上可能有重边，需要累加。

## P2444 [POI2000]病毒

AC 自动机判断子串要从 x-&gt;fail 传向 x。

## P3215 [HNOI2011]括号修复 / [JSOI2011]括号序列

这里 splay 指针版不需要记录每个元素的指针，要记录 root，因为有区间 reverse，会改变，查找时直接二分（BST）就行。

而 LCT 中却正好反过来，因为我们要记录点的标号，而且 reverse 操作不会影响标号。不用记录 root。

## P6327 区间加区间sin和

由欧拉公式

$$e^{ix}=\cos x+i\sin x$$

得到

$$
\begin{matrix}
&amp;(\cos \alpha &amp;+i&amp;\sin \alpha )
\\
\times &amp;(\cos \beta &amp;+i&amp;\sin \beta )
\\
=&amp;(\cos(\alpha+\beta)&amp;+i&amp;\sin(\alpha+\beta))
\end{matrix}
$$

就是高一的和差角公式了。

这样我们线段树维护这个复数、复数乘 lazy tag 即可。

## P1486 [NOI2004] 郁闷的出纳员

平衡树 pushup 时 rt.sz 不是 +1 而是 +rt.cnt。

## P2272 [ZJOI2007]最大半连通子图

`vector` 存有向图删重边：

```cpp
sort(e[i].begin(),e[i].end());
e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());
```

## P2045 方格取数加强版

网络流边的 tot 初始为 $1$！！！！！！！！！！！！！！！！！！！！！！

太久没写网络流了，调了 114514 年。

## P4013 数字梯形问题

网络流拆点，点的数组没开两倍。

## P2770 航空路线问题

显然每条原边 $u\leftrightarrow v(u&lt;v)$ 在费用流中建 $u'\to v$，费用为 $0$。

但是容量为多少呢？我当时以为每个点最多只能走一次，所以写了容量为 $1$，就快乐 WA 了。

原因：$1\leftrightarrow n$，可以 $1\to n\to 1$ 这样游，这条边经过 $2$ 次。

所以我们得建容量为 $1$ 的边两遍 qwq。

## P5610 [Ynoi2013] 大学

一道 Ynoi，肥肠卡常，搞了两天（做法放在简思短解）。

真正的跳坑：

1. 无序插入的数组不排序直接二分 lower_bound（甚至调了半天）/qd。

2. 被排除的忘记判断直接做了，导致错误。

介绍卡常：

1. 将 vector 改用前向星。

2. 将两次前向星改为一次，时空均减。

3. 改用 scanf。

4. 函数加 inline，将不必要的函数直接拆开。

5. 去掉冗余的树状数组查询，以及 que(x)-que(x-1)（因单点修改区间询问，直接存原序列求单点）。

6. 将**前向星**改为**指针版**的（首次尝试这样写），不过好像还变慢了？？

7. 将数组大小更接近真实值。

8. 将树状数组 que 中 **x-=low(x) 改为 x^=low(x)**，不过效果不明显。

9. 改 long long，不需要 64 位的用 32 位。

10. 将 求两次 lower_bound 求区间后遍历 改为 一次左端点二分，遍历时判断是否越右端点（效果显著）。

11. 改用 **buf 快读**（首次尝试）。

12. 此时已经 517ms（时限 500ms），将编译从 c++14 O2 改成 c++98 O2 就蜜汁过了（不可思议）。

最后附上代码（非指针版前向星）

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//Said no more counting dollars. We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define N 100002
#define V 500002
#define C 20000002
#define ll long long
#define low (x&amp;(-x))
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
#define rg register
inline int read() {
  rg int x=0,f=1;
  rg char c=gc();
  while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
  while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
  return x*f;
}
inline long long lread() {
  rg long long x=0,f=1;
  rg char c=gc();
  while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
  while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
  return x*f;
}
int n,m,g[N],lim=0;
ll c[N];
inline void add(int x,int y){
	while(x&lt;=n){
		c[x]+=y;
		x+=low;
	}
}
inline ll que(int x){
	ll res=0;
	while(x){
		res+=c[x];
		x-=low;
	}
	return res;
}
struct node{int nxt,id;}e[N];
int head[V],tot=0,d[C],cnt[V],L[V],R[V],f[C];
inline int gf(int x){return (x^f[x])?f[x]=gf(f[x]):x;}
#define lb lower_bound
inline void work(int l,int r,int w){
	int i=gf(lb(d+L[w],d+R[w],l)-d),val; 
	while(d[i]&lt;=r &amp;&amp; i&lt;R[w]){
		val=g[d[i]];
		if(val%w){
			f[i]=gf(i+1);
		}else{
			add(d[i],val/w-val);
			g[d[i]]=val/w;
		}
		i=gf(i+1);
	}
}
int main(){
	n=read();m=read();
	int x;
	For(i,1,n){
		g[i]=x=read();
		if(!x) continue;
		if(lim&lt;x) lim=x;
		add(i,x);
		cnt[x]++;
		e[++tot]=(node){head[x],i};head[x]=tot;
	} 
	For(i,1,lim)
		for(int j=i;j&lt;=lim;j+=i)
			L[i+1]+=cnt[j];
	For(i,2,lim) L[i]+=L[i-1];
	For(i,1,lim) R[i]=L[i];
	For(i,1,lim)
		for(int j=i;j&lt;=lim;j+=i)
			for(int k=head[j];k;k=e[k].nxt)
				d[R[i]++]=e[k].id;
	For(i,1,lim) sort(d+L[i],d+R[i]);
	For(i,0,R[lim]) f[i]=i;
	int opt;
	ll lst=0,l,r,w;
	while(m--){
		opt=read();l=lread()^lst;r=lread()^lst; 
		if(opt==1){
			w=lread()^lst; 
			if(w==1) continue;
			work(l,r,w);
		}else{
			lst=que(r)-que(l-1);
			printf("%lld\n",lst);
		}
	}
return 0;}
```
&lt;/details&gt;

## CF1674E Breaking the Wall

给定两个数 $a,b$，每次可以将一个 $-1$，另一个 $-2$，求使得两个均非正的最小次数。

我们不妨设 $a\le b$。

若 $2a\le b$，则我们每次都把 $-2$ 给 $b$，这样答案是 $\lceil\frac{b}{2}\rceil$。

否则，我们先给 $b$ 每次 $-2$，$a$ 每次 $-1$，直到使得 $a=b$。我们再用两种消减方式 $\{-1,-2\},\{-2,-1\}$ 交替搞 $a,b$。

通过分类讨论剩余 $\%3$，设 $c=2a-b$，则得到答案为

$$(b-a)+\lfloor\frac{2}{3}c\rfloor+(c\bmod 3)$$

## P2455 [SDOI2006]线性方程组

判无解优先于判无穷解！！！

[代码](https://www.luogu.com.cn/record/74737486)

## UVA11082 矩阵解压 Matrix Decompressing

建网络流的时候一定不要吝啬空间，记得精细算点数，边数（开两倍）。

## 405. 将他们分好队

qwq 被坑惨了。

题意转化为：给一个图，让划分成两个点集 $S,T$，使得 $S,T$ 分别为独立集，$n\le 100$。当然希望两个子集大小尽量相同（靠近 $n/2$），然后输出方案。

首先跑二分图。然后对于每一个连通块有两部分各自独立的点集。然后相当于分组背包了，最后体积要尽量接近 $n/2$。

坑点 1：分组背包中要二选一，不能不选（这个调了一下午qwq）。

坑点 2：多重背包不能滚动，因为要找方案（调了一晚上qwq）。

总计交了 20 遍。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//Said no more counting dollars. We'll be counting stars.
#pragma GCC optimize("Ofast")
//#pragma GCC optimize("unroll-loops")//DONT use rashly,I have suffered
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")//DONT use rashly,I have suffered
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define cerr cerr&lt;&lt;'_'
#define debug cerr&lt;&lt;"Passed line #"&lt;&lt;__LINE__&lt;&lt;endl
template&lt;typename T&gt;T ov(T x){cerr&lt;&lt;"Value: "&lt;&lt;x&lt;&lt;endl;return x;}
#define ll long long
const ll mod=1000000007;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
inline void mad(ll &amp;a,ll b){a=(a+b)%mod;while(a&lt;0)a+=mod;}
inline void mmu(ll &amp;a,ll b){a=a*b%mod;while(a&lt;0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N 110
//405. 将他们分好队
int n,tot=1;
int f[N][N];
int cnt[2*N];
bool a[N][N],flag=1,out[2*N];
vector&lt;int&gt; e[N];
int col[N];
void dfs(int x,int y){
	col[x]=y;
	cnt[y]++;
	For(i,1,n) if(a[x][i] || a[i][x]){
		if(col[i]==y){
			flag=0;
			return ;
		}else if(!col[i]) dfs(i,y^1);
	}
}
signed main(){IOS;
	cin&gt;&gt;n;
	int x;
	For(i,1,n) For(j,1,n) a[i][j]=(i!=j);
	For(i,1,n){
		while(1){
			cin&gt;&gt;x;
			if(!x) break;
			a[i][x]=0;
		}
	} 
	For(i,1,n) if(!col[i]){
		tot+=2;
		dfs(i,tot);
		if(!flag){
			cout&lt;&lt;"No solution"&lt;&lt;endl;
			return 0;
		}
	}
	mem(f,-1);
	f[0][0]=0;
	for(int i=2;i&lt;=tot;i+=2){
		Rof(j,n,0){
			if(j-cnt[i]&gt;=0 &amp;&amp; f[i/2-1][j-cnt[i]]&gt;=0) f[i/2][j]=i;
			else if(j-cnt[i^1]&gt;=0 &amp;&amp; f[i/2-1][j-cnt[i^1]]&gt;=0) f[i/2][j]=i^1;
		}
	}
	int ans=0;
	For(i,1,n) if(f[tot/2][i]&gt;=0 &amp;&amp; abs(n-2*i)&lt;abs(n-2*ans)) ans=i;
	Rof(i,tot/2,1){
		out[f[i][ans]]=1;
		ans-=cnt[f[i][ans]];
	}
	For(i,1,n) if(out[col[i]]) ans++;
	cout&lt;&lt;ans;   For(i,1,n) if(out[col[i]])  cout&lt;&lt;" "&lt;&lt;i; cout&lt;&lt;endl;
	cout&lt;&lt;n-ans; For(i,1,n) if(!out[col[i]]) cout&lt;&lt;" "&lt;&lt;i; cout&lt;&lt;endl; 
return 0;}
```
&lt;/details&gt;

## 379. 捉迷藏

传递闭包不会写了 qwq。

错误的：
```cpp
For(k,1,n)
	For(i,1,k-1)
		For(j,1,k-1)
			f[i][j]|=f[i][k]&amp;f[k][j];
```

正确的：
```cpp
For(k,1,n)
	For(i,1,n)
		For(j,1,n)
			f[i][j]|=f[i][k]&amp;f[k][j];
```

## 376. 机器任务

网络流建图的时候下标一定要算好，不能重叠 qwq。

## CF1662C European Trip

矩阵乘法 `a.mul(b)` 是乘法，不是 `*=`。（话说为啥把 `a.mul(a);` 放在 `main` 里不 warning？）

## P4195 【模板】扩展 BSGS/exBSGS

map 最好不要用下标访问不存在的节点，最好之前判断一下 `mp.find(...)==mp.end()`。

这道题就被卡时间了，别的题可能卡空间，因为：

* 访问不存在的节点会让 map 新建这个节点，时间慢。

* 多次新建后 $n$（在 map 中的个数）增大，$\log n$ 随之增大。

* 多次新建后空间可能会爆。

## P5278 算术天才⑨与等差数列

算 $\sum\limits_i(x+ki)^2$ 类似的东西，我用类似平方和前缀和相减的方法算，但是 $k$ 可以是 $0$，然后除数就是 $0$ 崩掉 RE 一直调不出来。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16211505.html</id>
    <title type="text">博弈论-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-01T12:14:00Z</published>
    <updated>2022-08-01T12:14:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16211505.html" />
    <content type="text">## 由来（doge）

&gt; Once upon a time, there were two clever people named Alice and Bob. This is how the story begins...

## 基础

$N$ 为先手必胜局面，$P$ 为先手必败局面。

先手被认为输的局势，我们可以称之为奇异局势。

## 巴什博弈

小学奥数题：甲乙轮流报数至多报 77 个数，至少报 11 个数，从 11 开始，谁先报到 5050 谁就胜利。甲先报，有无必胜策略？

## 威佐夫（Wythoff）博弈

有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

设两堆分别剩余 $x,y$ 的局面为 $(x,y)$。

小范围暴力打表得到奇异局势（pair 之中小的放前面）：

$$
(0,0),(1,2),(3,5),(4,7),(6,10),(8,13),(9,15),(11,18),(12,20),\dots
$$

我们用 $(a_k,b_k)$ 表示。可以看出 $b_k=a_k+k,a_k=\text{mex}\{a_1,b_1,\dots,a_{k-1},b_{k-1}\}$

然后，通过「找规律」得到（在考场上不相信有人严谨证明，就是小范围打表得到的）：

$$
a_k=\lfloor k\phi\rfloor
,
b_k=\lfloor k\phi^2\rfloor
,
\phi=1.618\dots
$$

## Nim 博弈

结论：异或和为 $0$ 则 $P$，否则 $N$。

证明（真的只是证明，不知道当时先人咋想出来的结论）:

首先必败局面有全 $0$，异或和为 $0$，满足要求。

接下来我们按石子总数来强归纳：

* 若当前异或和为 $0$，则任意取石子后异或和均不为 $0$，均为后手创造必胜局面。

* 若当前异或和不为 $0$，我们构造一种方案使得操作后异或和为 $0$，为后手创造败局面：设当前异或和为 $v$，

## K-Nim

[P2490 [SDOI2011]黑白棋](https://www.luogu.com.cn/problem/P2490) &amp; [Loj3784. 「SDOI2011」黑白棋](https://loj.ac/p/3784)（数据水，过了不一定对）

&gt; 有 $n$ 堆石子，每次可从 $k$ 堆石子中拿走任意数量的石子。
&gt; 
&gt; 两个人轮流拿，谁不能拿谁输。

结论： 将每堆数量分别用二进制表示（设二进制最高位为 $c-1$），每一位对应相加（$n$ 个 $0/1$ 相加），得到 $s_0,s_1,s_2,\dots,s_{c-1}$，奇异局面当且仅当**$\{s\}$ 均为 $(k+1)$ 的倍数**。

$k=1$ 时即为正常 Nim。

证明不难，类似正常 Nim。

## Anti-Nim

先手必胜：

* 异或和为 $0$ 且每一堆都只有 $1$ 个石子

* 异或和不为 $0$ ，且至少有一堆多于 $1$ 个石子

## SG（人名 Sprague-Grundy）函数

分道：$sg(x)=\text{mex}\{sg(son)\}$

分局面：$sg(x)=\text{xor}\{sg(son)\}$

## 树上删边博弈

算是 SG 例题。

在树上，我们可以进行这样一种博弈游戏：

给出一个有 $n$ 个点的树，有一个点作为树的根节点，游戏者只有两人。

游戏者轮流从树中删去边，删去一条边后，不与根节点相连的部分将被移走。

谁无路可走谁输。

简单的树**手推一下各个 SG 值**，然后找规律。

发现 $sg(rt)=\text{xor}\{(sg(son)+1)\}$。

证明对树的大小归纳，不难，略。

当然类似的树上博弈也类似做法，即 SG 扩展性好。

# 二分图博弈

[见二分图](https://www.cnblogs.com/shaojia/p/15731380.html#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88)

# 有向图博弈

[[省选联考 2023] 过河卒](https://www.luogu.com.cn/problem/P9169)

状态为 $(x,y,x',y',x'',y'',z)$ 表示黑棋的位置和两个红棋的位置和当前谁先手。

然后就转化成有向图博弈了。

我们将能确定胜负的局面全部确定好后，声称没确定的点都是平局点。

考虑将能确定胜负的点全部删去，剩下的图每个点必然有出度，且其他被删掉的出度到达的点都是先手必胜点。

这样两个人就会在新的有向图中不断游走，导致平局。

采用 bfs（类似 topo）删除确定胜负的点。

[record](https://www.luogu.com.cn/record/123458222)

# 阶梯 Nim

P3480 [POI2009] KAM-Pebbles
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16244319.html</id>
    <title type="text">重修 Slope Trick-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-10T11:59:00Z</published>
    <updated>2022-05-10T11:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16244319.html" />
    <content type="text">Slope Trick 算法存在十余载了，但是我没有找到多少拍手叫好的讲解 blog，所以凭借本人粗拙的理解来写这篇文章。

本文除标明外所有图片均为本人手绘（若丑见谅），画图真的不容易啊 qwq（无耻求赞）。

# Slope Trick 是啥？

凸代价函数DP优化。

# 具体哪种题目？

AcWing273. 分级

CF713C Sonya and Problem Wihtout a Legend

CF13C Sequence

P2893 [USACO08FEB]Making the Grade G

P4331 [BalticOI 2004]Sequence 数字序列

P4597 序列 sequence

P8118 Mystery

**千万题目汇成一句话：**

&gt; 给定长度为 $N(\le 10^6)$ 的序列 $A$，构造一个长度为 $N$ 的非降序列 $B$，最小化 $S=\sum\limits^N_{i=1}|A_i−B_i|$，求出 $S$ 的最小值和 $B$ 的构造方案。

注意 Slope Trick 不止能够解决这个问题，这个题目只是便于举例而已。

# 暴力咋做？

就是 $O(n^2)$ 的 DP。

设 $f_{i,j}$ 表示 $A$ 中第 $i$ 个数变为 $j$，前 $i$ 个数变为非降序列的最小代价，即
$$
\min_{B_1\le B_2\le\dots\le B_i=j}\sum_{k=1}^{i}|A_k−B_k|
$$
则有递推式
$$
f_{i,j}=|A_i-j|+\min_{k=minV}^{j} f_{i-1,k}
$$
其中 $minV$ 指值域下界。

当然，为了后续的拓展，我们设
$$
g_{i,j}=\min_{k=minV}^{j}f_{i,k}
$$
则递推式改成
$$
f_{i,j}=|A_i-j|+g_{i-1,j}
$$
是不是非常美观？

# 过渡

在下一步之前，我们需要几个定义和引理。

## 引理 A

两个斜率分别为 $a,b$ 的一次函数相加的斜率为 $a+b$。

## 定义 1

我们称这样的函数为**美妙的函数**：

* 函数连续。
* 函数由若干条一次函数（或常数函数）拼接而成（所以是分段函数），且一次函数的斜率为整数。
* 函数下凸，即若干条一次函数的斜率从左往右单调非减。

## 引理 B

任意两个美妙的函数相加还是美妙的函数。

## 定义 2

设一个连续函数 $f(x)$ 的**前缀最小函数** $g(x)$ 为
$$
g(x)=\min_{x'\le x}f(x')
$$

## 引理 C

一个美妙的函数的前缀最小函数还是美妙的函数，且最后一段（至 $x\to\infty$）为常数函数。

# 咋拓展到 Slope Trick？（正题）

先回忆一下递推式
$$
f_{i,j}=|A_i-j|+g_{i-1,j}
$$
我们设 $F_i(x)$ 函数
$$
F_i(x)=f_{i,x}
$$
类似地
$$
G_i(x)=g_{i,x}
$$
最后设
$$
H_i(x)=|x-A_i|
$$
我们再次改写递推式
$$
F_i(x)=H_i(x)+G_{i-1}(x)
$$
简洁美观！（请牢记这个公式）

由数学归纳法得到 $F,G,H$ 都是美妙的函数。

我们维护 $S_1,S_2,\dots,S_c$ 为 $G$ 函数的转折点。

来几张图演示一下。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103802466-1494049957.png)

设这个 $G_i$ 从一次函数到常数函数的转折点为 $P_i$。

值得注意的是，若一个转折点左边斜率 $&gt;$ 右边斜率 $+1$，则这个点是要再重复 $($ 左边斜率 $-$ 右边斜率 $-1)$ 次的，即：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103811459-1859476274.png)

然后加上 $H_i$，要分类：

## $A_i\ge P_{i-1}$

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103830873-182000511.png)

这样答案（为最右边水平部分的 $y$ 坐标）不变，即
$$
\begin{aligned}
F_i(P_i)&amp;=H_i(P_i)+G_{i-1}(P_i)
\\
&amp;=G_{i-1}(P_i)
\\
&amp;=G_{i-1}(P_{i-1})
\\
&amp;=F_{i-1}(P_{i-1})
\end{aligned}
$$
没有贡献。

而且对于 $\{S\}$，只用将 $A_i$ 插入 $\{S\}$ 末尾即可。

## $A_i&lt;P_{i-1}$

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103844002-876595186.png)

这样答案为
$$
\begin{aligned}
F_i(P_i)&amp;=H_i(P_i)+G_{i-1}(P_i)
\\
&amp;=P_i-A_i+F_{i-1}(P_i)
\\
&amp;=P_i-A_i+F_{i-1}(P_{i-1})+P_{i-1}-P_i
\\
&amp;=F_{i-1}(P_{i-1})+P_{i-1}-A_i
\end{aligned}
$$
即增加
$$
F_i(P_i)-F_i(P_{i-1})=P_{i-1}-A_i
$$
所以将 $Ans+\!=P_{i-1}-A_i$。

此时 $A_i$ **插入** $\{S\}$ 要**两次**，因为他是绝对值函数的转折点，所以两边斜率差值为 $2$。

------

相信很多人都蒙了，我们具象一下。

想象有一条左右无限长的铁丝。

初始化：一开始平放在高度 $0$ 的位置（$F_0(x)=G_0(x)=0$）

然后进行 $n$ 次操作，第 $i$ 次：

1. 铁丝横坐标为 $A_i$ 的地方用尖嘴钳固定住。

2. 将尖嘴钳左边的部分向上翘 $1$ 单位的斜率（这部分铁丝每一点都要弯 $1$ 斜率）。
3. 尖嘴钳右边的部分同理向上翘 $1$ 单位的斜率。这样整条铁丝更像「U」形。

这样我们从 $G_{i-1}$ 得到了 $F_i$。

4. 将右边翘起的部分压平。即在右边找到一个点使得这里的铁丝是水平的（导数为 $0$）然后从这里往右全部捋成水平的。

这样我们从 $F_i$ 得到了 $G_i$。

5. 松开尖嘴钳。

最后答案为整个铁丝的最低高度值。

相信前文仔细阅读的小可爱们一定懂了这段扭铁丝具体在对凸函数干嘛……

------

所以用堆维护 $S_1,S_2,\dots,S_c$ 即可。

总时间 $O(n\log n)$。

# 代码？

```cpp
int n,x,ans=0,b[N];
priority_queue&lt;int&gt; q;
int main(){
	cin&gt;&gt;n;
	For(i,1,n){
		cin&gt;&gt;x;
		q.push(x);
		if(q.top()!=x){
			ans+=q.top()-x;
			q.pop();
			q.push(x);
		}
		b[i]=q.top();
	}
	Rof(i,n-1,1) ckmn(b[i],b[i+1]);
	cout&lt;&lt;ans&lt;&lt;endl;
	For(i,1,n) cout&lt;&lt;b[i]&lt;&lt;" "; cout&lt;&lt;endl;
	return 0;
}
```

# 更多？

当然，Slope Trick 不止这种建模和推导。

为了证明这一点，我们再举一个例子。

## 1

### 题面

题目：[abc250_g Stonks](https://atcoder.jp/contests/abc250/tasks/abc250_g)

大意：

已知接下来 $n(\le 2\times 10^5)$ 天的股票价格 $1\le P_1,P_2,\dots,P_n\le 10^9$。

每天你可以（三选一）：

* 买进**一股**股票
* 卖出**一股**股票
* 什么也不做

$n$ 天之后你拥有的股票应为 $0$。

你最初有足够多的钱，求 $n$ 天结束后能获得的最大利润。

### 解答

#### 带悔贪心

我们可以快速想出一种贪心策略：买入价格最小的股票，在可以赚钱的当天卖出。

显然我们可以发现，上面的贪心策略是错误的，因为我们买入的股票可以等到可以赚最多的当天在卖出。

我们考虑设计一种反悔策略，使所有的贪心情况都可以得到全局最优解。（即设计反悔自动机的反悔策略）

我们先把当前的价格放入小根堆一次（这次是以上文的贪心策略贪心），判断当前的价格是否比堆顶大，若是比其大，我们就将差值计入全局最优解，再将当前的价格放入小根堆（这次是反悔操作）。相当于我们把当前的股票价格若不是最优解，就没有用，最后可以得到全局最优解。

上面的等式即被称为反悔自动机的反悔策略，因为我们并没有反复更新全局最优解，而是通过差值消去中间项的方法快速得到的全局最优解。

#### Slope Trick

首先我们考虑最朴素的 $O(n^2)$ DP 做法：$f_{i,j}$ 表示前 $i$ 天过完，现在手上 $j$ 张股票，所盈利的最大价值。
$$
f_{i,j}=\max\{f_{i-1,j+1}+P_i\, ,\, f_{i-1,j}\, ,\, f_{i-1,j-1}-P_i\}
$$
然后我们设函数 $F_i(x)=f_{i,x}$（老套路了）。
$$
F_i(x)=\max\{F_{i-1}(x+1)+P_i\, ,\, F_{i-1}(x)\, ,\, F_{i-1}(x-1)-P_i\}
$$
也就是说将函数 $F_{i-1}$

* 向上 $P_i$ 单位，向左 $1$ 单位复制一份，设为 $F^+_{i-1}$。
* 向下 $P_i$ 单位，向右 $1$ 单位复制一份，设为 $F^-_{i-1}$。
* 自己 $F_{i-1}$ 也保留。

再求三者的上凸包（$\max$）即为 $F_i$。

这里引用 Atcoder 官方题解的图：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103858789-126365679.png)

我们发现 $F_{i-1}$ 只有左边斜率 $&gt;-P_i$ 且右边斜率 $&lt;-P_i$ 的点才会相对于 $F_{i-1}^+,F_{i-1}^-$「露在外面」。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103918331-200024291.png)

这时会在本来的斜率序列中插入两个斜率为 $-P_i$ 的线段，同时将本来最靠左的线段去掉。所以用堆维护这个斜率序列，插入两个 $P_i$，弹出一次堆顶。

当然，如果 $P_i$ 小于堆顶，则只要插入 $P_i$ 即可。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220510103926961-1037587565.png)

### 代码

两种解法代码一样~~神奇吧~~。

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define int long long
#define N 200010

int n,ans=0,x;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 
signed main(){IOS;
	cin&gt;&gt;n;
	For(i,1,n){
		cin&gt;&gt;x;
		if(i!=1 &amp;&amp; q.top()&lt;x){
			ans+=x-q.top();
			q.pop();
			q.push(x);
		}
		q.push(x);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```

## 2(Upd 2022年8月10日)

lj 2022/8/10 tg T3

&gt; 定义两个长度为 $n$ 序列 $a,b$ 的差异度为 $\sum_{i=1}^n(a_i-b_i)^2$。
&gt;
&gt; 给定一个长度为 $n$ 的正整数数列 $a$，你需要求出一个长度为$n$，并且**单调不降**的**有理数**数列 $b$，使得 $a,b$ 的差异度最小。
&gt;
&gt; 以最简分数形式输出。

相比于之前例题的差异度为 $\sum_{i=1}^n|a_i-b_i|$，这里平了个方。

这样我们每次加的函数就形如 $f(x)=(x-x_0)^2$ 了，无法形成美妙的函数，但是~~发扬人类智慧~~我们将所有函数**求导**后进行 slope trick。

$f'(x)=2x-2x_0=2(x-x_0)$ 我们为方便，将所有系数 $2$ 去掉，所以我们要做到 $n$ 次下面的操作：

1. 将当前函数 $+f_i'(x)$。

2. 由于在原函数中我们将后面斜率 $&gt;0$ 的部分截去，所以在导函数中截去值 $&gt;0$ 的部分。

3. 查值为 $0$ 的最小 $x$ 坐标，存到 $ans_i$ 中。

注意此时相邻两段斜率（原函数的二阶导）之差可能不为 $1$，所以记得存一下每一段的斜率（用整体加减 delta 来优化）。

最后 $\{ans\}$ 取一个后缀 $\min$ 即为答案序列。

所以我们唯一要解决的问题就是 1. 里面的步骤。

设当前 $f_i'(x)=x-a$。

若 $x=a$ 交在那段值为 $0$ 的段。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220812112847190-805651490.png)

↑ 图片来自 wsyear。

那就将每一段的斜率 $+1$。

否则：

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220812112928993-2042469754.png)

找到交点（橙色线段），删掉右边部分，然后斜率 $+1$。

记得封装 frac 结构体。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 200010
struct frac{
	int p,q;
	frac(int x=0,int y=1){ p=x,q=y; }
	void print(){ printf("%lld/%lld ",p,q); }
	frac dv(){
		int d=abs(__gcd(p,q));
		return frac(p/d,q/d);
	}
	friend frac operator+(frac x,frac y){
		int d=__gcd(x.q,y.q);
		return frac(y.q/d*x.p+x.q/d*y.p,x.q/d*y.q).dv();
	}
	friend frac operator-(frac x,frac y){
		int d=__gcd(x.q,y.q);
		return frac(y.q/d*x.p-x.q/d*y.p,x.q/d*y.q).dv();
	}
	friend frac operator*(frac x,frac y){
		return frac(x.p*y.p,x.q*y.q).dv();
	}
	friend frac operator/(frac x,frac y){
		return frac(x.p*y.q,x.q*y.p).dv();
	}
	friend bool operator&lt;(frac x,frac y){
		return x.p*y.q&lt;y.p*x.q;
	}
}p[N],s[N],ans[N];
int tot=0,n;
signed main(){
	n=read();
	frac x,xx,y,z,del=frac();
	For(i,1,n){
		y=frac(read());
		if(!tot || p[tot]&lt;y){
			p[++tot]=y;
			s[tot]=frac()-del;
			del=del+frac(1);
		}else{
			x=frac();
			while(tot&gt;1 &amp;&amp; !((xx=x-(p[tot]-p[tot-1])*(s[tot]+del))&lt;y-p[tot-1]))
				tot--,x=xx;
			z=((y-x+p[tot]*(s[tot]+del))/(s[tot]+del+frac(1))).dv();
			p[tot]=z;
			del=del+frac(1);
		}
		ans[i]=p[tot];
	}
	Rof(i,n-1,1){
		if(ans[i+1]&lt;ans[i]){
			ans[i]=ans[i+1];
		}
	}
	For(i,1,n) ans[i].print();
return 0;}
```
&lt;/details&gt;

# 结语

当然还有题目是推荐做一下的：

[P3642 [APIO2016]烟火表演](https://www.luogu.com.cn/problem/P3642)

介于篇幅题解就不放了， 请自行看 Luogu 的题解区。

还有 [CF1534G A New Beginning](https://www.luogu.com.cn/problem/CF1534G) 也是好题。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16269587.html</id>
    <title type="text">重修 分块和莫队-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-14T04:08:00Z</published>
    <updated>2022-05-14T04:08:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16269587.html" />
    <content type="text">## 带修莫队

[P1903 [国家集训队] 数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)

~~相信我会了~~，这里只考虑时间复杂度。

设我们块大小（$l,r$ 两轴块大小）为 $B$，则时间复杂度为 $O$ 里面：
$$
m(\frac{n}{B})^2+mB+\frac{n^2}{B}
$$
上柿为三维长方体 $x\in[1,n],y\in[1,n],z\in[1,m]$ 内 $m$ 个点以 $x,y$ 轴分别以 $B$ 块长分块后用一根每一段与某坐标轴平行的折线串起来，线以分块策略下的最劣情况长度。

（由于我不会画 3D 的图，所以自行脑补 qwq）

我们若规定 $m&gt;&gt;B$，则上述柿子变为
$$
O(\frac{mn^2}{B^2}+mB)
$$
均衡一下得到 $B=n^{2/3}$，总复杂度为 $n^{2/3}m$。

~~为啥别的题解得到的 $B$ 和我的不一样捏。~~

## 回滚莫队

分成两种：只增加、只删除。

只删除的例题：[P8078 [WC2022] 秃子酋长](https://www.luogu.com.cn/problem/P8078)

## 二次离线莫队

设莫队单次修改的时间为 $t$，则二次离线莫队将莫队**从 $O(nt\sqrt{n})$ 优化到 $O(nt+n\sqrt{n})$**，当然前提是满足**区间可减性**。

例题：[P4887 【模板】莫队二次离线](https://www.luogu.com.cn/problem/P4887)

给你一个序列 $a$，每次查询给一个区间 $[l,r]$，查询 $l \leq i&lt; j \leq r$，且 $popcnt(a_i \oplus a_j)=k$ 的二元组 $(i,j)$ 的个数.$\oplus$ 是指按位异或。$n,q\le 10^5,0\le a_i,k&lt;2^{14}$。

设 $m$ 为 $[0,V)$ 中 $popcnt=k$ 的个数，我们预处理这些数，最后时间复杂度也和 $m$ 有关。

设 $f(x,l,r)$ 表示

$$y\in[l,r],popcnt(a_x\oplus a_y)=k$$

的 $y$ 的个数。

由于区间可减，得到
$$
f(x,l,r)=f(x,1,r)-f(x,1,l-1)
$$
所以下文用 $f(x,y)$ 来简写 $f(x,1,y)$。

只有当 $k=0$ 时 $popcnt(a_x\oplus a_x)=k$，所以得到
$$
f(x,x)=f(x,x-1)+[k=0]
$$
我们先正常莫队（甚至可以奇偶优化）。举个例子（莫队区间设为 $[L,R]$）。

当 $L$ **增大**至 $l$ 时，此询问比上次**减少**
$$\begin{aligned}
\sum_{x=L}^{l-1} f(x,x+1,R)&amp;=\sum_{x=L}^{l-1} f(x,R)-f(x,x)
\\
&amp;=\sum_{x=L}^{l-1} f(x,R)-\sum_{x=L}^{l-1} (f(x,x-1)+[k=0])
\\
&amp;(p(x):=f(x+1,x))
\\
&amp;=\sum_{x=L}^{l-1} f(x,R)-\sum_{x=L}^{l-1} (p(x-1)+[k=0])
\end{aligned}$$
$L$ 增大、$R$ 减小、$R$ 增大 同理，不再赘述。

我们可以用桶 $O(nm)$ 预处理出 $p(x)$。所以剩下的只要拎出 $\sum_{x=L}^{l-1} f(x,R)$ 类的东西求即可，最后再代回来算答案。

接下来就是二次离线部分了。

我们将每一个形如 $\sum_{x=l}^{r} f(x,i)$ 的询问挂在 $i$ 位置上。

然后再用桶扫，同时计算每个位置上的询问。

这部分是 $O(nm+n\sqrt{n})$，$n\sqrt{n}$ 是因为二级询问有 $O(n\sqrt{n})$ 个，每个只要 $O(1)$ 回答。

然后就做完了，总时间 $O(nm+n\sqrt{n})$，与开头说的相同。

例题代码：

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//Said no more counting dollars. We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define int long long
#define N 100010
#define V 16384//值域 
vector&lt;int&gt; bu;//0~V-1 popcnt=k 的数 
int n,m,k,a[N],b[N],gap;
struct Que{
	int l,r,id,ans;//ans:比莫队中上次询问答案的增量 
	friend bool operator&lt;(Que x,Que y){return b[x.l]==b[y.l]?((b[x.l]&amp;1)?x.r&lt;y.r:x.r&gt;y.r):x.l&lt;y.l;}
}q[N];
int p[N];//ct((i+1)-&gt;[1,i]) ct表示贡献 
int t[V];//桶 
int ans[N];//最终答案 
vector&lt;tuple&lt;int,int,int,int&gt; &gt; v[N];
//第一次莫队留下的询问v[i].&lt;l,r,id,val&gt;：[l,r] 区间中所有 x，sum ct(x-&gt;[1,i])，乘系数 val 贡献给询问 i 
signed main(){
	scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k);
	For(i,0,V-1) if(__builtin_popcount(i)==k) bu.pb(i);
	For(i,1,n) scanf("%lld",a+i); 
	For(i,1,m) scanf("%lld%lld",&amp;q[i].l,&amp;q[i].r),q[i].id=i;
	gap=sqrt(n);
	For(i,1,n) b[i]=(i-1)/gap+1;
	sort(q+1,q+1+m); 
	For(i,1,n){
		for(int j:bu) t[a[i]^j]++;
		p[i]=t[a[i+1]];
	}
	int L=1,R=0,l,r;
	For(i,1,m){
		l=q[i].l,r=q[i].r;
        if(L&lt;l)    v[R].pb(L,l-1,i,-1);
        while(L&lt;l){q[i].ans+=p[L-1]+(!k);++L;} 
        
        if(R&gt;r)    v[L-1].pb(r+1,R,i,1);
        while(R&gt;r){q[i].ans-=p[R-1];     --R;}
        
        if(L&gt;l)    v[R].pb(l,L-1,i,1);
        while(L&gt;l){q[i].ans-=p[L-2]+(!k);--L;}
        
        if(R&lt;r)    v[L-1].pb(R+1,r,i,-1);
        while(R&lt;r){q[i].ans+=p[R];       ++R;}
	}
	mem(t,0);
	int id,val,tmp;
	For(i,1,n){
		for(int j:bu) t[a[i]^j]++;
		for(auto x:v[i]){
			tie(l,r,id,val)=x;
			For(j,l,r){
				tmp=t[a[j]];
				q[id].ans+=tmp*val; 
			} 
		}
	}
	For(i,1,m) q[i].ans+=q[i-1].ans;//累计 
	For(i,1,m) ans[q[i].id]=q[i].ans;//重排 
	For(i,1,m) printf("%lld\n",ans[i]);
return 0;}
```
&lt;/details&gt;

## 树上莫队（fake）

指的是平摊成欧拉序后在序列上做莫队。

## 树上莫队（real）

首先先得会树分块。

树分块：[P2325 [SCOI2005]王室联邦](https://www.luogu.com.cn/problem/P2325)

为了保证最终莫队复杂度的正确性，我们需要做到：

* 属于同一块的节点之间的距离不大。

* 每个块中的节点不能太多也不能太少。

* 每个节点都要属于一个块。

* 编号相邻的块之间的距离不能太大。

我们让树分块后依次顺序编号就正好满足了第四个条件了。

分块后的排序方法：若路径 $(u,v)$ 的 $u$ 的时间戳大于 $v$ 那么交换 $u,v$。然后按照 $u$ 所在块为第一关键字，$v$ 的时间戳为第二关键字排序。

注意这里有一个大坑点：

在指针移动的过程中，我们肯定是让移动前的位置和移动后的位置一起向 lca 靠近。然后利用 $vis$ 标记来
判断这个点是要进入区间还是出区间。

但是这个移动中会出现一个问题，移动时候如果跨过 lca 了会出问题，如下图。

我们按照上面步骤从 $(u,v)$ 移到 $(u',v')$的时候，两个 lca 都被标记了两次，也就是标记状态没有改变，这是错误的。

所以我们要把 lca 放到最后特判，单独更新。就解决问题了。

形象一点就是：因为若是边权这样处理没有问题，所以我们将树上路径点权移到它连向祖先的边上（这时候要删掉 lca 的点权），成功改为边权，然后正常移动，然后再变回点权（要把 lca 点权加回来）。

[P4074 [WC2013] 糖果公园](https://www.luogu.com.cn/problem/P4074)

这甚至是树上带修莫队~~太毒瘤了~~。

~~代码被我吃了。~~由于是缝合题，代码有点长，但是很好理解。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Create Time:        2022-08-24 19:46:10
* Last Modified time: 2022-08-25 14:49:42
* Motto: We'll be counting stars.
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
//------------------------------------------
const int N=100005,gap=2000,C=16;
int b[N];
struct Que{
	int u,v,t,id;
	friend bool operator&lt;(Que x,Que y){
		if(b[x.u]!=b[y.u]) return b[x.u]&lt;b[y.u];
		if(b[x.v]!=b[y.v]) return b[x.v]&lt;b[y.v];
		return x.t&lt;y.t;
	}
}q[N];
struct Chan{ int x,lst,nxt; }c[N];
vector&lt;int&gt; e[N];
int n,m,qt=0,v[N],w[N],a[N],s[N],st=0;
int f[N][C+1],dep[N],bl=0,tim=0,now,ans[N],vis[N],cnt[N];
void dfs(int rt,int fa){
	dep[rt]=dep[fa]+1;
	f[rt][0]=fa;
	For(i,1,C) f[rt][i]=f[f[rt][i-1]][i-1];
	int tmp=st;
	s[++st]=rt;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
		if(st-tmp&gt;gap){
			bl++;
			while(st!=tmp) b[s[st--]]=bl;
		}
	}
}
int lca(int x,int y){
	int xx,yy;
	if(dep[x]&lt;dep[y]) swap(x,y);
	Rof(i,C,0){
		xx=f[x][i];
		if(dep[xx]&gt;=dep[y]) x=xx;
	}
	if(x==y) return x;
	Rof(i,C,0){
		xx=f[x][i];
		yy=f[y][i];
		if(xx!=yy) x=xx,y=yy;
	}
	return f[x][0];
}
void del(int x){ now-=w[cnt[x]--]*v[x]; }
void add(int x){ now+=w[++cnt[x]]*v[x]; }
void work(int x){
	if(vis[x]) del(a[x]); else add(a[x]);
	vis[x]^=1;
}
void change(int x,int val){
	if(vis[x]) del(a[x]),add(val);
	a[x]=val;
}
void mov(int x,int y){
	if(dep[x]&lt;dep[y]) swap(x,y);
	while(dep[x]&gt;dep[y])
		work(x),x=f[x][0];
	while(x!=y){
		work(x),x=f[x][0],
		work(y),y=f[y][0];
	}
}
signed main(){
	int opt,x,y,tmp;
	n=read(),m=read(),tmp=read();
	For(i,1,m) v[i]=read();
	For(i,1,n) w[i]=read();
	For(i,1,n-1){
		x=read(),y=read();
		e[x].pb(y);
		e[y].pb(x);
	}
	For(i,1,n) s[i]=a[i]=read();
	while(tmp--){
		opt=read(),x=read(),y=read();
		if(!opt) c[++tim]=(Chan){x,s[x],y},s[x]=y;
		else qt++,q[qt]=(Que){x,y,tim,qt};
	}
	dfs(1,0);
	if(st){ bl++; while(st) b[s[st--]]=bl; }
	sort(q+1,q+1+qt);
	int T=0,U=1,V=1;
	work(1);
	For(i,1,qt){
		while(T&lt;q[i].t) T++,change(c[T].x,c[T].nxt);
		while(T&gt;q[i].t) change(c[T].x,c[T].lst),T--;
		work(lca(U,V));
		mov(U,q[i].u);
		mov(V,q[i].v);
		work(lca(U=q[i].u,V=q[i].v));
		ans[q[i].id]=now;
	}
	For(i,1,qt) printf("%lld\n",ans[i]);
return 0;}
```
&lt;/details&gt;

## 树上撒点

[P3603 雪辉](https://www.luogu.com.cn/problem/P3603)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16278542.html</id>
    <title type="text">重修 网络流建模-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-16T13:06:00Z</published>
    <updated>2022-05-16T13:06:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16278542.html" />
    <content type="text">~~因为这一板块东西太多了所以拎出来单独讲~~

## 二分图最大匹配

[MyBlog 二分图](https://www.cnblogs.com/shaojia/p/15731380.html)

从 $S$ 到所有左部结点各连⼀条容量为 $1$ 的弧，再从所有右部结点各连⼀条容量为 $1$ 的弧到 $T$，最后把每条边变成⼀条由左部节点指向右部节点的有向弧，容量为 $1$。

最大流 $=$ 最大匹配

由于每条边的流量均为 $1$，所以时间为 $O(m\sqrt{n})$，[OI wiki](https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)证明。

## 带依赖集合划分

[P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)

看到二者选其一，联想到了最小割模型。

若是不考虑额外收益，图是很容易建出来的 ：

由 $S$ 向它连一条边权为其种在 $A$ 中的价值的边，表示将其种在 $A$ 中。

由它向 $T$ 连一条边权为其种在 $B$ 中的价值的边，表示将其种在 $B$ 中。

把一条边割掉，则表示不这么种。

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221014204538281-629018718.png)

这样的图，要使其不连通，每个点都不能同时连接源点 $S$ 和汇点 $T$，也就是说，保证其只属于一个集合。

这时跑一遍最小割，是删去的最小，留下的就是最大的了~~假装不能直接取最大值~~。

但是现在加入了额外收益，应该如何改进上述的图呢？

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221014204134694-216656957.png)

差不多长这样，其中蓝色的为 $\inf$ 容量。

答案为总边权 $-$ 最小割。

因为 $c_1 / c_2$ 没有割掉则其旁边的边也都不割一定更优，否则若 $c_1,c_2$ 都割掉则等价于不考虑额外收益的情况。

[P2057 [SHOI2007] 善意的投票 / [JLOI2010] 冠军调查](https://www.luogu.com.cn/problem/P2057)

上面那题的弱化版，集合大小为 $2$ 且分在两侧代价相同。

这时我们就可以将上图 $X,Y$ 点删去，取而代之的是两个绿点之间双向边流量为分在同侧的代价。

## 求三集合（多集合）链状最大匹配

~~子标题名字我 YY 的。~~

[P2891 [USACO07OPEN]Dining G](https://www.luogu.com.cn/problem/P2891) [P1402 酒店之王](https://www.luogu.com.cn/problem/P1402) [P1231 教辅的组成](https://www.luogu.com.cn/problem/P1231) 三倍经验自己看。

设三个集合为 $A,B,C$。

$B$ 集合拆点 $B_0,B_1$。

以下容量均为 $1$。

$S$ 向 $A$ 中元素连边。

$A$ 向 $B_0$ 中可匹配的点连边。

$B_0,B_1$ 对应点连边。

$B_1$ 向 $C$ 中可匹配的点连边。

$C$ 向 $T$ 连边。

跑最大流即为答案。

由于中间有拆点，所以保证了 $B$ 集合每个元素最多用一次。

## 求最大权闭合子图

### 定义

点有点权 $a_i$，一个原有向图点集子集 $G$ 的诱导子图，使得 $\nexists (x\to y)\in E,x\in G,y\notin G$，且 $G$ 中点权和最大。

简称：**胳膊肘不往外拐**

### 做法

建网络流，具体如下：

* 原图上的有向边容量为 $\inf$。

* 对于 $a_i\ge 0$，从 $S$ 向 $i$ 连边，容量为 $a_i$。

* 对于 $a_i&lt;0$，从 $i$ 向 $T$ 连边，容量为 $|a_i|$。

先统计出 $All=\sum a_i[a_i\ge 0]$，再求出最小割（最大流） $Ans$，答案为 $All-Ans$。

模板题：[CF1473F Strange Set](https://codeforces.com/contest/1473/problem/F)

[Code](https://codeforces.com/contest/1473/submission/154450406)

### 正确性证明

**（一）** 跑网络流最小割一定对应一个闭合子图。

显然，最小割一定是简单割，即割的每一条边要么有一端是 $S$，要么有一端是 $T$（因为中间每条边都是 $\inf$）。

设最小割为 $\{S\to x\ |\ x\in A\}\cup\{x\to T\ |\ x\in B\}$。

设 $C=\{x\ |\ S\to x\}$，则对应的闭合子图为 $(C-A)\cup B$ 的诱导子图。

通过简单的推导发现对应的闭合子图权值就是 $All-Ans$。

**（二）** 任何闭合子图都对应一个割。

设闭合子图点集中正权的 $D$，负权的 $B$，则对应的“割”为 $\{S\to x\ |\ x\notin D\}\cup\{x\to T\ |\ x\in B\}$，由上述推导发现 $All-Ans$ 就是闭合子图的权值。

然后我们证明“割”为割，我们用反证法，假设还有流。由于 $\{S\to x\ |\ x\notin D\}$ 都被割了，所以从 $S$ 走一步只能到 $D$ 中的点，而 $D\cup B$ 为闭合子图，所以没有出路，矛盾，原命题成立。

**（三）** 由于最小割，所以闭合子图最大权，得证。

## 上下界流

### 无源汇上下界可行流

也就是没有源汇，每个点的流量均平衡，每条边的流量在区间内，问是否**可行**。

若一条边 $x\to y$ 的界为 $[A,B]$ 且 $A&lt;0$，则拆成两条：

* $x\to y$ 界为 $[0,B]$。

* $y\to x$ 界为 $[0,|A|]$。

这样我们就保证了下界 $\ge0$。

先假设有解。我们让每一条 $x\to y[A,B]$ 拆成 $x\to y[A,A]$ 和 $x\to y[0,B-A]$。

所以，我们可以将 $x\to y[A,A]$ 转化成 $S\to y[0,A]$ 和 $x\to T[0,A]$。

这时候我们跑 $S\to T$ 的最大流，如果与 $S,T$ 相邻的边没有流满，说明无解，否则构造就是现在每条边的流量加上下界流就是答案。

### 有源汇上下界可行流

设这里原图的源汇为 $S',T'$，我们新建的为 $S,T$。

将原图的 $T'$ 向 $S'$ 连 $\inf$ 的边，然后就是无源汇问题了。

### 有源汇上下界最大流

在求出有源汇上下界可行流后只用干两件事：

1. 删掉 $T'\to S'$ 的 $\inf$ 边。

2. 跑 $S'\to T'$ 的最大流。

因为此时与 $S,T$ 相邻的边都被「榨干」了，所以最大流不会搞到 $S,T$ 相邻的边。

所以跑完最大流后 $S\to T$ 还是满流的，所以可行。

### 有源汇上下界最小流

与上文不同的是，这次从 $T'\to S'$ 跑最大流。

### 最小费用上下界可行流

其实和无源汇上下界可行流很像，就是多了费用。

1. 建立附加源点 $S$，和附加汇点 $T$。

2. 对于原图中每一个点（包括源汇）$x$,令 $d_x$ 代表 $x$ 点的所有入边的流量下界减去出边的流量下界。
* 若 $d_x&gt;0$，连 $S\to x$，容量为 $d_x$，费用为 $0$。
* 若 $d_x&lt;0$，连 $x\to T$，容量为 $|d_x|$，费用为 $0$。

3. 对于原图中每一条边 $u\to v&lt;w&gt;[l,r]$，连边 $u\to v$，容量为 $r-l$，费用为 $w$。

### 最小费用有源汇上下界可行流

加边 $T'\to S'$，容量为 $\inf$，费用为 $0$。

## 二分图最小点权覆盖集/最大点权独立集

源点连左部，容量为点权。右边同理。中间原二分图容量为 $\inf$。

## 切糕模型（带依赖变量最优化选值）

[P3227 [HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)

[P6054 [RC-02] 开门大吉](https://www.luogu.com.cn/problem/P6054)

构造 $n$ 条长度为 $m$ 的链，每个变量选什么值就割掉链上第几条边，链之间连代表限制的容量为 $\inf$ 的边，跑最小割。

注意**为了保证每条链只割一条边，我们需要对于每条链上每条边连一条容量为 $\inf$ 的反向边，这样保证了割去最小割后每条链能被源点走到的点集是一个前缀。**</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16286636.html</id>
    <title type="text">APIO2022-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-18T14:22:00Z</published>
    <updated>2022-05-18T14:22:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16286636.html" />
    <content type="text">## 前言

$$
\boxed{\large
\color{blue}{\huge\mathcal{A}}
\text{sia-}
\color{red}{\huge\mathcal{P}}
\text{acific }
\color{yellow}{\huge\mathcal{I}}
\text{nformatics }
\color{green}{\huge\mathcal{O}}\text{lympiad}
}
$$

## 5.18

写完了网络流~~打算之后用网络流骗分~~。

写了两道 APIO 历年，发现好难，不想写了。

## 5.23

把 dev 的缺省源删了，多练练头文件，不让考试时挂在这里。

发了练习用的网站，发现 2/3 是交互题/ll。

对了，才知道 Batch 就是一般意义上的“传统题”，而 Communication 好像是交互题。

人傻了 APIO 的题这么难，2019~21 我分别~~抄题解~~做了 2,1,1 道题（~~甚至 2021 的那道还没过~~ 5.31 补好了 雨林跳跃）。

## 5.25

学了一下 [线段树分治](https://www.cnblogs.com/zhangshaojia/p/16309367.html)，感觉好奇妙，不知道考场上用不用得到。

官方发的练习题做了 1,2 不会 3。

洛谷上帖子说这三道评分约蓝红蓝或绿红绿，wtcl。

### Practice T1

&lt;details&gt;
&lt;summary&gt;点击展开&lt;/summary&gt;

#### Trans

下标从 $0$ 开始。

有一个机器，输入一个长度为 $n$ 的序列 $\{a\}$，返回 $\{b\}$ 序列，$b_i=a_{p_i}\ \text{xor} \ x$，其中 $\{p\}$ 为机器内置的 $n$ 排列（$0$ 到 $n-1$），$x$ 为机器内定的值。你只能向机器中输入一次一个序列 $\{a\}$，其中值域 $[0,n+2]$，然后得到返回 $\{b\}$，请猜出 $\{p\}$。

$3\le n\le 128,0\le x\le 255$

#### Sol

以下的 $/$ 均代表除法+下取整。

首先我们认同，如果猜的数列 $\{a\}$ 值互不相同，且我们求出了 $x$ 的值，那 $\{p\}$ 就迎刃而解了。

分类讨论。设 $k$ 使得 $2^k-1\le n,2^{k+1}-1&gt;n$。

$$\large{n&lt;2^{k+1}-2}$$

我们只要询问 $\{1,2,3,\dots,2^k-1,2^k,\dots,n\}$ 即可。

我们发现将这些数 $/ 2^k$ 后会有两种值 $0,1$，值的个数分别为 $2^k-1,n-2^k+1$。

由于 $2^k-1&gt;n-2^k+1$，我们对于 $\{b\}$ 统计同样的东西（$/ 2^k$），多的那类就对应 $[1,2^k-1]$ 这部分。

多的那部分值就是 $x/2^k$，我们直接将 $(x/2^k)\times 2^k$ 异或掉 $\{b\}$，接下来只有 $x\bmod 2^k$ 的部分了。

由于 $[0,2^k-1]$ 异或一个 $&lt;2^k$ 的 $x$ 后还是 $[0,2^k-1]$ 这些数，我们开桶查询 $\{b\}$ 中 $[0,2^k-1]$ 少了哪个数，就对应着原来 $\{a\}$ 中 $[1,2^k-1]$ 缺失的 $0$，所以 $x\bmod 2^k$ 就是那个缺失的数。

$$\large{n=2^{k+1}-2}$$

类似上一种情况的做法，但是 $2^k-1=n-2^k+1$，无法像上一种这样做。

我们发现 $n+2=2^{k+1}$ 正好是 $2$ 的幂，这说明要用。

我们询问 $\{a\}=\{1,2,3,\dots,2^k-1,2^k,\dots,n-2,n-1,2^{k+1}\}$。

由于 $\{a\}$ 中只有 $2^{k+1}/2^{k+1}=1$，所以我们能快速定位到原 $2^{k+1}$ 在 $\{b\}$ 中的位置，记为 $pos$。

然后 $x=b_{pos}\ \text{xor} \ 2^{k+1}$ 就结束了。

#### Detail

注意分类讨论中第二类不能 $\{a\}=\{\color{red}{0},1,2,\dots,2^k-1,2^k,\dots,n-3,\color{red}{n-2},2^{k+1}\}$。

因为当 $n=6$ 时（其实就是小数据部分的锅），$(n-2)-(2^k-1)=1$，这时 $2^{k+1}$ 和 $2^k(=n-2)$ 就无法区分了。

#### Code

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
#include"machine.h" 
using namespace std;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define pb emplace_back
#define sec second
#define fir first
map&lt;int,int&gt; mp;
bool vis[1000];
vector&lt;int&gt; guess_permutation(int n){
	vector&lt;int&gt; que,res; 
	int a=0;
	while((1&lt;&lt;(a+1))-1&lt;=n) a++;
	if((1&lt;&lt;(a+1))-2==n){
		For(i,0,n-2) que.pb(i);
		que.pb((1&lt;&lt;(a+1)));
		res=use_machine(que);
		mp.clear();
		For(i,0,n-1) mp[res[i]&gt;&gt;(a+1)]++;
		int mn=0,cnt=n+1;
		for(auto i:mp){
			if(i.sec&lt;cnt){
				mn=i.fir;
				cnt=i.sec;
			}
		}
		int pos=0,x;
		while((res[pos]&gt;&gt;(a+1))!=mn) pos++;
		x=res[pos]^(1&lt;&lt;(a+1));
		For(i,0,n-1) res[i]^=x;
		res[pos]=n-1;
		return res;
	} 
	For(i,1,n) que.pb(i);
	res=use_machine(que);
	mp.clear();
	For(i,0,n-1) mp[res[i]&gt;&gt;a]++;
	int mx=0,cnt=0;
	for(auto i:mp){
		if(i.sec&gt;cnt){
			mx=i.fir;
			cnt=i.sec;
		}
	}
	mx&lt;&lt;=a;
	For(i,0,n-1) res[i]^=mx;
	For(i,0,(1&lt;&lt;a)-1) vis[i]=0;
	For(i,0,n-1) if(res[i]&lt;(1&lt;&lt;a)) vis[res[i]]=1;
	int mis=0;
	while(vis[mis]) mis++;
	For(i,0,n-1) res[i]^=mis;
	For(i,0,n-1) res[i]--;
	return res;
}
```
&lt;/details&gt;
&lt;/details&gt;

### Practice T2

就是前缀和板子，不再赘述。

## 5.26

重修了一下分数规划。

出发！！！

路上很不顺。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220526153939382-189366503.png)

然后到处堵车（查核酸+下雨）。

我们 1:30 才到，这边午餐供应 1 点结束，我、xay、yjj、yzc、zty、wn、xyr AA 点了KFC吃。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132920286-151766974.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132928300-2034659553.jpg)

一车大佬一起讨论 practice T3 终于会了。

&gt; 感觉集体降智。——yjj

### Practice T3

&lt;details&gt;
&lt;summary&gt;点击展开&lt;/summary&gt;

#### Trans

有人给了你 $n\le 4e4$ 个点，每个点的两个坐标为整数 $\in[0,5e8)$，然后让你 encode 成一个长度为 $3n$ 的整数序列，每一个值域 $[0,2e9]$。

之后这个人会把这个序列打乱还给你，让你还原出最初的 $n$ 个点的坐标，注意 $n$ 个点之间的顺序无关紧要。 

#### Sol

我们大体的思路为：$n$ 个值存 $X$ 坐标（末尾两个二进制位存 10，然后 $4\times 5e8$ 正好 $2e9$），同理 $n$ 个存 $Y$（末尾 11），然后存一个 $n$ 的排列 $\{p\}$，使得 $X$ 坐标第 $i$ 小的对应 $Y$ 坐标第 $p_i$ 小的构成一个点。

前面的 $X,Y$ 存起来没有问题，但是最后排列的值域会达到 $2\times 4e4\times 4e4=3.2e9&gt;2e9$（末尾标识符 0，$i$ 下标，$p_i$ 的值）。

我们发现我们其实浪费了信息资源，因为这样 $3.2e9$ 我们甚至可以存一个 $n$ 长度值域 $[1,n]$ 的整数序列了，所以有排列的性质我们没有用到。

对了！
$$0+1+2+\dots+(n-1)=\frac{n(n-1)}{2}&lt;1e9$$

所以再加上占位符也不超过 $2e9$。

所以我们对 $\{p\}$ 求一个前缀和 $\{q\}$，这样 $\{q\}$ 一定是单调不减的。

所以我们直接存 $\{q\}$ 加占位符即可，最后将乱序的 $\{q\}$ 排序后差分即得到 $\{p\}$，问题就迎刃而解。

#### Code

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
#include"treasure.h"
using namespace std;
#define vi vector&lt;int&gt;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define pb emplace_back
#define mkp make_pair
#define fir first
#define sec second
struct node{int x,y,rk;};
bool cmp (node x,node y){return x.x&lt;y.x;}
bool cmp2(node x,node y){return x.y&lt;y.y;}
int n;
vi encode(vi X,vi Y){
	vi res,p;
	vector&lt;node&gt; v;
	n=X.size();
	For(i,0,n-1) v.pb((node){X[i],Y[i],0});
	sort(v.begin(),v.end(),cmp2);
	For(i,0,n-1) v[i].rk=i;
	sort(v.begin(),v.end(),cmp);
	For(i,0,n-1) p.pb(v[i].rk);
	For(i,0,n-1) res.pb(1+4*X[i]);
	For(i,0,n-1) res.pb(3+4*Y[i]);
	For(i,1,n-1) p[i]+=p[i-1];
	For(i,0,n-1) res.pb(2*p[i]);
	return res;
}
vi decode(vi w){
	n=w.size()/3;
	vi X,Y,res,p;
	for(int i:w){
		if(i&amp;1){
			if(i&amp;2) Y.pb(i&gt;&gt;2);
			else X.pb(i&gt;&gt;2);
		}else{
			p.pb(i&gt;&gt;1);
		}
	}
	sort(X.begin(),X.end());
	sort(Y.begin(),Y.end());
	sort(p.begin(),p.end());
	Rof(i,n-1,1) p[i]-=p[i-1];
	For(i,0,n-1){
		res.pb(X[i]);
		res.pb(Y[p[i]]);
	}
	return res;
}
```
&lt;/details&gt;
&lt;/details&gt;

* * *

然后 APIO 主办方还发了衣服、袋子和牌子，感觉好好~~主要是颜色鲜艳~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220526155321474-262943953.jpg)

&gt; 我大杭二九个人就硬生生把我 rand 去和别的学校的老哥住了。什么叫铁眉笔啊。
&gt;
&gt; 不过结果论来看好像室友是 Hydrooj 站长并且认识了。感觉变成了欧皇。——wyl

宾馆和 zqs 住。

一直摸鱼，打雀魂，iwanna。

晚饭就挺好吃的，还有兰州拉面，但是全装在一盘了，味道混了。

然后做核酸：6:30 的时候超多人，7:10 的时候完全没人，直接做好。

然后问了门卫大叔，说小卖部在大门出门~~右~~左转 10m。

宾馆内有自助售货机~~卖的是老坛酸菜牛肉main~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220526191918139-1385526933.jpg)

然后 wyl 拉我们去玩狼人杀，~~然后我把wsy zqs wds拉过去了~~。

一开始他们三个蒙在鼓里。

然后就活起来了。

有一局我是预言家，然后直接选警长~~我一个新手能这样一定是真预言家~~。然后就一路开挂，直到被刀了~~最后输了~~。

再一局就我、wsy、zqs三个新手是狼，然后二中一般不相信我们是狼，而且wds是干扰选项，就开挂胜利。

22:45 了，不早了睡了，明天早上还有课。

晚上和zqs~~在谈政策~~聊太久了~~也有可能是出门玩太激动了~~，导致 0:30 才睡。

## 5.27

早上 6:45 的闹钟把我吵醒。

早饭海星，培根鸡蛋薯条~~西柚汁真解油~~。

7:00 开吃吃完 7:23，这时二中一堆人才过来，但是好像自助餐被吃得不多了。

上午 3.5h 的课好无聊啊~~我打游戏+睡觉~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132815887-1661978690.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132827288-1785546885.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132834619-2131690428.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132854125-43152826.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132859573-1440194346.jpg)

本来台下安静的~~，但是 djq 不会控场~~，后面大家吵起来了 a bit。

旁边一位看起来文静的教练也是进行的一个骂，然后主动和我说：

&gt; djq 讲的，会的人听得懂，不会的人还是听不懂。

其实我觉得 djq 讲得确实不算差，但是口音比较 naive，而且设备的问题~~不会用 PPT、记事本~~，然后讲各种计数+卷积+多项式exp/ln，听得云里雾里。

&gt; 为啥我对多项式一窍不通啊——我 &amp; 5ab

然后 djq 感觉就是纯理论人，不太会啥电脑软件。

于是不用 PPT，直接手写 latex 在记事本上给我们看。

体会一下，一整节课都是这样的东西：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132842567-1707458654.jpg)

评价：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132214174-862459704.png)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132223040-1835115810.png)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132235630-1921914856.png)

好吧，上午就这样浑浑噩噩过去了。

看了一眼之后的讲义，比 djq 的友好太多了，心里有了安慰。

ez 的说下午的集合幂级数就集体不去了，因为lj讲过。

然后吃了午饭做了核酸，还算快。

由于明天比赛大概率会饿，我去小卖部买了点~~旺仔QQ糖（和wsy wds zqs分了吃）~~充饥的东西。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527132944919-1552940099.jpg)

然后我发现没有房卡上不去了，我想着先蹭到 6 楼再上 8 楼，谁想到~~我个笨蛋~~连个楼梯都找不到，只能回 1 楼叫 wsy 把我带上来。

所有人都知道了，但是不知道去哪里：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527134402711-2111952450.png)

下午讲 FWT，还好大致懂了~~但是代码绝对不会写~~。

不过讲例题的时候还是云里雾里的，咱就是说不要把自己定义的记号和一般化的记号搞混啊。

一天下来被多项式折磨死。

&gt; 做多项式题就像嗑药——pinkrabbit

啥多项式 exp ln inv pow 都不会。

~~我是不会说下午的课 wsy wds 在麦块屠龙的。~~

xmc 的赞赏：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204116473-1544386193.png)

摸鱼的时候看房卡，发现：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527203431916-2047258760.png)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527203619175-964248473.png)

~~@侃哥侃英语 人 类 低 质 量 翻 译 鉴 赏（9）~~

&gt; 饭非常好评。自助餐能吃饱还挺好吃。——wyl

晚饭吃了真假羊肉串：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204319118-2044528945.png)

我、wyl、wwc、wxw、wn、xay、yzc、xyr、zty、tyq 几个甚至偷闲玩了一局狼人杀，可刺激了。

当时十一人局，我及wwc、yzc、xyr是狼，然后预言家、女巫、骑士、守卫、警长。

一开始 wwc 当警长被 xay 骑士戳死了 qwq。

然后因为 yzc新手一直笑~~场外~~，xyr 当时力挺 wwc，然后两晚死三狼。

就剩我了，还有 6 个好人。

然后我就一点一点~~攻于心计~~挑拨离间，他们也看我小白，就没太怀疑我。

六杀，太爽了。

晚上开幕式，信息量巨大。

开局先随机抽了几个幸运儿上台演讲。

然后放了一个关于准备工作和入场的 VCR~~有 wyl 入住做核酸的三个角度特写/ww~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204509789-2032652629.jpg)

甚至还有舞蹈和萨克斯~~才艺晚会~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204526268-1811101938.jpg)

之后让本校（南京外国语学校）的[孙悠然](https://bytew.net/OIer/?query=UID47537)女~~同学~~大佬演讲。

最后就是重~~（物理）~~头戏——dzd（杜子德）教授。

&lt;details&gt;
&lt;summary&gt;简介&lt;/summary&gt;

1984年至1996年，于中科院计算所从事研究工作；

1996年9月至2004年3月，任中国计算机学会专职副秘书长；

1998年5月，创建中国计算机学会青年计算机科技论坛 YOCSEF；

1998年起，负责全国青少年信息学奥林匹克竞赛 NOI，任竞赛委员会主席。成功策划和组织由中国主办的2000国际信息学奥林匹克竞赛(IOI 2000)，任执行委员会主席；

2004年4月至2021年3月，任中国计算机学会秘书长；

2005年被选举为首任IOI主席；

2006年被中科院计算所聘为研究员；

2021年3月起任香港中文大学（深圳）校长顾问；

2021年9月起任深圳市人工智能与机器人研究院执行院长。
&lt;/details&gt;

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204541325-1051032902.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204534850-1337609029.jpg)

然后由于话筒不好+本身特有的口音，非常滑稽。

当然听得清楚的话也非凡：

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527210436479-2108358244.png)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527210506384-28230656.png)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527210549830-1503885703.png)

[~~指代码中存在暴戾性语言选手禁赛一年~~](https://www.zhihu.com/question/503464471)

开幕式时正好领了密码条。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204335181-1262481272.jpg)

~~关于密码条没有密码这回事。~~

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220527204415677-515030334.jpg)

我爸发了去年初二~~选手~~大佬们的成绩，ssfd。

wyl 传来话：lj 让我们认真对待，好好考。

## 5.28

昨天又睡晚了，感觉考试不妙。

匆匆吃了早饭，然后去一楼牡~~M~~丹~~D~~厅试机。

lj给我买了尖叫，感谢~~虽然后面发现水随便拿~~。

发现是 **NOI Linux 系统**！！！连 Dev 都没，能用的只有 VSCode 和 CodeBlock，心态一崩。

然后我去尝试 VSCode，根本不会，同 wsyear 转向 CodeBlock。

Sleep 键就在 Backspace 上面，按到不止一次了，强制拆除~~拆按键能手~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530000049948-950413570.jpg)

这时 dzd 来观摩了，我们鼓掌欢迎。

发现 CodeBlock 和 Dev 挺像的，好像没有想象中的那么不顺。

然后开始狂打缺省源。

开考了，结果同时埃及主办方的服务器崩了，最后是技术发 ftp pdf 题面，此时已经 20min 了，心态二崩。

然后发现我昨天好像吃坏了，出去闹肚子了，心态三崩。

终于能好好写题了。

T1 一眼就蒙，好像 practice T3 信息压缩传递题。

T2 发现暴力超好写 $O(m+nk)$ 拿了 $60$ 跑路。

T3 感觉是全场最简单的，稍微想了想 91.36 就满足了直接润。

「哈哈哈 150 多，我好强！」——当时的自信

然后又去想 T1，推了 1h 验证是正解就开始打。

打打打打交了两发 WA 了。

然后我的代码就是冗长，加上 CodeBlock bzd咋调试，APIO 独特的交互方式，直接肉眼调。

最后一发交了评测机 queue 能绕地球。

属实是 API![O](https://cms.apio2022.org/static/loading.gif) 赛制了。

总共去厕所了 $6$ 次~~监考都惊呆了！~~

赛后发现宝玲了 /ll，心态四崩。

然后就一直玩狼人杀，晚上的 OI 活动也没去~~ez的说就是国家队答疑，还在隔壁房间打雀呢~~。

## 5.29

早起抢饭。

lxl 讲课，我是一点都没听懂，问了一圈 ez 的~~他们说本来懂的，结果现在不会了~~。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530001628022-498289950.jpg)

然后中间 dzd 混入~~看到我们在玩[IO游戏](https://generals.io/)~~，这时主持人直接欢迎，网线那头的 lxl 都懵了。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530001615242-384150385.jpg)

中间 lxl 接外卖电话+水群，xswl。

中午 lj 带我们吃小龙虾/se。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530000035025-607439296.jpg)

$10$ 人 $20$ 斤+各种副菜。

再次感谢 lj。

然后下午我们就摸鱼玩狼人杀，没去听 NP-hard。~~其实 wn 去听了回来评价太理论+偏+不考。~~

xay 还穿了 bmh 短袖，非常有亲切感~~但是把校徽拆了~~。

&gt; 修宝！我的修宝！——ez人的蜜汁行为（？）

有必要狼人杀单独出一章了。

闭幕式不去了，听说是各省表演~~文艺晚会就真的只是唱歌~~。

然后就整理东西润了ahahaha。

车上甚至还在玩狼人杀（双身份）。

lj 说让我学学 yzc（coding）。

~~车上知道了 lj 的男孩小学了。~~

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530124240041-1012284125.png)

回程为啥这么快啊，只要 2h。

回杭州了，悲喜交加。

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530002417871-1469054695.jpg)

![](https://img2022.cnblogs.com/blog/2213867/202205/2213867-20220530002423790-167798955.jpg)

（↑既然 zty 空间里放我照片那我也不客气了哈）

$$
\boxed{\large
\color{blue}{\huge\mathcal{A}}
\text{sia-}
\color{red}{\huge\mathcal{P}}
\text{acific }
\color{yellow}{\huge\mathcal{I}}
\text{nformatics }
\color{green}{\huge\mathcal{O}}\text{lympiad 2022}
\\
\color{grey}{\mathtt{Goodbye}}
}
$$

## 认识的人 + 新认识的

wdssean wsyear daniel

wn wyl wxw wwc xyr yjj zty xay yzc

tyq fkq（PrincessQi）why（缩写，不是英文） szh xze（Macesuted）

## 狼人杀

转自 wyl：

一群萌新 xjb 打。全是血压操作。节目效果太好了记一下。

### R1

A（真预）：我是真预，我金水 B。

B（好人，A 右手第一个）：我不是预言家，我觉得 A 给我发的金水有问题，出他。

### R2

A（萌新，狼人，晚上）：哈哈哈哈哈哈哈哈哈。

然后第二天被盲出了。

### R3

场上还剩三个人。警长一民一狼。

民和狼对了个眼神把整场的警长冲了。

### R4

狼美板子第一晚死了三个人。分别是预言家女巫平民。

怎么回事呢？

原来是狼人刀了预言家。女巫私人恩怨把狼美毒了带走了平民没交药。

直接把预言家气了个半死。第二晚女巫被刀了还自救不了。

关键这把后面狼人还犯病给好人赢了。太神奇了。

### R5

丘比特三狼局 A（非恋狼人）第一晚自刀骗银水。

上警成功后第二晚接着自刀被守卫守了。

这时候两个狼队友被连起来吃毒了。

第三晚，接着自刀，把自己刀死了。

### R6

（一个近似白狼骑的板）

A（白痴）：我是石像鬼，我昨天摸了 B（法官）是个守墓人，哦，我还是女巫，我昨天银水 C，哦哦不对，我是预言家我查杀 C，对的对的。

于是从今以后跳白痴都这么干。

## 收获

~~并没有听懂啥课。~~

~~APIO比赛并没有打好。~~

学会了狼人杀。

面基了ez的人。

认识了外校的（结果发现是 Luogu 熟人）。

## APIO 三道题题解

Emmm 考虑了一下还是直接等 Luogu 的题解吧。

完结撒花。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16298364.html</id>
    <title type="text">PKUSC2022-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-22T09:10:00Z</published>
    <updated>2022-05-22T09:10:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16298364.html" />
    <content type="text">&gt; 总结：分很低但是很爽。——wyl

## Day0

匆匆准备各种配置啥的，新学的文件 MD5 hash。

还好我家有两个~~简陋垃圾￥9.9~~轻便的三角手机架哈哈哈太方便了。

## Day1

上午讲座近一半在讲北大招生啥的，boring~~于是抛给家长~~。

然后测试环境，发现就我在傻呆呆地搞各种问题，别人都在写比赛 OJ 上的测试题：

&gt; 给一个 $n\times n$ 的矩阵，每次变换每个位置同时操作：将这个位置的值改为这行和这列的元素的和。求 $T$（很大）次操作后矩阵。

发现这就是一个矩阵快速幂（当然不是这个原矩阵）或类似斐波那契递推一样的东西，$\log$ 复杂度的。然后就写啊写，写完发现 11 点多了，交不了了 qwq。

后来拿给 wdssean 对拍了一下，发现好像写错了（？），反正无所谓了，下午才是重头戏。

然后下午就是兴致勃勃地开题，每道题都以为还好后来发现假了。

T1 一看就是 ex 的概率 DP。然后乱搞没搞过，写了两大张草稿纸无果。最后拿了 $m=1$ 的部分分。

赛后发现 wsyear 等人去搞小数据的部分分无果，心里平衡好多。

wyl 起来随机游走被监考哥哥警告了。

T2 写了 1h 的 $O(nm)$ 暴力发现被卡精度了，md 题目要 $10^{-10}$ 我卡半天只到 $10^{-9}$，我想着只能写高精了，abandon。

赛后发现就我被卡精度，好难受啊啊啊~~把出题人刀了~~。

wxw（2h AKer） 赛后说是扫描线板子+平衡树（还说甚至不用平衡树），然后丢给我一个 [P6106 [Ynoi2010] Self Adjusting Top Tree](https://www.luogu.com.cn/problem/P6106)。

T3 一看就列一个方程把 $n=2$ 解决了，然后发现好像就是个线性规划？不会写，abandon。

最后在坐牢，受不了了直接提前交卷。

晚上才知道好像 T3 用网络流能骗好多分，可惜了。

晚上在上课，正好在讲网络流建模，md 杀人猪心。

## Day2

早上 10 点多起。

突然感觉拿身份证大喊自己名字就像一个↑↓。

T1 又 tm 是概率 DP！！！我当时又猛列两页柿子无果/fn。

T2 看起来像淀粉质？先鸽着。

T3 md 麻将题（题目名就叫雀圣，我不说是哪款游戏）看起来好 ex，也跳过。

然后 T2T3 反复横跳了一会，发现 T3 其实还好。我就写了个最暴力的 $O(n^3)$（$n=3\times 9=27$ 牌数）判听牌，然后外层 $O(n^2)$ 可以判一次摸牌。

然后拿到 25pts，我以为就是极限了。然后再判一次摸牌 $O(n^7)$，跑过 sub3 拿到 50pts！！！！！！！！！！！机子太牛了（或是说我的听牌写的快？剪枝多？）

$n^7=10,460,353,203$

&gt; 老师你麻将打的还不够多。——wyl

然后发现 T2 的 sub1 直接 $O(n^2m)$ 能过就写了个类似暴力的玩意。

现在 T1 最早开的一分没有/qd，然后写了个 sub1 滚粗（其实发现之前题目理解错了，公式白推了 qwq）。

然后又不想坐牢，提前退了。

总分 21+0+12+6+9+50=98，两位数 qwq wtcl。 

为啥两位数的分数会被 gzw 鼓励啊qwq。

晚上听讲评。

反正就是大受震撼。

D1T1 反正是炒鸡复杂的概率 DP（qwq 我要是想到正解我也不一定能过），个人觉得能拿 m=1 的部分不错了 qwq。

D1T2 [原题](https://www.luogu.com.cn/problem/P6106)

D1T3 发现我的二分图（或最大流）的想法是对的，但是最后还要 Hall 引理的加持，最后化成了简单柿子 qwq。

D2T1 qwq 反正是爆难的图计数，还要斯特林数 awa，标算是 $O(n^6)$ 的卷积，但是好像 $n$ 的拆分数也能过。

D2T2 woc 标算是随机化算法。我们放后面好好讲讲。

D2T3 jry说可以证明原问题的答案必然 $\le 5$。然后就是动态规划（类似前多少张牌再合上后面的某些要替换多少能组成有无雀头的牌）。然后说优秀的剪枝搜索有可能过 qwq。

**D2T2 sol：**

题目：

给一棵树，边有颜色。

定义一个路径合法为：路径上的颜色只在这个路径上出现。

独立询问 $m$ 次，每次给一个点，询问不经过这个点的合法路径的最大长度。

解答：

对于每一种颜色，给该颜色的边随机权值，使得这些边权异或和为 $0$。

当随机的权值值域约 $10^{18}$ 时，以高概率，一条路径合法等价于路径异或和为 $0$。

定根为 $1$。

记 $v_i$ 为路径 $1\leftrightarrow i$ 的边权异或和，则路径 $x\leftrightarrow y$ 合法以高概率等价于 $v_x=v_y$。

然后先 $O(n\log n)$ 把全局的最长合法路径求出来，设为 $P$。

设询问的点为 $x$。若 $x$ 不在 $P$ 上，则答案就为 $P$ 的长度。

否则，我们 $O(n\log n)$ 预处理出路径（拉成水平）前缀和后缀的合法路径最大值，询问 $O(1)$ 即可。

两处单 $\log$ 其实可以双 $\log$ 的启发式合并也行。

[jry讲解视频（我录的qwq）](https://www.bilibili.com/video/BV1JB4y1R7AP)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16309367.html</id>
    <title type="text">线段树分治-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-05-25T07:09:00Z</published>
    <updated>2022-05-25T07:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16309367.html" />
    <content type="text">~~Emm 不知道讲啥~~算了直接放例题。

### CF1681F Unique Occurrences

&gt; 给定一个 $n$ 个结点的树，每条边有一个颜色，记 $f(x,y)$ 表示结点 $x$ 到 $y$ 的路径上只出现了一次的颜色的数量，求 $\sum\limits_{x &lt; y}f(x, y)$。数据保证 $n \le 5 \times 10^5$。

如果现在考虑颜色 $w$，那么删去所有该颜色的边，求得剩下每个连通块的大小，那么每条颜色 $w$ 的边的贡献就是两端连通块大小的乘积。这个过程可以通过**线段树分治+带撤销并查集**快速维护。

$O(n\log^2 n)$

具体地，我们将每一种颜色看作数组中的下标，构建线段树。

若有一条 $(x,y)$ 颜色为 $z$ 的边，那线段树 $[1,z-1]$ 及 $[z+1,n]$ 区间 push_back 这条 $(x,y)$ 边，表示在算这些颜色的贡献的时候这条边会被算进并参与并查集。

然后就线段树直接 DFS，一路下来维护并查集，然后到叶子的时候统计贡献，回去的时候记得撤销。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define pi pair&lt;int,int&gt;
#define N 500010
#define pb emplace_back
#define mid ((l+r)&gt;&gt;1)
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
#define fir first
#define sec second
#define mkp make_pair
int n,ans=0,f[N],sz[N];
vector&lt;pi&gt; e[N],g[N&lt;&lt;2];
inline int gf(int x){return x==f[x]?x:gf(f[x]);}//no path-zip
void add(int rt,int l,int r,int x,int y,pi z){
	if(l==x &amp;&amp; r==y){
		g[rt].pb(z);
		return ;
	}
	if(y&lt;=mid) add(ls,l,mid,x,y,z);
	else if(x&gt;mid) add(rs,mid+1,r,x,y,z);
	else add(ls,l,mid,x,mid,z),add(rs,mid+1,r,mid+1,y,z);
}
int del[N],tot=0;
inline void merge(int x,int y){
	x=gf(x);y=gf(y);
	if(sz[x]&lt;sz[y]) swap(x,y);
	sz[x]+=sz[y];
	f[y]=x;
	del[++tot]=y;
}
inline void antimerge(){
	int x=del[tot];
	sz[f[x]]-=sz[x];
	f[x]=x;
	tot--;
}
void work(int rt,int l,int r){
	int re=tot;
	for(auto i:g[rt]) merge(i.fir,i.sec);
	if(l==r){
		for(auto i:e[l]) ans+=sz[gf(i.fir)]*sz[gf(i.sec)];
	}else{
		work(ls,l,mid);
		work(rs,mid+1,r);
	}
	while(tot&gt;re) antimerge();
}
signed main(){IOS;
	cin&gt;&gt;n;
	For(i,1,n) f[i]=i;
	For(i,1,n) sz[i]=1;
	int x,y,z;
	For(i,1,n-1){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
		e[z].pb(mkp(x,y));
		if(z&gt;1) add(1,1,n,1,z-1,mkp(x,y));
		if(z&lt;n) add(1,1,n,z+1,n,mkp(x,y));
	}
	work(1,1,n);
	cout&lt;&lt;ans&lt;&lt;endl; 
	return 0;
}
```
&lt;/details&gt;

### CF1680F Lenient Vertex Cover

&gt; 求一个 $n$ 个点、$m$ 条边的无向连通图是否能够删掉仅一条边后成为二分图（或者本身就是）。

这里官方是 $O(n)$ 做法，但是 $O(n\log^2 n)$ 也能卡过~~对吧~~。

[我的题解](https://www.luogu.com.cn/blog/101868/solution-cf1680f)

### CF1442D Sum

&gt; 给定 $n$ 个**不降**的数组。有一个值 $ans$，初始为 $0$。你需要进行如下操作 $k$ 次：
&gt;
&gt; 选择一个数组，把 $ans$ 加上数组的第一个元素，之后把它删除。
&gt;
&gt; 请求出 $ans$ 的最大值。
&gt;
&gt; 所有数组的元素总个数 $\leq 10^6,n,k\leq 3000$

先要有一个**结论**：**最多有一个数组没有被取完。**（大佬们可能能手玩出来）

当然证明和理解都不难，略。

我们考虑分治这个没有取完的是哪个数组。

除了这个数组，其它都可以看作单件物品，和 **$01$ 背包**相同。

最后再和这个特殊的数组合并一下即可。

时间复杂度 $O(nk\log n)$

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) 
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define pi pair&lt;int,int&gt;
#define N 3030
#define mkp make_pair
#define fir first
#define sec second
#define pb emplace_back
#define vi vector&lt;int&gt;
#define ckmx(a,b) a=max(a,b)
vi v[N],f;
int sum[N],sz[N],ans=0,n,k;
void work(int l,int r){
	if(l==r){
		int x=0,y=0;
		for(int i:v[l]){
			y++;x+=i;
			if(y&gt;k) break;
			ckmx(ans,f[k-y]+x);
		}
		return ;
	}
	int mid=(l+r)&gt;&gt;1;
	vi re=f;
	For(i,mid+1,r)
		Rof(j,k,sz[i])
			ckmx(f[j],f[j-sz[i]]+sum[i]);
	work(l,mid);
	f=re;
	For(i,l,mid)
		Rof(j,k,sz[i])
			ckmx(f[j],f[j-sz[i]]+sum[i]);
	work(mid+1,r);
}
signed main(){IOS;
	cin&gt;&gt;n&gt;&gt;k;
	For(i,0,k) f.pb(0); 
	int x,y;
	For(i,1,n){
		cin&gt;&gt;x;
		sz[i]=x;
		while(x--){
			cin&gt;&gt;y;
			v[i].pb(y);
			sum[i]+=y;
		}
	} 
	work(1,n);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
```
&lt;/details&gt;

### P5787 二分图 /【模板】线段树分治

就是模板，按时间分治，不再赘述。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16332612.html</id>
    <title type="text">偷家糕首-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-08T05:18:00Z</published>
    <updated>2022-08-08T05:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16332612.html" />
    <content type="text">&lt;https://generals.io/replays/SaD9llJOj&gt; &lt;- 这个太夸张了

&lt;https://generals.io/replays/HnTWLUJRq&gt;

&lt;https://generals.io/replays/St6zrI1R5&gt;

&lt;https://generals.io/replays/BabHVI10c&gt;

&lt;https://generals.io/replays/HsCM-I10c&gt;

&lt;https://generals.io/replays/B3GmszCp9&gt;

&lt;https://generals.io/replays/Sdsi5fATq&gt;

&lt;https://generals.io/replays/Ba1rEz0p9&gt;

&lt;https://generals.io/replays/HFCdBfA6q&gt;

&lt;https://generals.io/replays/r31ULfCa9&gt;

&lt;https://generals.io/replays/B_eEwfR6q&gt;

&lt;https://generals.io/replays/B075PGAaq&gt;

&lt;https://generals.io/replays/S3T4_zR6q&gt;

&lt;https://generals.io/replays/H270OMA6q&gt;

&lt;https://generals.io/replays/r5GIgGcTq&gt;

&lt;https://generals.io/replays/SnSqBMcpc&gt;

&lt;https://generals.io/replays/HtNm8f5pc&gt;

&lt;https://generals.io/replays/HKajwf5ac&gt;

&lt;https://generals.io/replays/BOGLdzcT9&gt;

&lt;https://generals.io/replays/HhfCOz569&gt;

&lt;https://generals.io/replays/S2l0hzc6q&gt;

&lt;https://generals.io/replays/rioqemq65&gt;

&lt;https://generals.io/replays/HisfLZKTc&gt;

&lt;https://generals.io/replays/H2G4Kbtac&gt;

&lt;https://generals.io/replays/HtcwVqypq&gt;

&lt;https://generals.io/replays/rja21cka5&gt;

&lt;https://generals.io/replays/H_e5Z91p9&gt;

&lt;https://generals.io/replays/BFEl75kaq&gt;

&lt;https://generals.io/replays/HKJS7c1p9&gt;

&lt;https://generals.io/replays/HtcwVqypq&gt;

&lt;https://generals.io/replays/rsI_TYJpc&gt;

&lt;https://generals.io/replays/SO2WCFJpc&gt;

&lt;https://generals.io/replays/BhGgkcJTc&gt;

&lt;https://generals.io/replays/rT0UCep2c&gt;

&lt;https://generals.io/replays/HokZ1isnq&gt;

&lt;https://generals.io/replays/BFY569s3c&gt;

&lt;https://generals.io/replays/rAcHoCwnq&gt;

&lt;https://generals.io/replays/S3PACAPh5&gt;

&lt;https://generals.io/replays/rnU2y1_3c&gt;

&lt;https://generals.io/replays/BYMaxy_h5&gt;

&lt;https://generals.io/replays/B3u4MJd39&gt;

&lt;https://generals.io/replays/rTfY7J_h9&gt;

&lt;https://generals.io/replays/BjbXryunq&gt;

&lt;https://generals.io/replays/S0JQ8y_n5&gt;

&lt;https://generals.io/replays/Su2uPCP39&gt;

&lt;https://generals.io/replays/rKQTBCw3c&gt;

&lt;https://generals.io/replays/rhJyECD2q&gt;

&lt;https://generals.io/replays/HnHPIoQO9&gt;

&lt;https://generals.io/replays/H0VfNs7uc&gt;

&lt;https://generals.io/replays/Htagms7O5&gt;

&lt;https://generals.io/replays/BCNoFFQ_5&gt;

&lt;https://generals.io/replays/Spy8eVROq&gt;

&lt;https://generals.io/replays/rdExRgV99&gt;

&lt;https://generals.io/replays/rKwDeMB29&gt;

&lt;https://generals.io/replays/SYnIr5U3q&gt;

&lt;https://generals.io/replays/S9_wvsw25&gt;

&lt;https://generals.io/replays/SRibV59h9&gt;

&lt;https://generals.io/replays/ScjcLqqnc&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16345539.html</id>
    <title type="text">重修 LGV-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-05T15:10:00Z</published>
    <updated>2022-06-05T15:10:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16345539.html" />
    <content type="text">[OI wiki](https://oi-wiki.org/graph/lgv/)

一般用于不相交路径计数。

![](https://img2022.cnblogs.com/blog/2213867/202206/2213867-20220605230000402-792020113.png)

![](https://img2022.cnblogs.com/blog/2213867/202206/2213867-20220605225919458-914125643.png)

发现好像例题不多。

## P6657 【模板】LGV 引理

&gt; 有一个 $n\times n$ 的棋盘，左下角为 $(1,1)$，右上角为 $(n,n)$，若一个棋子在点 $(x,y)$，那么走一步只能走到 $(x+1,y)$ 或 $(x,y+1)$。
&gt; 
&gt; 现在有 $m$ 个棋子，第 $i$ 个棋子一开始放在 $(a_i,1)$，最终要走到 $(b_i,n)$。问有多少种方案，使得每个棋子都能从起点走到终点，且对于所有棋子，走过路径上的点互不相交。输出方案数 $\bmod\ 998244353$ 的值。
&gt;
&gt; 两种方案不同当且仅当存在至少一个棋子所经过的点不同。

就是模板题。

发现只有 $a_i\to b_i$ 一一对应才有可能，所以直接行列式求值即为答案。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(false)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define ll long long
const ll mod=998244353;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
inline void mad(ll &amp;a,ll b){a=(a+b)%mod;while(a&lt;0)a+=mod;}
inline void mmu(ll &amp;a,ll b){a=(a*b)%mod;while(a&lt;0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N 2000010
#define M 103
int f[N],ivf[N];
void init(){
	f[0]=1;
	For(i,1,N-1) f[i]=f[i-1]*i%mod;
	ivf[N-1]=inv(f[N-1]);
	Rof(i,N-1,1) ivf[i-1]=ivf[i]*i%mod;
}
inline int C(int x,int y){
	return f[x]*ivf[y]%mod*ivf[x-y]%mod;
}
int a[M][M],n,m,A[M],B[M];
bool flag;
inline void swa(int x,int y){
	flag^=1;
	For(i,1,m) swap(a[i][x],a[i][y]);
}
int Det(){//行列式求值模板 P7112
	flag=0;
	int tmp=0;
	For(i,1,m) For(j,i+1,m){
		while(a[i][j]){
			tmp=a[i][i]/a[i][j];
			For(k,1,m) mad(a[k][i],-a[k][j]*tmp);
			swa(i,j);
		}
	}
	int ans=1;
	For(i,1,m) mmu(ans,a[i][i]);
	return flag?(mod-ans)%mod:ans;
}
void work(){
	cin&gt;&gt;n&gt;&gt;m;
	For(i,1,m) cin&gt;&gt;A[i]&gt;&gt;B[i];
	For(i,1,m) For(j,1,m) a[i][j]=(A[i]&lt;=B[j]?C(n-1+B[j]-A[i],n-1):0);
	cout&lt;&lt;Det()&lt;&lt;endl;
}
int32_t main(){IOS;
	init();
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## CF348D Turtles

&gt; 有一个 $n\times m$ 的棋盘，其中某些格子可走，某些格子不可走。有两只海龟只能向下或向右走，求海龟从 $(1,1)$ 到 $(n,m)$ 路径**不相交**（除起点终点）的方案数取模之后的结果。
&gt;
&gt; $2\le n,m\le 3000$

相当于一只从 $(2,1)$ 走到 $(n,m-1)$，另一只 $(1,2)$ 走到 $(n-1,m)$，反过来的话必定交叉。

所以我们

![](https://img2022.cnblogs.com/blog/2213867/202206/2213867-20220605230543192-1335310890.png)

求完行列式即为答案（$f$ 的值 $O(nm)$ DP 求）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16353020.html</id>
    <title type="text">重修 CDQ 分治-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-07T11:13:00Z</published>
    <updated>2022-06-07T11:13:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16353020.html" />
    <content type="text"># 简介

**把动态问题转化为静态问题。**

&gt; **静态问题：**没有修改操作的问题，或者所有查询操作都在修改操作之后的问题
&gt; 
&gt; **动态问题：**修改和查询操作交叉的问题

$$\large{动态问题\xrightarrow{CDQ}静态问题+\log\uparrow}$$

# 例题

## P3810 【模板】三维偏序（陌上花开）

就是个模板。

## P4390 [BOI2007]Mokia 摩基亚

我们按照时间分治 $solve(l,r)$：

1. 先 $solve(l,mid)$，因为时间无后效性。

2. 再计算 $[l,mid]$ 的加点操作给 $[mid+1,r]$ 的贡献。

3. 最后，由于 $[l,mid]$ 对 $[mid+1,r]$ 的贡献已经算完，直接放心 $solve(mid+1,r)$。

所以这层分治之内唯一要解决的就是第二步。

求矩形和可以二维差分转化为四个 2-sides 矩形。

所以这道题可转化为静态问题：

&gt; 给定平面上的一些点（带点权）和一些询问，每次询问需回答在一个坐标左下角的点权和。

这可以类似扫描线解决。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(false)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define debug cerr&lt;&lt;"Passed line #"&lt;&lt;__LINE__&lt;&lt;endl
#define numlim(s) cerr&lt;&lt;numeric_limits&lt;s&gt;::min()&lt;&lt;"~"&lt;&lt;numeric_limits&lt;s&gt;::max()&lt;&lt;endl
#define ll long long
const ll mod=1000000007;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
inline void mad(ll &amp;a,ll b){a=(a+b)%mod;while(a&lt;0)a+=mod;}
inline void mmu(ll &amp;a,ll b){a=(a*b)%mod;while(a&lt;0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N 170010
#define V 2000001
#define low (x&amp;(-x))
int n=0,lim,ans[N],c[V],buf[V],tot=0;
bool vis[V];
inline void add(int x,int y){
	while(x&lt;=lim){
		c[x]+=y;
		if(!vis[x]){
			vis[x]=1;
			buf[++tot]=x;
		}
		x+=low;
	}
}
inline int que(int x){
	int res=0;
	while(x){
		res+=c[x];
		x-=low;
	}
	return res;
}
inline void clear(){
	int x;
	while(tot){
		x=buf[tot--];
		vis[x]=0;
		c[x]=0;
	}
}
struct Que{
	bool opt;//0 add 1 que
	int x,y,k,co;
	friend bool operator&lt;(Que x,Que y){
		if(x.x!=y.x) return x.x&lt;y.x;
		if(x.y!=y.y) return x.y&lt;y.y;
		return x.opt&lt;y.opt;
	}
}b[4*N];//询问是要 *4 的 
int bt;
struct Node{
	bool opt;
	int x,y,xx,yy,k;
}a[N];
#define mid ((l+r)&gt;&gt;1)
void work(int l,int r){
	if(l==r) return ;
	work(l,mid);
	bt=0;
	For(i,l,mid) if(!a[i].opt) b[++bt]=(Que){0,a[i].x,a[i].y,a[i].k,0};
	For(i,mid+1,r) if(a[i].opt){
		b[++bt]=(Que){1,a[i].xx ,a[i].yy ,i, 1};
		b[++bt]=(Que){1,a[i].xx ,a[i].y-1,i,-1};
		b[++bt]=(Que){1,a[i].x-1,a[i].yy ,i,-1};
		b[++bt]=(Que){1,a[i].x-1,a[i].y-1,i, 1};
	}
	sort(b+1,b+1+bt);
	For(i,1,bt)
		if(!b[i].opt) add(b[i].y,b[i].k);
		else ans[b[i].k]+=b[i].co*que(b[i].y);
	clear();
	work(mid+1,r);
}
int32_t main(){IOS;
	int x;
	cin&gt;&gt;x&gt;&gt;lim;
	while(1){
		cin&gt;&gt;x;
		if(x==3) break;
		n++;
		a[n].opt=x-1;
		if(!a[n].opt) cin&gt;&gt;a[n].x&gt;&gt;a[n].y&gt;&gt;a[n].k;
		else cin&gt;&gt;a[n].x&gt;&gt;a[n].y&gt;&gt;a[n].xx&gt;&gt;a[n].yy;
	}
	work(1,n);
	For(i,1,n) if(a[i].opt) cout&lt;&lt;ans[i]&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## P2487 [SDOI2011]拦截导弹

也类似模板，但是要算概率，直接古典概型上即可。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define IOS ios::sync_with_stdio(false)
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define Fe(x,y) for(int x=head[y];x;x=e[x].nxt)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define fin(s) freopen(s,"r",stdin)
#define fout(s) freopen(s,"w",stdout)
#define file(s) fin(s".in");fout(s".out")
#define debug cerr&lt;&lt;"Passed line #"&lt;&lt;__LINE__&lt;&lt;endl
#define numlim(s) cerr&lt;&lt;numeric_limits&lt;s&gt;::min()&lt;&lt;"~"&lt;&lt;numeric_limits&lt;s&gt;::max()&lt;&lt;endl
#define int long long
#define db double
#define N 50010
#define pi pair&lt;int,db&gt;
struct Node{
	int x,y,id;
	friend bool operator&lt;(Node x,Node y){return x.id&lt;y.id;}
}a[N];
inline bool cmp(Node x,Node y){return x.x==y.x?x.id&lt;y.id:x.x&gt;y.x;}
int n,s[N],lim,st[N],tot=0;
struct node{
	int mxlen;
	db cnt;
	void init(){mxlen=cnt=1;}
	void clear(){mxlen=-1;cnt=0;}
	friend node operator+(node x,node y){
		if(x.mxlen==y.mxlen) return (node){x.mxlen,x.cnt+y.cnt};
		else return x.mxlen&gt;y.mxlen?x:y;
	}
	friend void operator+=(node &amp;x,node y){x=x+y;}
}t[N&lt;&lt;2],f[2][N];
void lisan(){//lisan for a.y
	For(i,1,n) s[i]=a[i].y;
	sort(s+1,s+1+n);
	lim=unique(s+1,s+1+n)-s-1;
	For(i,1,n) a[i].y=lower_bound(s+1,s+1+lim,a[i].y)-s;
}
#define mid ((l+r)&gt;&gt;1)
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
void build(int rt,int l,int r){
	t[rt].clear();
	if(l==r) return ;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void add(int rt,int l,int r,int x,node val){
	if(l==r){
//		cout&lt;&lt;t[rt].mxlen&lt;&lt;" "&lt;&lt;t[rt].cnt&lt;&lt;endl;
		t[rt]+=val;
		st[++tot]=rt;
//		cout&lt;&lt;x&lt;&lt;"!"&lt;&lt;val.mxlen&lt;&lt;" "&lt;&lt;val.cnt&lt;&lt;" "&lt;&lt;t[rt].mxlen&lt;&lt;" "&lt;&lt;t[rt].cnt&lt;&lt;endl;
		return ;
	}
	if(x&lt;=mid) add(ls,l,mid,x,val);
	else add(rs,mid+1,r,x,val);
	t[rt]=t[ls]+t[rs];
}
node que(int rt,int l,int r,int x,int y){
	if(l==x &amp;&amp; r==y) return t[rt];
	if(y&lt;=mid) return que(ls,l,mid,x,y);
	else if(x&gt;mid) return que(rs,mid+1,r,x,y);
	return que(ls,l,mid,x,mid)+que(rs,mid+1,r,mid+1,y);
}
void clear(){
	int x;
	while(tot){
		x=st[tot--];
		while(x &amp;&amp; t[x].mxlen!=-1){
			t[x].clear();
			x&gt;&gt;=1;
		}
	}
}
node addlen(node x){x.mxlen++;return x;}
void solve(int l,int r){
	if(l==r) return ;
//	cout&lt;&lt;"solve "&lt;&lt;l&lt;&lt;"~"&lt;&lt;r&lt;&lt;endl;
	solve(l,mid);
	sort(a+l,a+r+1,cmp);
//	cout&lt;&lt;"mid   "&lt;&lt;l&lt;&lt;"~"&lt;&lt;r&lt;&lt;" "; For(i,l,r) cout&lt;&lt;a[i].id&lt;&lt;" "; cout&lt;&lt;endl;
	For(i,l,r)
		if(a[i].id&lt;=mid) add(1,1,lim,a[i].y,f[0][a[i].id]);
		else f[0][a[i].id]+=addlen(que(1,1,lim,a[i].y,lim));
	clear();
	sort(a+l,a+r+1);
	solve(mid+1,r);
//	cout&lt;&lt;"end   "&lt;&lt;l&lt;&lt;"~"&lt;&lt;r&lt;&lt;" "; For(i,l,r) cout&lt;&lt;f[0][i].mxlen&lt;&lt;" "; cout&lt;&lt;endl;
}
int32_t main(){IOS;
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
	lisan();
	build(1,1,lim);
	cout&lt;&lt;fixed&lt;&lt;setprecision(5);
	For(i,1,n) f[0][i].init();
	reverse(a+1,a+1+n);
	For(i,1,n) a[i].x*=-1;
	For(i,1,n) a[i].y=lim-a[i].y+1;
	For(i,1,n) a[i].id=i;
	solve(1,n);
	For(i,1,n) f[1][i]=f[0][n-i+1];
	For(i,1,n) f[0][i].init();
	reverse(a+1,a+1+n);
	For(i,1,n) a[i].x*=-1;
	For(i,1,n) a[i].y=lim-a[i].y+1;
	For(i,1,n) a[i].id=i;
//	For(i,1,n) cout&lt;&lt;a[i].x&lt;&lt;" "&lt;&lt;a[i].y&lt;&lt;" "&lt;&lt;a[i].id&lt;&lt;endl; 
	solve(1,n);
//	For(i,1,n) cout&lt;&lt;f[0][i].mxlen&lt;&lt;"&gt;"&lt;&lt;f[0][i].cnt&lt;&lt;endl; 
//	For(i,1,n) cout&lt;&lt;f[1][i].mxlen&lt;&lt;"&lt;"&lt;&lt;f[1][i].cnt&lt;&lt;endl; 
	int ans=0;
	db sum=0;
	For(i,1,n) ckmx(ans,f[0][i].mxlen); cout&lt;&lt;ans&lt;&lt;endl;
	For(i,1,n) if(f[0][i].mxlen==ans) sum+=f[0][i].cnt;
	For(i,1,n)
		if(f[0][i].mxlen+f[1][i].mxlen-1&lt;ans) cout&lt;&lt;(db)0&lt;&lt;" ";
		else cout&lt;&lt;f[0][i].cnt*f[1][i].cnt/sum&lt;&lt;" ";
	cout&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## P4169 [Violet]天使玩偶/SJY摆棋子

~~不是那个 sjy~~

发现哈密尔顿距离不好搞，我们将绝对值拆开，每次询问拆成左下左上右下右上四个子问题的最小值。

那和 P4390 [BOI2007]Mokia 摩基亚 不就类似了？

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=j;i&lt;=k;i++)
#define Rof(i,j,k) for(int i=j;i&gt;=k;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define N 600010
#define V 1000002
#define low (x&amp;(-x))
const int inf=1e7;
int c[V],buf[N],bt=0;
void add(int x,int y){
	buf[++bt]=x;
	while(x&lt;V){
		ckmx(c[x],y);
		x+=low;
	}
}
int que(int x){
	int res=0;
	while(x){
		ckmx(res,c[x]);
		x-=low;
	}
	return res;
}
void clear(){
	int x;
	while(bt){
		x=buf[bt--];
		while(x&lt;V){
			c[x]=0;
			x+=low; 
		}
	}
}
struct node{
	bool opt;
	int x,y;
}a[N];
struct Node{
	bool opt;
	int x,y,id;
	friend bool operator&lt;(Node x,Node y){return x.x!=y.x?x.x&lt;y.x:(x.y!=y.y?x.y&lt;y.y:x.opt&lt;y.opt);}
}b[N];
int n,m,f[N],tot;
void solve(int l,int r){
	if(l==r) return ;
	int x,mid=(l+r)&gt;&gt;1;
	solve(l,mid);
	tot=0;
	For(i,l,mid) if(!a[i].opt) b[++tot]=(Node){a[i].opt,a[i].x,a[i].y,i};
	For(i,mid+1,r) if(a[i].opt) b[++tot]=(Node){a[i].opt,a[i].x,a[i].y,i};
	sort(b+1,b+1+tot);
	For(i,1,tot)
		if(!b[i].opt) add(b[i].y,b[i].x+b[i].y);
		else x=que(b[i].y),ckmn(f[b[i].id],x?b[i].x+b[i].y-x:inf);
	clear();
	solve(mid+1,r);
}
int32_t main(){
	scanf("%d%d",&amp;n,&amp;m);
	For(i,1,n) scanf("%d%d",&amp;a[i].x,&amp;a[i].y);
	For(i,1,n) a[i].opt=0;
	int x;
	For(i,n+1,n+m){
		scanf("%d%d%d",&amp;x,&amp;a[i].x,&amp;a[i].y);
		a[i].opt=x-1;
	}
	n+=m; 
	For(i,1,n) a[i].x++;
	For(i,1,n) a[i].y++;
	For(i,1,n) f[i]=inf;
	solve(1,n);
	For(i,1,n) a[i].x=V+1-a[i].x;
	solve(1,n);
	For(i,1,n) a[i].y=V+1-a[i].y;
	solve(1,n);
	For(i,1,n) a[i].x=V+1-a[i].x;
	solve(1,n);
	For(i,1,n) if(a[i].opt) printf("%d\n",f[i]);
return 0;}
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16361027.html</id>
    <title type="text">重修 LCT-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-09T12:21:00Z</published>
    <updated>2022-06-09T12:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16361027.html" />
    <content type="text">## 20230302

重写了一个更美观的 LCT。

突然感觉 LCT 好写多了，不再被认为是毒瘤数据结构。

[P6664 [清华集训2016] 温暖会指引我们前行](https://www.luogu.com.cn/record/103409204)

## 20220609

Link Cut Tree 可以理解为动态的树链剖分，且链的维护是 splay。

在这之前一定要把 splay 写熟练了，不然吃大亏。

[splay 板子来这里](https://www.cnblogs.com/zhangshaojia/p/15526354.html)

[P3690 【模板】动态树（Link Cut Tree）](https://www.luogu.com.cn/problem/P3690)

[指针版 Code](https://www.luogu.com.cn/record/77087968)

~~不好意思只会写指针版的~~

写了一份非指针版的，但是不是模板题（比模板更强）：[Link](https://www.luogu.com.cn/record/85451020)

[P2147 [SDOI2008] 洞穴勘测](https://www.luogu.com.cn/problem/P2147) 首次不看任何资料自己写 LCT，耗时 28min。

[记录](https://www.luogu.com.cn/record/85464081)

教训：

* access 一定要想想要不要 splay（acsp 连招），因为 access 并不会将这个点旋到 splay 的根。

* 判祖先不要再用 `t[rt].fa` 啦！！！！（因为有虚边的存在），用 `sonty()`。

又写了一份非指针版的~~指针什么 lj，不好调还空间大~~ [P2173 [ZJOI2012]网络](https://www.luogu.com.cn/problem/P2173)

[Link](https://www.luogu.com.cn/record/85473671) 封装版的写法（带 Link Cut 改点权 和 求路径点权最大值），这道题用时 45min。

教训：

* 用 map 存的边对应颜色，但是改边颜色时忘记更新 map 了/qd。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16367154.html</id>
    <title type="text">重修 AC 自动机-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-11T15:32:00Z</published>
    <updated>2022-06-11T15:32:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16367154.html" />
    <content type="text"># 2023年3月19日

以前写的太丑了，现在重新写了一个：

[Link](https://www.luogu.com.cn/record/105264338)

稍微压缩（将 bfs 和建 ACAM 放一起）版：

[Link](https://www.luogu.com.cn/record/105264253)

# 远古

~~区别于自动 AC 机~~

以前写的太丑了，现在重新写了一个：

[P5357 【模板】AC 自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)

[指针版record](https://www.luogu.com.cn/record/77370762)

[非指针版record](https://www.luogu.com.cn/record/77371252)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16376543.html</id>
    <title type="text">重修 分散层叠算法（Fractional Cascading）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-15T11:08:00Z</published>
    <updated>2022-06-15T11:08:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16376543.html" />
    <content type="text">~~新学的知识不能算重修了吧~~

自己想到的一个类似的东西：

&gt; **顺势疗法（homeopathy）**：首先，把某种物质在酒精中浸泡几个星期，过滤浸泡液得到该物质的“母酊剂”。然后，使用一些母酊剂通过用水**反复地稀释**和强烈的摇动，得到最终的药剂。直到现在，仍然用相同的基本的基本程序来制造顺势疗法的药剂。
&gt; 
&gt; 最后得到的药剂往往**甚至不含**有原始物质的**一个分子**，正统的科学认为，这会致使药剂失去活性。
&gt; 
&gt; 生物化学博士方舟子曾撰写《“分子顺势疗法”来了》一文：
&gt; &gt; 市场上销售的顺势疗法药物常见的有用蒸馏水把药物稀释了 $10^{30}$ 的。这是什么概念呢？往海洋里滴一滴水，也不过被稀释了 $10^{26}$，也就是说，其有效成分的浓度，比沧海一粟还要低 $1$ 万倍，事实上是什么都没有。根据阿芙伽德罗定律，$1$ 摩尔的任何物质包含有大约 $10^{24}$ 个分子，也就是说，稀释到 $10^{24}$ 以后，已不可能含有被稀释的成分的一个分子，全都是水分子了。

学完后你就会发现分散层叠算法和这个过程很像~~不过不是伪科学~~。

[P6466 分散层叠算法(Fractional Cascading)](https://www.luogu.com.cn/problem/P6466)

[record](https://www.luogu.com.cn/record/77402787)

还是讲一下大体：

## 题面

&gt; 给出 $k$ 个长度为 $n$ 的**升序**数组。保证**所有数组中出现过的数不重复**（如果有的题重复，离散化即可）。
&gt; 现在有 $q$ 个查询：给出数 $x$，**分别求出每个数组**中大于等于 $x$ 的最小的数（**lower_bound**）（不存在则定义为 $0$）。
&gt; 由于不让瓶颈在 IO 上，每个查询输出 $k$ 个后继的异或和。
&gt; 还是由于不让瓶颈在 IO 上，只要编号为 $d$ 倍数的询问要输出。
&gt; **强制在线**。
&gt; $O(nk+q(k+\log n))$ 时间 $O(nk)$ 空间内解决。

## 题解

我们先设原 $k$ 个序列为 $A^{(1)},A^{(2)},\dots,A^{(k)}$。

对应地，创建 $k$ 个序列 $B^{(1)},B^{(2)},\dots,B^{(k)}$，但是每个元素实现中不只是一个 int，存有两个下标 $nxt1,nxt2$，意义后面说。

### 初始化

文中有序数组之间的 $+$ 均定义为**归并**。
$$
B^{(k)}=A^{(k)}
$$
之后 $s$ 遍历 $(k-1)\to 1$，每一步中：

$C$ 数组为 $B^{(s+1)}$ **提取偶数下标元素**得到的数组。
$$
B^{(s)}=A^{(s)}+C
$$
归并的同时 $B^{(s)}$ 中每个元素 $x$ 记录：

* $nxt1$：$x$ 在 $A^{(s)}$ 中的 lower_bound 下标。

* $nxt2$：$x$ 在 $B^{(s+1)}$ 中的 lower_bound 下标。**注意是 $B^{(s+1)}$ 而不是 $C$。**

因为
$$
\frac{\frac{\frac{\ddots}{2}+n}{2}+n}{2}+n=2n
$$
所以 $B^{(s)}$ 数组长度的上界是 $2n$，所以空间 $O(nk)$ 满足。

由于**归并是线性复杂度的**，初始化时间为 $O(nk)$。

### 询问

设询问的值在 $B^{(1)}$ 中的 lower_bound 下标为 $p$。**注意是 $B$ 而不是 $A$。**

$s$ 遍历 $1\to k$：

1. 将 $p$ 位置 $O(1)$ **微调**。（虽然这一步在 $s=1$ 无用，但后面有）

2. 设 $pos=B^{(s)}_p.nxt1$ 将 $A^{(s)}_{pos}$ 统计入答案（本题 $\text{xor}$）。

3. $p:=B^{(s)}_p.nxt2$，此时 $p$ 可能不是 $B^{(s+1)}$ 正确的 lower_bound，但是下一轮循环开始时会有微调。由于 $C$ 是 $B$ 隔位取位得来的，所以当前的 $p$ 与真正的 $p$ 之间相差不超过 $1$，所以第一步的微调 $O(1)$ 得证。

全过程记得特判 $p$ 越 $B^{(s)}$ 界的情况。

单次询问的时间复杂度是 $O(\log n+k)$（第一次 lower_bound + 后面 $k$ 次微调）

# wikipedia

&lt;https://en.wikipedia.org/wiki/Fractional_cascading&gt;

In computer science, fractional cascading is a technique to speed up a sequence of binary searches for the same value in a sequence of related data structures. The first binary search in the sequence takes a logarithmic amount of time, as is standard for binary searches, but successive searches in the sequence are faster. The original version of fractional cascading, introduced in two papers by Chazelle and Guibas in 1986 (Chazelle &amp; Guibas 1986a; Chazelle &amp; Guibas 1986b), combined the idea of cascading, originating in range searching data structures of Lueker (1978) and Willard (1978), with the idea of fractional sampling, which originated in Chazelle (1983). Later authors introduced more complex forms of fractional cascading that allow the data structure to be maintained as the data changes by a sequence of discrete insertion and deletion events.

## Example

As a simple example of fractional cascading, consider the following problem. We are given as input a collection of k ordered lists Li of numbers, such that the total length Σ|Li| of all lists is n, and must process them so that we can perform binary searches for a query value q in each of the k lists. For instance, with k = 4 and n = 17,

L1 = 24, 64, 65, 80, 93
L2 = 23, 25, 26
L3 = 13, 44, 62, 66
L4 = 11, 35, 46, 79, 81

The simplest solution to this searching problem is just to store each list separately. If we do so, the space requirement is O(n), but the time to perform a query is O(k log(n/k)), as we must perform a separate binary search in each of k lists. The worst case for querying this structure occurs when each of the k lists has equal size n/k, so each of the k binary searches involved in a query takes time O(log(n/k)).

A second solution allows faster queries at the expense of more space: we may merge all the k lists into a single big list L, and associate with each item x of L a list of the results of searching for x in each of the smaller lists Li. If we describe an element of this merged list as x[a,b,c,d] where x is the numerical value and a, b, c, and d are the positions (the first number has position 0) of the next element at least as large as x in each of the original input lists (or the position after the end of the list if no such element exists), then we would have

L = 11[0,0,0,0], 13[0,0,0,1], 23[0,0,1,1], 24[0,1,1,1], 25[1,1,1,1], 26[1,2,1,1],
35[1,3,1,1], 44[1,3,1,2], 46[1,3,2,2], 62[1,3,2,3], 64[1,3,3,3], 65[2,3,3,3],
66[3,3,3,3], 79[3,3,4,3], 80[3,3,4,4], 81[4,3,4,4], 93[4,3,4,5]

This merged solution allows a query in time O(log n + k): simply search for q in L and then report the results stored at the item x found by this search. For instance, if q = 50, searching for q in L finds the item 62[1,3,2,3], from which we return the results L1[1] = 64, L2[3] (a flag value indicating that q is past the end of L2), L3[2] = 62, and L4[3] = 79. However, this solution pays a high penalty in space complexity: it uses space O(kn) as each of the n items in L must store a list of k search results.

Fractional cascading allows this same searching problem to be solved with time and space bounds meeting the best of both worlds: query time O(log n + k), and space O(n). The fractional cascading solution is to store a new sequence of lists Mi. The final list in this sequence, Mk, is equal to Lk; each earlier list Mi is formed by merging Li with every second item from Mi+1. With each item x in this merged list, we store two numbers: the position resulting from searching for x in Li and the position resulting from searching for x in Mi+1. For the data above, this would give us the following lists:

M1 = 24[0, 1], 25[1, 1], 35[1, 3], 64[1, 5], 65[2, 5], 79[3, 5], 80[3, 6], 93[4, 6]
M2 = 23[0, 1], 25[1, 1], 26[2, 1], 35[3, 1], 62[3, 3], 79[3, 5]
M3 = 13[0, 1], 35[1, 1], 44[1, 2], 62[2, 3], 66[3, 3], 79[4, 3]
M4 = 11[0, 0], 35[1, 0], 46[2, 0], 79[3, 0], 81[4, 0]

Suppose we wish to perform a query in this structure, for q = 50. We first do a standard binary search for q in M1, finding the value 64[1,5]. The "1" in 64[1,5], tells us that the search for q in L1 should return L1[1] = 64. The "5" in 64[1,5] tells us that the approximate location of q in M2 is position 5. More precisely, binary searching for q in M2 would return either the value 79[3,5] at position 5, or the value 62[3,3] one place earlier. By comparing q to 62, and observing that it is smaller, we determine that the correct search result in M2 is 62[3,3]. The first "3" in 62[3,3] tells us that the search for q in L2 should return L2[3], a flag value meaning that q is past the end of list L2. The second "3" in 62[3,3] tells us that the approximate location of q in M3 is position 3. More precisely, binary searching for q in M3 would return either the value 62[2,3] at position 3, or the value 44[1,2] one place earlier. A comparison of q with the smaller value 44 shows us that the correct search result in M3 is 62[2,3]. The "2" in 62[2,3] tells us that the search for q in L3 should return L3[2] = 62, and the "3" in 62[2,3] tells us that the result of searching for q in M4 is either M4[3] = 79[3,0] or M4[2] = 46[2,0]; comparing q with 46 shows that the correct result is 79[3,0] and that the result of searching for q in L4 is L4[3] = 79. Thus, we have found q in each of our four lists, by doing a binary search in the single list M1 followed by a single comparison in each of the successive lists.

More generally, for any data structure of this type, we perform a query by doing a binary search for q in M1, and determining from the resulting value the position of q in L1. Then, for each i &gt; 1, we use the known position of q in Mi to find its position in Mi+1. The value associated with the position of q in Mi points to a position in Mi+1 that is either the correct result of the binary search for q in Mi+1 or is a single step away from that correct result, so stepping from i to i + 1 requires only a single comparison. Thus, the total time for a query is O(log n + k).

In our example, the fractionally cascaded lists have a total of 25 elements, less than twice that of the original input. In general, the size of Mi in this data structure is at most
$$
|L_{i}|+{\frac {1}{2}}|L_{i+1}|+{\frac {1}{4}}|L_{i+2}|+\cdots +{\frac {1}{2^{j}}}|L_{i+j}|+\cdots ,
$$
as may easily be proven by induction. Therefore, the total size of the data structure is at most
$$
\sum |M_{i}|=\sum |L_{i}|\left(1+{\frac {1}{2}}+{\frac {1}{4}}+\cdots \right)\leq 2n=O(n),
$$
as may be seen by regrouping the contributions to the total size coming from the same input list Li together with each other.

## The general problem

In general, fractional cascading begins with a catalog graph, a directed graph in which each vertex is labeled with an ordered list. A query in this data structure consists of a path in the graph and a query value q; the data structure must determine the position of q in each of the ordered lists associated with the vertices of the path. For the simple example above, the catalog graph is itself a path, with just four nodes. It is possible for later vertices in the path to be determined dynamically as part of a query, in response to the results found by the searches in earlier parts of the path.

To handle queries of this type, for a graph in which each vertex has at most d incoming and at most d outgoing edges for some constant d, the lists associated with each vertex are augmented by a fraction of the items from each outgoing neighbor of the vertex; the fraction must be chosen to be smaller than 1/d, so that the total amount by which all lists are augmented remains linear in the input size. Each item in each augmented list stores with it the position of that item in the unaugmented list stored at the same vertex, and in each of the outgoing neighboring lists. In the simple example above, d = 1, and we augmented each list with a 1/2 fraction of the neighboring items.

A query in this data structure consists of a standard binary search in the augmented list associated with the first vertex of the query path, together with simpler searches at each successive vertex of the path. If a 1/r fraction of items are used to augment the lists from each neighboring item, then each successive query result may be found within at most r steps of the position stored at the query result from the previous path vertex, and therefore may be found in constant time without having to perform a full binary search.

## Dynamic fractional cascading

In dynamic fractional cascading, the list stored at each node of the catalog graph may change dynamically, by a sequence of updates in which list items are inserted and deleted. This causes several difficulties for the data structure.

First, when an item is inserted or deleted at a node of the catalog graph, it must be placed within the augmented list associated with that node, and may cause changes to propagate to other nodes of the catalog graph. Instead of storing the augmented lists in arrays, they should be stored as binary search trees, so that these changes can be handled efficiently while still allowing binary searches of the augmented lists.

Second, an insertion or deletion may cause a change to the subset of the list associated with a node that is passed on to neighboring nodes of the catalog graph. It is no longer feasible, in the dynamic setting, for this subset to be chosen as the items at every dth position of the list, for some d, as this subset would change too drastically after every update. Rather, a technique closely related to B-trees allows the selection of a fraction of data that is guaranteed to be smaller than 1/d, with the selected items guaranteed to be spaced a constant number of positions apart in the full list, and such that an insertion or deletion into the augmented list associated with a node causes changes to propagate to other nodes for a fraction of the operations that is less than 1/d. In this way, the distribution of the data among the nodes satisfies the properties needed for the query algorithm to be fast, while guaranteeing that the average number of binary search tree operations per data insertion or deletion is constant.

Third, and most critically, the static fractional cascading data structure maintains, for each element x of the augmented list at each node of the catalog graph, the index of the result that would be obtained when searching for x among the input items from that node and among the augmented lists stored at neighboring nodes. However, this information would be too expensive to maintain in the dynamic setting. Inserting or deleting a single value x could cause the indexes stored at an unbounded number of other values to change. Instead, dynamic versions of fractional cascading maintain several data structures for each node:

* A mapping of the items in the augmented list of the node to small integers, such that the ordering of the positions in the augmented list is equivalent to the comparison ordering of the integers, and a reverse map from these integers back to the list items. The order-maintenance technique of Dietz (1982) allows this numbering to be maintained efficiently.

* An integer searching data structure such as a van Emde Boas tree for the numbers associated with the input list of the node. With this structure, and the mapping from items to integers, one can efficiently find for each element x of the augmented list, the item that would be found on searching for x in the input list.

* For each neighboring node in the catalog graph, a similar integer searching data structure for the numbers associated with the subset of the data propagated from the neighboring node. With this structure, and the mapping from items to integers, one can efficiently find for each element x of the augmented list, a position within a constant number of steps of the location of x in the augmented list associated with the neighboring node.

These data structures allow dynamic fractional cascading to be performed at a time of O(log n) per insertion or deletion, and a sequence of k binary searches following a path of length k in the catalog graph to be performed in time O(log n + k log log n).

## Applications

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230517232044670-50906080.png)

(The convex layers of a point set, part of an efficient fractionally cascaded data structure for half-plane range reporting.)

Typical applications of fractional cascading involve range search data structures in computational geometry. For example, consider the problem of half-plane range reporting: that is, intersecting a fixed set of n points with a query half-plane and listing all the points in the intersection. The problem is to structure the points in such a way that a query of this type may be answered efficiently in terms of the intersection size h. One structure that can be used for this purpose is the convex layers of the input point set, a family of nested convex polygons consisting of the convex hull of the point set and the recursively-constructed convex layers of the remaining points. Within a single layer, the points inside the query half-plane may be found by performing a binary search for the half-plane boundary line's slope among the sorted sequence of convex polygon edge slopes, leading to the polygon vertex that is inside the query half-plane and farthest from its boundary, and then sequentially searching along the polygon edges to find all other vertices inside the query half-plane. The whole half-plane range reporting problem may be solved by repeating this search procedure starting from the outermost layer and continuing inwards until reaching a layer that is disjoint from the query halfspace. Fractional cascading speeds up the successive binary searches among the sequences of polygon edge slopes in each layer, leading to a data structure for this problem with space O(n) and query time O(log n + h). The data structure may be constructed in time O(n log n) by an algorithm of Chazelle (1985). As in our example, this application involves binary searches in a linear sequence of lists (the nested sequence of the convex layers), so the catalog graph is just a path.

Another application of fractional cascading in geometric data structures concerns point location in a monotone subdivision, that is, a partition of the plane into polygons such that any vertical line intersects any polygon in at most two points. As Edelsbrunner, Guibas &amp; Stolfi (1986) showed, this problem can be solved by finding a sequence of polygonal paths that stretch from left to right across the subdivision, and binary searching for the lowest of these paths that is above the query point. Testing whether the query point is above or below one of the paths can itself be solved as a binary search problem, searching for the x coordinate of the points among the x coordinates of the path vertices to determine which path edge might be above or below the query point. Thus, each point location query can be solved as an outer layer of binary search among the paths, each step of which itself performs a binary search among x coordinates of vertices. Fractional cascading can be used to speed up the time for the inner binary searches, reducing the total time per query to O(log n) using a data structure with space O(n). In this application the catalog graph is a tree representing the possible search sequences of the outer binary search.

Beyond computational geometry, Lakshman &amp; Stiliadis (1998) and Buddhikot, Suri &amp; Waldvogel (1999) apply fractional cascading in the design of data structures for fast packet filtering in internet routers. Gao et al. (2004) use fractional cascading as a model for data distribution and retrieval in sensor networks.</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16391669.html</id>
    <title type="text">重修 Burnside &amp; Pólya（Polya）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-21T07:51:00Z</published>
    <updated>2022-06-21T07:51:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16391669.html" />
    <content type="text">长长长文警告（可能只是公式多）。

~~可能不会讲 Polya。~~

[P4980 【模板】Pólya 定理](https://www.luogu.com.cn/problem/P4980)

[本人の题解](https://www.luogu.com.cn/blog/101868/solution-p4980)

本人几年前就跟着某数学老师学了这个，但是当时我还太年轻啊 qwq，所以来重修了。

以下是个人的见解。

让我们~~荡起双桨~~翻开《组合数学引论》Page 210，也就是说，**默认你会了群论和置换**。

**这里我们用 OI 的语言来翻译：置换中的点就是每种状态（我们最终要求状态有多少种不同的等价类），置换群就是一些操作的集合，其中每种操作都会让状态转移（并且转移的形状是多个有向环），而且这些操作是传递闭包的。**

下文设 $D=\{1,\dots,n\}$（相当于给 $n$ 种状态标号），$G$ 为作用在 $D$ 上的置换群，两群间 $A\le B$ 表示 $A$ 是 $B$ 的子群。

## k-不动置换类

定义状态 $k$ 的不动置换类
$$
Z_k=\{\sigma\ |\ \sigma \in G,\sigma(k)=k\}
$$
通俗地讲，就是让 $k$ 这个状态不变（仍然是 $k$）的那些变换。

我们有
$$
k\in D\implies Z_k\le G
$$

## 等价类

定义 $k$ 和 $l$ 等价当
$$
\exists\sigma\in G\ \text{s.t.}\ \sigma(k)=l
$$
极大的一堆等价的就是等价类。

对了，一个**置换左乘**一个**置换类**为这个置换和置换类中每一个置换叠加构成的类，即
$$
\sigma \Pi=\{\sigma \pi|\pi\in\Pi\}
$$
**右乘**同理。

## (A)
$$\color{blue}{
|\sigma\Pi|=|\Pi|
}$$
假若 $\sigma\pi_1=\sigma\pi_2$，由于置换群有逆元（相当于在有向环上倒着走一步），得出 $\sigma^{-1}\sigma\pi_1=\sigma^{-1}\sigma\pi_2$，即 $\pi_1=\pi_2$。构成单射，得证。

下面我们考察一个状态 $k$，设 $|E_k|=l,E_k=\{a_1(=k),a_2,\dots,a_l\}$。

任意找 $l$ 个置换（必然有，因为在等价类里）$\{p_1,\dots,p_l\}\ \text{s.t}\ p_i(k)=a_i$。

## (B)
$$\color{blue}{
p_iZ_k\cap p_jZ_k=\emptyset\quad(i\ne j)
}$$

$p_iZ_k$ 中的任何元素都把 $k(=a_1)$ 带到 $a_i$（$Z_k$ 不让她动，$p_i$ 把她带走），而同理 $p_jZ_k$ 把 $k$ 带到 $a_j$，你说咋可能有交呢对吧。

## (C)
$$\color{blue}{
G=\cup_{i=1}^lp_iZ_k
}$$
On the one hand:
$$
p_iZ_k\in G\implies \cup_{i=1}^lp_iZ_k\in G
$$
On the other hand:

任取 $\pi\in G$ 我们只要证明她在某个 $p_iZ_k$ 即可。

由于等价类的定义，设 $\pi(k)=a_m(\in E)$，并且
$$
p_m^{-1}\pi(k)=p_m^{-1}(a_m)=k
$$

所以
$$
p_m^{-1}\pi\in Z_k
$$
即
$$
\pi\in p_mZ_k
$$
原命题得证。

## (D)
$$\color{blue}{
|E_k|\cdot|Z_k|=|G|\quad(k\in D)
}$$
由 (A)(B)(C) 可以快速得到
$$\begin{aligned}
|G|&amp;=|p_1Z_k|+|p_2Z_k|+\dots+|p_lZ_k|
\\&amp;=l\cdot|Z_k|
\\&amp;=|E_k|\cdot|Z_k|
\end{aligned}$$

## (E)
$$\color{blue}{
|Z_k|=|Z_i|\quad(j\in E_i)
}$$
由 (D)
$$
|Z_k|=|Z_i|=\frac{|G|}{|E_k|}
$$
快速证明。

当然有另一种方法：

由于 $i,k$ 等价，所以存在 $\pi(k)=i$。

由 (A)（左乘右乘）：
$$
|Z_k|=|\pi Z_k\pi^{-1}|
$$
在 $Z_k$ 中任取一项置换 $z$，则
$$
\pi z\pi^{-1}(i)=\pi z(k)=\pi (k)=i
$$
所以
$$
\pi Z_k\pi^{-1}\subseteq Z_i
\\
|\pi Z_k\pi^{-1}|\le|Z_i|
\\
|Z_k|\le|Z_i|
$$
将 $k,i$ 两项 swap 后重复上述证明过程，即得到
$$
|Z_k|\ge|Z_i|
$$
结合两式后原命题得证。

## (Burnside)
$$\color{blue}{
ans=\frac{1}{|G|}\sum_{\pi\in G}c_1(\pi)
}$$
其中 $ans$ 为 $D$ 由 $G$ 诱导出来的等价类个数，$c_1(\pi)$ 表示置换 $\pi$ 作用下保持不变的状态个数（角标 $1$ 表示长度为 $1$ 的环，因为这些状态在 $\pi$ 置换时形成自环），换一种说法
$$
c_1(\pi)=\sum_{k\in D}[\pi\in Z_k]
$$

## (Burnside Proof)

首先，
$$
ans=\sum_{k\in D}\frac{1}{|E_k|}
$$
因为这样每一个等价类对 $ans$ 的贡献均为 $1$。

而由 (D) 得到
$$\begin{aligned}
ans&amp;=\sum_{k\in D}\frac{1}{|E_k|}
\\&amp;=\sum_{k\in D}\frac{Z_k}{|G|}
\\&amp;=\frac{1}{|G|}\sum_{k\in D}Z_k
\\&amp;=\frac{1}{|G|}\sum_{\pi\in G}c_1(\pi)
\end{aligned}$$

最后一步其实是**改变了计数方式：计数「某置换不改变某状态」从状态角度转变为置换角度。**

即得证。

## 例题

就是开头给的例题。

为防止混淆，我们设珠子的颜色数为 $m$，虽然在这道题里 $=n$。

我们发现这个项链的置换群为 $\{cy_0,cy_1,cy_2,\dots,cy_{n-1}\}$ 其中 $cy_i$ 表示将项链顺时针旋转 $i$ 格。

不妨设 $cy_n=cy_0$（反正是一个东西）（为了方便接下来的 $\gcd$）。

我们先搞定 $c_1(cy_i)\quad(1\le i\le n)$。

易发现
$$
c_1(cy_i)=m^{\gcd(i,n)}
$$
也就是将链子每 $\gcd(i,n)$ 个划分，每一段都要相同。

然后就是 Burnside 了：
$$\begin{aligned}
ans&amp;=\frac{1}{|G|}\sum_{\pi\in G}c_1(\pi)
\\&amp;=\frac{1}{n}\sum_{i=0}^{n-1}c_1(cy_i)
\\&amp;=\frac{1}{n}\sum_{i=1}^{n}c_1(cy_i)
\\&amp;=\frac{1}{n}\sum_{i=1}^{n}m^{\gcd(i,n)}
\\&amp;=\frac{1}{n}\sum_{d|n}\sum_{i=1}^{n/d}m^d[\gcd(i,\frac{n}{d})=1]
\\&amp;=\frac{1}{n}\sum_{d|n}m^d\sum_{i=1}^{n/d}[\gcd(i,\frac{n}{d})=1]
\\&amp;=\frac{1}{n}\sum_{d|n}m^d\varphi(\frac{n}{d})
\end{aligned}$$
（显然使用了莫比乌斯反演，或你说是 $\varphi$ 的定义也行）

关于如何解决剩下这个东西我那篇 Luogu 的题解应该讲得够清楚了。

## 拓展

[P3307 [SDOI2013]项链](https://www.luogu.com.cn/problem/P3307) 这道题项链支持翻转，稍难搞。

## 计蒜客课件截图

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001242993-1158276404.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001259606-1713754022.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001324301-971946027.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001344600-629938863.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001355494-1739723765.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230524001409052-182681648.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16398412.html</id>
    <title type="text">重修 二项式反演-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-22T14:30:00Z</published>
    <updated>2022-06-22T14:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16398412.html" />
    <content type="text"># 开头

~~我只知道容斥不知道二项式反演。~~

**反演**，顾名思义就是有两个函数 $f,g$，知道 $f$ 用 $g$ 表示后反过来 $g$ 用 $f$ 表示。

**二项式**，$(a+b)^n$，别学了二项式反演忘了**二项式定理**：
$$
\sum_{i=0}^n\binom{n}{i}a^ib^{n-i}=(a+b)^n
$$

# 常见形式

## （一）

### 式子
$$
\begin{aligned}
f(n)=\sum_{i=0}^n&amp; (-1)^i\binom{n}{i}g(i)
\\ &amp; \Updownarrow \\
g(n)=\sum_{i=0}^n&amp; (-1)^i\binom{n}{i}f(i)
\end{aligned}
$$

### 证明
$$
\begin{aligned}
&amp; \sum_{i=0}^n(-1)^i\binom{n}{i}f(i)
\\=&amp; \sum_{i=0}^n(-1)^i\binom{n}{i}\sum_{j=0}^i(-1)^j\binom{i}{j}g(j)
\\=&amp; \sum_{j=0}^ng(j)\binom{n}{j}\sum_{i=j}^n(-1)^{i-j}\binom{n-j}{i-j}
\\=&amp; \sum_{j=0}^ng(j)\binom{n}{j}[n-j=0]
\\=&amp; g(n)
\end{aligned}
$$

## （二）

### 式子
$$
\begin{aligned}
f(n)=\sum_{i=n}^N&amp; (-1)^i\binom{i}{n}g(i)
\\ &amp; \Updownarrow \\
g(n)=\sum_{i=n}^N&amp; (-1)^i\binom{i}{n}f(i)
\end{aligned}
$$

### 证明
$$
\begin{aligned}
&amp; \sum_{i=n}^N(-1)^i\binom{i}{n}f(i)
\\=&amp; \sum_{i=n}^N(-1)^i\binom{i}{n}\sum_{j=i}^N(-1)^j\binom{j}{i}g(j)
\\=&amp; \sum_{j=n}^Ng(j)(-1)^{j-n}\binom{j}{n}\sum_{i=n}^j(-1)^{i-n}\binom{j-n}{i-n}
\\=&amp; \sum_{j=n}^Ng(j)(-1)^{j-n}\binom{j}{n}[j-n=0]
\\=&amp; g(n)
\end{aligned}
$$

## 证明的总结
由于两个式子都是对称的，所以都只证明了充分性。

证明都用到了
$$
\binom{a}{b}\binom{b}{c}=\binom{a}{c}\binom{a-c}{b-c}
$$
和
$$
[n=0]=\sum_{i=0}^{n}\binom{n}{i}(-1)^i
$$

## 多元的情况
我们拿二元举例子：
$$\begin{aligned}
f(n,m)=\sum_{i=0}^n\sum_{j=0}^m(-&amp; 1)^{i+j}\binom{n}{i}\binom{m}{j}g(i,j)
\\ \Updownarrow \\
g(n,m)=\sum_{i=0}^n\sum_{j=0}^m(-&amp; 1)^{i+j}\binom{n}{i}\binom{m}{j}f(i,j)
\end{aligned}$$
其他~~应该~~同理。

# 例题

## 第二类斯特林数

我不会，长大后再学习。（

## 错排

$g(x)$ 表示 $n$ 个位置中**至多**有 $x$ 个位置放错的方案数，而 $f(x)$ 表示**恰好**。
$$
g(n)=n!
\\
g(n)=\sum_{i=0}^{n}\binom{n}{i}f(i)
$$
反演
$$\begin{aligned}
f(n)&amp;=\sum_{i=0}^{n}(-1)^{n-i}\binom{n}{i}g(i)
\\&amp;=\sum_{i=0}^{n}(-1)^{n-i}\binom{n}{i}i!
\\&amp;=\sum_{i=0}^{n}(-1)^{n-i}\frac{n!}{(n-i)!}
\\&amp;=n!\sum_{i=0}^{n}\frac{(-1)^{n-i}}{(n-i)!}
\\&amp;=n!\sum_{i=0}^{n}\frac{(-1)^i}{i!}
\end{aligned}$$
错排通项由此诞生。

由于后面的和式是 $e^{-1}$ 的泰勒展开，所以我们得到：

&gt; 任意一个排列，当 $n\to\infty$，该排列为错排的概率为 $\dfrac{1}{e}$。

P.S.

错排递推式 $f_n=(n-1)(f_{n-1}+f_{n-2})$。

若 $n$ 所在环为二元环，删掉二元环后是错排，$(n-1)f_{n-2}$。

否则环长至少为三，将 $n$ 前后接起来跳过 $n$ 后是错排，$(n-1)f_{n-1}$。

## P4859 已经没有什么好害怕的了

&gt; 给定 $n\le 2000$ 长度的序列 $a_1,\dots,a_n$ 和 $b_1,\dots,b_n$，$2n$ 个元素两两不同，求排列 $p_1,\dots,p_n$ 的个数使得（以下的 $k$ 为原题的 $\frac{n+k}{2}$）：
&gt; $$
&gt; \sum_{i=1}^n[a_i&gt;b_{p_i}]=k
&gt; $$

设 $f(x)$ 表示**恰好** $x$ 组 $[a_i&gt;b_{p_i}]$ 的 $\{p\}$ 的方案数，显然答案为 $f(k)$。

而 $g(x)$ 表示**钦定** $x$ 组…………的方案数。

&lt;details&gt;
&lt;summary&gt;钦定和至少的区别&lt;/summary&gt;

**钦定**指固定某些位置满足条件，而**至少**只是单纯的计数。

举个例子，假设要计数值域 $0,1$ 的 $a_1,a_2,a_3,a_4$ 序列中 $a_i=1$ 个数不少于 $2$ 个的方案数。

对于 $\{a\}=\{0,1,1,1\}$ 来说：

**至少**：贡献为 $1$，因为就一种状态。

**钦定**：贡献为 $3$，因为序列中 $3$ 个 $1$，我们钦定任意 $2$ 个为 $1$ 都会产生贡献，所以贡献为 $\binom{3}{2}=3$。
&lt;/details&gt;

显然
$$
g(x)=\sum_{i=x}^n\binom{i}{x}f(i)
$$
二项式反演
$$
f(x)=\sum_{i=x}^n(-1)^{i-x}\binom{i}{x}g(i)
\\
Ans=f(k)=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}g(i)
$$
问题转化为求 $g(k),\dots,g(n)$。

首先我们可以将 $\{a\},\{b\}$ 升序排序，由于值互不相同，所以可求 $c_1,\dots,c_n$ 使得 $b_{c_i}\le a_i\le b_{c_i+1}$。

我们考虑 DP，$dp(i,j)$ 表示 $a$ 的前 $i$ 个中有 $j$ 个**钦定**匹配了比她小的 $b$ 值，即有
$$
dp(i,j)=dp(i-1,j)+dp(i-1,j-1)\cdot(c_i-(j-1))
$$
然后 $g(i)=dp(n,i)\cdot (n-i)!$ 就做完了。

时间 $O(n^2)$。

[record](https://www.luogu.com.cn/record/77758630)

## CF997C Sky Full of Stars

&gt; 有一个 $n\times n$ 的正方形网格，用红绿蓝三种颜色染色，求有多少种染色方案使得至少一行或一列是同一种颜色。
&gt; 
&gt; 结果对 $998244353$ 取模。

设 $f(i,j)$ 表示恰好 $i$ 行与 $j$ 列颜色相同，而 $g(i,j)$ 表示钦定 $i$ 行与 $j$ 列颜色相同。
$$
g(x,y)=\sum_{i=x}^n\sum_{j=y}^n\binom{i}{x}\binom{j}{y}f(i,j)
$$
二项式反演
$$
f(x,y)=\sum_{i=x}^n\sum_{j=y}^n(-1)^{i+j-x-y}\binom{i}{x}\binom{j}{y}g(i,j)
\\
\begin{aligned}
Ans&amp;=3^{n^2}-f(0,0)
\\&amp;=3^{n^2}-\sum_{i=0}^n\sum_{j=0}^n(-1)^{i+j}g(i,j)
\end{aligned}
$$
求 $g(i,j)$ 要分类：

1. $i\ne 0,j\ne 0$，此时钦定的同色行列颜色必然全部一样，即
$$
g(i,j)=\binom{n}{i}\binom{n}{j}3^{(n-i)(n-j)+1}
$$

2. $i\ne 0,j=0$（$i=0,j\ne 0$ 情况类似），此时这些行之间颜色可以不同，即
$$
g(i,0)=\binom{n}{i}3^{n(n-i)+i}
$$

3. $i=j=0$，此时自由了~~我向往自由！~~
$$
g(0,0)=3^{n^2}
$$

综上
$$\begin{aligned}
Ans&amp;=-2\sum_{i=1}^n(-1)^{i}g(i,0)-\sum_{i=1}^n\sum_{j=1}^n(-1)^{i+j}g(i,j)
\\&amp;=-2A-B
\end{aligned}
\\
A=\sum_{i=1}^n(-1)^{i}\binom{n}{i}3^{n(n-i)+i}
\\
B=\sum_{i=1}^n\sum_{j=1}^n(-1)^{i+j}\binom{n}{i}\binom{n}{j}3^{(n-i)(n-j)+1}
$$
$A,B$ 分开求（分别均使用二项式定理）
$$\begin{aligned}
A&amp;=3^{n^2}\sum_{i=1}^n(-1)^{i}\binom{n}{i}3^{-ni+i}
\\&amp;=3^{n^2}\sum_{i=1}^n\binom{n}{i}(-3^{1-n})^{i}
\\&amp;=3^{n^2}((1-3^{1-n})^{n}-1)
\end{aligned}$$
$$\begin{aligned}
B&amp;=3^{n^2+1}\sum_{i=1}^n\sum_{j=1}^n(-1)^{i+j}\binom{n}{i}\binom{n}{j}3^{-ni-nj+ij}
\\&amp;=3^{n^2+1}\sum_{i=1}^n(-1)^i\binom{n}{i}3^{-ni}\sum_{j=1}^n(-1)^j\binom{n}{j}3^{(i-n)j}
\\&amp;=3^{n^2+1}\sum_{i=1}^n(-1)^i\binom{n}{i}3^{-ni}\sum_{j=1}^n\binom{n}{j}(-3^{i-n})^j
\\&amp;=3^{n^2+1}\sum_{i=1}^n(-1)^i\binom{n}{i}3^{-ni}((1-3^{i-n})^n-1)
\end{aligned}$$

所以就 $O(n\log n)$ 解决了。

[record](https://www.luogu.com.cn/record/77728214)

## P6076 [JSOI2015]染色问题

&gt; $n\times m$ 的矩形棋盘，初始无色。现在有 $C$ 种颜料涂，要求：
&gt; 
&gt; 1. 棋盘的每一行/列至少有一个小方格被染色。
&gt; 
&gt; 2. 每种颜色都在棋盘上出现至少一次。
&gt;
&gt; 求染色方案数 $\bmod 10^9+7$。

一样的套路，我们发现设 $f(i,j,k)$ 表示恰好 $i,j$ 行/列至少有一个染色，$k$ 种颜色被上在墙上的方案数比较困难。

正难则反，设 $f(i,j,k)$ 表示恰好 $i,j$ 行/列**完全没有染色**，$k$ 种颜色**没有上在墙上**。

同理 $g(i,j,k)$ 将 $f$ 的**恰好**换成**钦定**。

有
$$
g(i,j,k)=\binom{n}{i}\binom{m}{j}\binom{C}{k}(C-k+1)^{(n-i)(m-j)}
$$
然后求 $g$ 关于 $f$ 的表达式
$$
g(i,j,k)=\sum_{x=i}^n\sum_{y=j}^m\sum_{z=k}^C
\binom{x}{i}\binom{y}{j}\binom{z}{k}f(x,y,z)
$$ 
然后三元二项式反演
$$
f(i,j,k)=\sum_{x=i}^n\sum_{y=j}^m\sum_{z=k}^C
(-1)^{x+y+z-i-j-k}
\binom{x}{i}\binom{y}{j}\binom{z}{k}g(x,y,z)
$$
然而我们要求的最终答案是 $f(0,0,0)$ 即（将 $g$ 一开始的柿子带入）
$$\begin{aligned}
f(0,0,0)&amp;=\sum_{i=0}^n\sum_{j=0}^m\sum_{k=0}^C
(-1)^{i+j+k}g(i,j,k)
\\&amp;=\sum_{i=0}^n\sum_{j=0}^m\sum_{k=0}^C
(-1)^{i+j+k}\binom{n}{i}\binom{m}{j}\binom{C}{k}(C-k+1)^{(n-i)(m-j)}
\\&amp;=\sum_{k=0}^C\sum_{i=0}^n\sum_{j=0}^m
(-1)^{i+j+k}\binom{n}{i}\binom{m}{j}\binom{C}{k}(C-k+1)^{(n-i)(m-j)}
\end{aligned}$$
这样我们在第一层循环时预处理后面的幂，时间复杂度 $O(nmC)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16411101.html</id>
    <title type="text">多项式-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-05T11:56:00Z</published>
    <updated>2022-07-05T11:56:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16411101.html" />
    <content type="text">[TOC]

# 乘法逆

## 题面

[P4238 【模板】多项式乘法逆](https://www.luogu.com.cn/problem/P4238)

&gt; 给定一个多项式 $F(x)$，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \equiv 1 \pmod{x^n}$。
&gt; 
&gt; 系数对 $998244353$ 取模。

为方便 NTT 和倍增，不妨设 $n$ 为 $2$ 的幂。

我们有两种方法。

## 倍增

首先，若 $n=1$，答案为 $[x^0]F(x)$ 的乘法逆元。

假设我们求出了 $\bmod x^{n/2}$ 的逆，设为 $H(x)$。

接下来就是柿子环节
$$\begin{aligned}
FH&amp;\equiv 1\pmod{x^{n/2}}
\\
FH-1&amp;\equiv 0\pmod{x^{n/2}}
\\
(FH-1)^2&amp;\equiv 0\pmod{x^n}
\\
F^2H^2-2FH+1&amp;\equiv 0\pmod{x^n}
\\
2FH-F^2H^2&amp;\equiv 1\pmod{x^n}
\\
F(2H-FH^2)&amp;\equiv 1\pmod{x^n}
\\
G&amp;\equiv 2H-FH^2\pmod{x^n}
\end{aligned}$$
我们就得到了递推式。

## 牛迭

![](https://img2022.cnblogs.com/blog/2213867/202206/2213867-20220625160042031-1529759970.png)

Konata：多项式牛顿迭代法，不止用来求逆用的。

![](https://img2022.cnblogs.com/blog/2213867/202206/2213867-20220625160048822-454467183.png)

Konata：求逆的话就是在上面证明基础上直接用就好了。

## 代码 / 时间复杂度

注意多项式项数 / 边界等细节，可看注释。

[record](https://www.luogu.com.cn/record/77868477)

时间：
$$
T(n)=T(\frac{n}{2})+n\log n
$$
由[主定理](https://www.cnblogs.com/zhangshaojia/p/16411620.html)，时间复杂度为 $O(n\log n)$。

# 乘转加

## 例题

[P3321 [SDOI2015]序列统计](https://www.luogu.com.cn/problem/P3321)

题面够简化了，不需要再补充了。

## 做法

如果将「数列中所有数的乘积」改成「加和」那就好做了，将 $S$ 中的元素移到 $x$ 的指数上去然后多项式快速幂即可。

但是这里是「乘积」，咋办？

首先，因为题目要求最后的结果（题面中的 $x$）不是 $0$，所以我们可以把 $S$ 中的 $0$ 全部删去。

其次，由于 $m$ 是素数，[这篇说到](https://zhuanlan.zhihu.com/p/376149223)只有 $1,2,4,p^k,2p^k$（$p$ 为奇素数）有原根。

&gt; **$\bmod p(p\in\text{prime})$ 意义下的乘法可以转化为 $\bmod (p-1)$ 意义下的加法，转化途径就是原根。**

也就是说，我们本来的思路是 $\log(xy)=\log(x)+\log(y)$ 用对数转化的，但是我们只支持自然数啊。所以我们打算「以原根为底求 $\log$」设我们求出 $m$ 的原根有 $g$，我们把 $1,\dots,m-1$ 都表示为
$$g^{k}\bmod m\quad(k\in[0,\varphi(m)-1(=m-2)]\cap\mathbb{N})$$
的形式，这时她的对数就是这里的指数 $k$。

所以我们把这个对数放到 $x$ 的指数上去，然后多项式快速幂即可，注意我们每次将多项式压进 $x$ 指数 $\bmod (m-1)$ 的同余系里。

[record](https://www.luogu.com.cn/record/78519512)

# 导数积分

$$
\frac{d\, x^n}{d\, x}=nx^{n-1}
$$

$$
\int x^n d\, x=\frac{x^{n+1}}{n+1}
$$

# ln &amp; exp

$$
\begin{aligned}
G&amp;=\exp F
\\
G'&amp;=F'\exp F
\\
G'&amp;=F'G\quad ^{\dagger}
\\
F&amp;=\int\frac{G'}{G}
\\
\ln G&amp;=\int\frac{G'}{G}
\end{aligned}
$$

$\ln G$ 有意义 $\iff [x^0]G=1$

$\exp F$ 有意义 $\iff [x^0]F=0$

用多项式乘法逆即可线性对数求出多项式 $\ln$。

更好写的 $O(n^2)$ 多项式 $\exp$ 求法：

设 $f_i=[x^i]F,g_i=[x^i]G$，由 $\dagger$ 式得：
$$
(i+1)g_{i+1}=\sum_{j=0}^i(i-j+1)f_{i-j+1}g_j\quad(i\ge 0,g_0=1)
$$
将上式移项有 $O(n^2)$ 多项式 $\ln$ 求法：
$$
(i+1)g_0f_{i+1}=(i+1)g_{i+1}-\sum_{j=1}^ijg_{i+1-j}f_j\quad(i\ge 0,f_0=0)
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16411620.html</id>
    <title type="text">主定理（Master Theorem）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-25T07:58:00Z</published>
    <updated>2022-06-25T07:58:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16411620.html" />
    <content type="text">[随堂测验](http://people.csail.mit.edu/thies/6.046-web/master.pdf)

[wikipedia](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)#cite_note-Yap-3)

大概翻译自 wiki，并包含一些私货。
$$
T(n)=aT(\frac{n}{b})+n^c\log^k n
\\
T(O(1))=O(1)
$$
其中 $a\ge 1,b&gt;1,c\ge 0,k$ 均为常实数。

定义 $c_{\text{crit}}=\log_b a$ 为临界指数（critical exponent）。

|    类  |   条件   |   复杂度   |
| ---- | ---- | ---- |
|   leaf-heavy   |   $c&lt;c_{\text{crit}}$   |   $O(n^{c_{\text{crit}}})$   |
|  comparable to subprob. |   $c=c_{\text{crit}}$   |   N/A   |
|  root-heavy |   $c&gt;c_{\text{crit}}$   |   $O(n^c\log^kn)$   |

对于上表第二类 comparable to subprob.，我们还需要对 $k$ 的取值分类：

|   条件   |   复杂度   |
| ---- | ---- |
|   $k&lt;-1$   |   $O(n^c)$   |
|   $k=-1$   |   $O(n^c\log\log n)$   |
|   $k&gt;-1$   |   $O(n^c\log^{k+1}n)$   |

尝试解释一下上表（不严谨，私货），由于（下方等式表示复杂度相同）
$$
T(n)=n^c\sum_{i=0}^{\log_b n}\log^k\frac{n}{b^i}
$$
不妨将 $\log$ 的底数设为 $b$，则
$$
T(n)=n^c\sum_{i=0}^{\log_b n}(\log_b n-i)^k=n^c\sum_{i=0}^{\log_b n}i^k
$$
将后面的求和近似为积分即可
$$
T(n)=n^c\int_{0}^{\log n}x^k\text{ d}x
$$
由于
$$
\int x^k\text{ d}x=
C+\begin{cases}
\ln x&amp;,k=-1
\\
\frac{x^{k+1}}{k+1}&amp;,\text{otherwise}
\end{cases}
$$
就可以推出上表了。

**注意：** 把 $\log n$ 固定为某个常数 $d$ 在 leaf-heavy 分类下是不可取的，复杂度变为 $O(n^{c_{\text{crit}}}d^k)$，在别的分类下应该没影响，所以 leaf-heavy 时请检查你有多少只 $\log$ 里是 $n$（赝品：位长，$\log$ 值域 etc.）（详见【UNR #5】诡异操作）。

**P.S.：** 如果你带 $\log\log n$ 或更多层 $\log$ 的东西，据我所推，leaf-heavy 复杂度不变，其他两类复杂度都乘上这些东西（也就是看成常数）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16412187.html</id>
    <title type="text">拉格朗日插值-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-06-25T10:35:00Z</published>
    <updated>2022-06-25T10:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16412187.html" />
    <content type="text">~~So far 没啥好说的。~~终于有东西了。

## 原本的插值

给定 $n$ 个坐标系上的点（$x$ 坐标两两不同），让你求一个**最高不超过 $n-1$ 次**的多项式函数经过这些点。

设 $n$ 个点的坐标为 $(x_1,y_1),\dots,(x_n,y_n)$，则函数
$$\large{
f(x)=\sum_{i=1}^ny_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}
}$$
即为所求。

证明：

只要将 $x=x_1,x_2,\dots,x_n$ 代入原式一切就明白了，每次代入都只有一项为 $y_i$，其他为 $0$。

若 $x_i$ 没有规律的话复杂度为 $O(n^2)$，也比高斯消元优秀。

## P4781 【模板】拉格朗日插值

[远古的提交](https://www.luogu.com.cn/record/57137308)

## P5667 拉格朗日插值2

配合多项式。

[提交](https://www.luogu.com.cn/record/57218162)

## CF622F The Sum of the k-th Powers

&gt; 求 $\sum_{i=1}^ni^k \bmod (10^9+7)$。
&gt;
&gt; $n$ 很大，要求 $O(k\log k)$。

不妨设答案为 $S_k(n)$。

其实，$S_k(n)$ 是关于 $n$ 的 $k+1$ 次多项式，给出证明。

### 证明 1

做一下差分，发现 $\Delta S_k(n)=n^k$，是一个 $k$ 次多项式，而 $k$ 次多项式的前缀和为 $k+1$ 次多项式。

### 证明 2（仅供参考）

[参考](https://www.luogu.com.cn/blog/pks-LOVING/solution-cf622f) [我写的](https://www.cnblogs.com/shaojia/p/18023217)
$$
S_{k}(n)=\frac{1}{k+1}\sum_{r=1}^{k+1}\binom{k+1}{r}B_{k+1-r}(n+1)^r
$$
其中 $B_i$ 为伯努利数。

* * * 

所以说我们**任意**找不同的 $k+2$ 个点进行插值即可求出 $S_{k}(n)$。

我们就选取好算的 $1\sim k+2$ 来插值，发现每个点的值和插值时的系数可以快速求出，就解决了。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//https://www.luogu.com.cn/problem/CF622F
#include&lt;bits/stdc++.h&gt;
#define mod 1000000007
#define N 1000010
using namespace std;

int pl[N], pr[N], fac[N];
int qpow(int a, int b) {
	int ans = 1;
	for(; b &gt;= 1; b &gt;&gt;= 1, a = 1ll * a * a % mod)
		if(b &amp; 1) ans = 1ll * ans * a % mod;
	return ans;
}
signed main() {
	int n, k, y = 0, ans = 0;
	scanf("%d%d", &amp;n, &amp;k);
	pl[0] = pr[k + 3] = fac[0] = 1;
	for(int i = 1; i &lt;= k + 2; i ++)
		pl[i] = 1ll * pl[i - 1] * (n - i) % mod;
	for(int i = k + 2; i &gt;= 1; i --)
		pr[i] = 1ll * pr[i + 1] * (n - i) % mod;
	for(int i = 1; i &lt;= k + 2; i ++)
		fac[i] = 1ll * fac[i - 1] * i % mod;
	for(int i = 1; i &lt;= k + 2; i ++) {
		y = (y + qpow(i, k)) % mod;
		int a = pl[i - 1] * 1ll * pr[i + 1] % mod;
		int b = fac[i - 1] * ((k - i) &amp; 1 ? -1ll : 1ll) * fac[k + 2 - i] % mod;
		ans = (ans + 1ll * y * a % mod * qpow(b, mod - 2) % mod) % mod;
	}
	printf("%d\n", (ans + mod) % mod);
	return 0;
}
```
&lt;/details&gt;

## BZOJ3453. tyvj 1858 XLkxc

&gt; 给定 $k,a,n,d,p$。
&gt; 
&gt; $f(x)=\sum_{i=1}^{x}i^k$
&gt;
&gt; $g(x)=\sum_{i=1}^{x}f(i)$
&gt;
&gt; $h(x)=\sum_{i=0}^{x}g(a+id)$
&gt;
&gt; 求 $h(n)\bmod p$。
&gt;
&gt; $1\le k\le 123,0\le a,n,d\le 123456789$
&gt;
&gt; $p=1234567891$ 一个素数。

和上一道差不多，就是多套了几层，插值 $k+4$ 个点即可。

时间 $O(k^3)$。

细节有一些。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ll long long
const ll P=1234567891;//prime
const int N=130;
ll pw(ll x,ll y){
	ll res=1;
	while(y){
		if(y&amp;1){
			(res*=x)%=P;
		}
		y&gt;&gt;=1;
		(x*=x)%=P;
	}
	return res;
}
int k;
ll A,n,d,v[N],f[N],g[N],h[N];
ll calc(int lim,ll x){//[0,lim) 内整数已知点值，求 f(x)（x 对 P 取模）
	ll ans=0,res;
	For(i,0,lim-1){
		res=1;
		For(j,0,lim-1) if(i!=j) (res*=i-j+P)%=P;
		res=pw(res,P-2)*v[i]%P;
		For(j,0,lim-1) if(i!=j) (res*=x-j+P)%=P;
		(ans+=res)%=P;
	}
	return ans;
}
void work(){
	cin&gt;&gt;k&gt;&gt;A&gt;&gt;n&gt;&gt;d;
	For(i,1,k+2) f[i]=(f[i-1]+pw(i,k))%P;
	For(i,1,k+2) g[i]=(g[i-1]+f[i])%P;
	copy(g,g+k+3,v);
	h[0]=calc(k+3,A);
	For(i,1,k+3) h[i]=(h[i-1]+calc(k+3,(A+i*d)%P))%P;
	copy(h,h+k+4,v);
	cout&lt;&lt;calc(k+4,n)&lt;&lt;"\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
//插值式子上面是 x-x_j 不是 x_i-x，公式记牢
//这里模数两倍爆 int！！
```
&lt;/details&gt;

## [AGC061F] Perfect Strings

看题解区吧，我也不是非常懂，属于拉插高端运用了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16436099.html</id>
    <title type="text">2-sat-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-01T14:03:00Z</published>
    <updated>2022-07-01T14:03:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16436099.html" />
    <content type="text">[P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782)

[record](https://www.luogu.com.cn/record/57330660)

## 是啥

给定一些 bool 变量，和一些形如「某 bool 为 true/false 则另一个 bool 必然为 true/false」的条件，问是否有解（并构造）。

## 构图

将 $n$ 个 bool 变量拆成 $2n$ 个点，分别表示某 bool 取 true/false 的情况。

首先我们要知道条件 $p,q$：
$$
(p\implies q)\iff (\neg q\implies \neg p)
$$
所以假设我们有条件「$a_1$ 若为 true，则 $a_2$ 为 false」，则我们这样连边：
![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220701213004574-1417461740.png)
其中绿色边代表逆否命题。

所以我们就得到了一个最基础且最关键的 2-sat 性质：

&gt; **对称性：** 若 $a$ 向 $b$ 连边，则 $b$ 的对面向 $a$ 的对面连边。

假若我们要固定一个 bool 为 true 咋办（false 同理）：
![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220701213603937-2006390556.png)
即将命题转化为「若 $a_3$ 为 false，则 $a_3$ 为 true」（这样 $a_3$ 只能为 true），注意此图仍然满足对称性。

## 缩点

没错，用 tarjan 将这个有向图缩点。

我们接下来证明：

**此 2-sat 有解 $\iff$ 不存在两个对面对的点处于同一个 SCC 中**。

**充分性**

假设存在两个对面对的点处于同一个 SCC 中。那这个 bool 若为 true 则能推至 false，false 能推至 true，矛盾。

**必要性**

假设不存在两个对面对的点处于同一个 SCC 中且 2-sat 无解。

我们对于每一个 bool 构造：若 bool 的一个状态 $x$ 能推到 $y$，则我们选择 $y$ 状态，否则 $x,y$ 无法互相推，随便选。

此时必然无解，假设是某一个 bool 的 $x$ 推到了 $y$。但是由于我们的构造方案，得出 $y$ 能够推到 $x$。这样发现 $x,y$ 在同一个 SCC 中，矛盾。

## 构造

若判得有解，我们尝试构造一组解。

其实我们的构造方法就在上面的证明里。

我们用 tarjan 对 SCC 进行染色。由于**tarjan 是逆拓扑序**，所以我们每次在 bool 的两个状态中选颜色更小的即可。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16479623.html</id>
    <title type="text">计算几何-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-13T02:50:00Z</published>
    <updated>2022-08-13T02:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16479623.html" />
    <content type="text">[TOC]

# 向量旋转与基变换

不用死记二维向量旋转矩阵啦！（向量逆时针旋转 $\theta$ 弧度）
$$
\begin{bmatrix}
\cos\theta&amp;-\sin\theta
\\
\sin\theta&amp;\cos\theta
\end{bmatrix}
\begin{bmatrix}x\\y\end{bmatrix}
=
\begin{bmatrix}x'\\y'\end{bmatrix}
$$
理解：

本来基底是
$$
\hat\imath=\begin{bmatrix}1\\0\end{bmatrix}
\ \hat\jmath=\begin{bmatrix}0\\1\end{bmatrix}
$$
（上面为 $x$ 坐标，下面为 $y$）

基底逆时针旋转 $\theta$ 后变为
$$
\hat\imath'=\begin{bmatrix}\cos\theta \\ \sin\theta\end{bmatrix}
\ \hat\jmath'=\begin{bmatrix}-\sin\theta\\ \cos\theta\end{bmatrix}
$$
然后就得到开头的旋转矩阵了
$$
\begin{bmatrix}\hat\imath' &amp;\hat\jmath'\end{bmatrix}=\begin{bmatrix}
\cos\theta&amp;-\sin\theta
\\
\sin\theta&amp;\cos\theta
\end{bmatrix}
$$

这样是因为

$$
\begin{bmatrix}\hat\imath' &amp;\hat\jmath'\end{bmatrix}\begin{bmatrix}\hat\imath &amp;\hat\jmath\end{bmatrix}=\begin{bmatrix}\hat\imath' &amp;\hat\jmath'\end{bmatrix}
$$

因为左式右边项为单位矩阵。

所以不论是怎样的基变换，都只要将变换后的基并排放在一起就是变换矩阵了。

[3b1b 基变换](https://www.bilibili.com/video/BV1Ls411b7r2)

# 向量的模长

等于与自身的点积的算数平方根。

# 点积和叉积

[3b1b 点积](https://www.bilibili.com/video/BV13s411t7fe/)

[3b1b 叉积](https://www.bilibili.com/video/BV1js411t7qS/)

&gt; 点积判前后，叉积判左右。

## 点积

点积写作 $\vec u \cdot \vec v$，叉积写作 $\vec u\times \vec v$。

点积定义在两个相同维度向量之间：
$$
\begin{bmatrix}a_1\\ a_2\\ \vdots\\ a_n\end{bmatrix}
\cdot
\begin{bmatrix}b_1\\ b_2\\ \vdots\\ b_n\end{bmatrix}
=
\sum_{i=1}^na_ib_i
$$
其实就是将第一个向量转置后的矩阵乘法。

对于二维的话
$$
\vec v\cdot \vec w=|\vec v||\vec w|\cos\theta
$$
$\theta$ 是 $\vec v$ 向 $\vec w$ 的逆时针夹角（其实点积这里无所谓因为 $\cos$ 是偶函数）。

实现时重载用 `operator*`。

## 叉积

而叉积只考虑二维的情况：
$$
\begin{bmatrix}x_1\\ y_1\end{bmatrix}
\times
\begin{bmatrix}x_2\\ y_2\end{bmatrix}
=
\begin{vmatrix}x_1&amp;x_2\\ y_1&amp;y_2\end{vmatrix}
=
x_1y_2-x_2y_1
$$
回顾基变换，发现叉积就是两个向量组成的平行四边形的（有向）面积。

其实叉积是定义在三维空间中的，其用途是计算三个向量 $\vec a,\vec b,\vec c$ 构成的平行六面体（有向）体积，为：
$$
(\vec a\times\vec b)\cdot\vec c
$$
其中
$$
\vec a\times \vec b=
\begin{vmatrix}
\begin{bmatrix}\hat \imath\\ \hat \jmath\\ \hat k\end{bmatrix}
&amp;
\vec a
&amp;
\vec b
\end{vmatrix}
$$
遵循右手定则。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221120111311591-1632399776.png)

二维时想知道叉积正负性也可以右手定理，大拇指指外（向自己）就是正，指内就是负。

实现时重载用 `operator^`。

叉积也有像点积那样的式子
$$
\vec v\cdot \vec w=|\vec v||\vec w|\sin\theta
$$
所以我做了一个优美的图：
![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221120112903621-856630391.png)

# 点到直线的距离

设点为 $O$，找到直线上不同的两个点 $A,B$，则点 $O$ 到直线 $AB$ 的距离为
$$
\frac{|(O-A)\times (B-A)|}{|A-B|}
$$
主要用到了面积法。

# 点到线段的距离

用点积判断一下垂足是否在线段外，剩下的同直线。

# 二维凸包

通过叉积来计算两个向量的方向关系。

提供简单的写法：

[【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define N 100005
#define db double
#define Pos pair&lt;db,db&gt;
Pos operator-(Pos x,Pos y){ return mkp(x.fir-y.fir,x.sec-y.sec); }
db operator^(Pos x,Pos y){ return x.fir*y.sec-x.sec*y.fir; }
db operator*(Pos x,Pos y){ return x.fir*y.fir+x.sec*y.sec; }
db Len(Pos x){ return sqrt(x*x); }
int b[N&lt;&lt;1],bt,n;
Pos a[N];
void insert(int x){
	while(bt&gt;=2 &amp;&amp; b[bt]!=n &amp;&amp; ((a[x]-a[b[bt]])^(a[b[bt]]-a[b[bt-1]]))&gt;=0) bt--;
	b[++bt]=x;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i].fir&gt;&gt;a[i].sec;
	sort(a+1,a+1+n);
	b[bt=1]=1;
	For(i,2,n) insert(i);
	Rof(i,n-1,1) insert(i);
	bt--;
	db ans=0;
	For(i,1,bt) ans+=Len(a[b[i]]-a[b[i%bt+1]]);
	cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

# 旋转卡壳 / 平面最远点对 / 凸包直径

（这四个字咋读）

凸包直径 = 平面最远点对距离

我们先求出凸包，接下来我们说的点指凸包上的点集。

注意我们**不能**枚举**点**，然后像双指针那样找对锺点。

因为所有点到同一个点的距离并**不单峰**。

比如：

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220813114453183-1050639064.png)

所以我们要顺序枚举**凸包上的边**，找到这条边所在直线最远的点，同样是类似双指针，但是这次是正确的，因为**单峰**：

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220813115352216-1560323129.png)

（单峰性质一目了然）

由于像一块石头不断改变与桌面接触的面，然后不断维护最高点的编号，所以这就是“旋转卡壳”名称的由来。

设凸包上的点数为 $bt$，注意每次找到一条边的对锺点后我们分别要求这个点到边的两端的距离，所以最后的答案其实是 $2bt$ 个值取 $\max$ 的结果。

[【模板】旋转卡壳](https://www.luogu.com.cn/problem/P1452)

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define N 50005
#define Pos pair&lt;int,int&gt;
Pos operator-(Pos x,Pos y){ return mkp(x.fir-y.fir,x.sec-y.sec); }
int operator^(Pos x,Pos y){ return x.fir*y.sec-x.sec*y.fir; }
int operator*(Pos x,Pos y){ return x.fir*y.fir+x.sec*y.sec; }
int Len(Pos x){ return x*x; }
Pos a[N];
int b[N&lt;&lt;1],bt,n;
void insert(int x){
	while(bt&gt;=2 &amp;&amp; b[bt]!=n &amp;&amp; ((a[x]-a[b[bt]])^(a[b[bt]]-a[b[bt-1]]))&gt;=0) bt--;
	b[++bt]=x;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i].fir&gt;&gt;a[i].sec;
	sort(a+1,a+1+n);
	b[bt=1]=1;
	For(i,2,n) insert(i);
	Rof(i,n-1,1) insert(i);
	bt--;
	if(bt==1){
		cout&lt;&lt;0&lt;&lt;endl;
		return 0;
	}
	int pos=2,ans=0;
	auto nxt=[&amp;](int x)-&gt;int{ return x==bt?1:x+1;  };
	For(i,1,bt){
		while(
			((a[b[nxt(i)]]-a[b[i]])^(a[b[pos]]-a[b[i]]))&lt;
			((a[b[nxt(i)]]-a[b[i]])^(a[b[nxt(pos)]]-a[b[i]]))
		) pos=nxt(pos);
		ckmx(ans,Len(a[b[pos]]-a[b[i]]));
		ckmx(ans,Len(a[b[pos]]-a[b[nxt(i)]]));
	}
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

# 平面最近点对

[P7883 平面最近点对（加强加强版）](https://www.luogu.com.cn/problem/P7883)

这里讲两种做法：随机化期望 $O(n)$ 和分治+归并 $O(n\log n)$ 两种做法，后者好写，前者快。

## 随机化

我们先将点 shuffle。

我们先求出 $1,2$ 之间的距离 $ans$ 作为初始答案，将平面划分成 $ans\times ans$ 的无限网格。

$1\to n$ 枚举每一个点，通过 hash 得出所在格子的标号，然后用链式前向星查附近（类似扫雷区域）$3\times 3$ 格子中的点（可以证明点数为常数）是否与新加入的点构成更小的距离（$&lt;ans$）。

* 若没有，则直接将点加入链式前向星。

* 若有，则更新答案 $ans$，重构整个平面。

可以证明复杂度期望线性。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define For(i,j,k) for(register int i=j;i&lt;=k;i++)
#define gc getchar
template&lt;typename T&gt; void read(T &amp;x){
	x=0;char c=gc();bool f=0;
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=gc();}
	if(f)x=-x;
}
#define fir first
#define sec second
#define mkp make_pair
#define pll pair&lt;long long,long long&gt;
#define N 400010
#define M 1000000
#define B 13331
int n;
pll a[N];
ll ans,d=1;
struct hsh{
	int head[M],nxt[N];
	inline int num(pll x){ return (x.fir%M*B%M+x.sec%M+M+M)%M; }
	inline void ins(int x,pll y){ int z=num(y); nxt[x]=head[z]; head[z]=x; }
}mp;
ll dis(int x,int y){
	ll xx=a[x].fir-a[y].fir,yy=a[x].sec-a[y].sec;
	return xx*xx+yy*yy;
}
void rebuild(int x){
	For(i,1,x) mp.head[mp.num(mkp(a[i].fir/d,a[i].sec/d))]=0;
	d=ceil(sqrt(ans));
	assert(d*d&gt;=ans);
	For(i,1,x) mp.ins(i,mkp(a[i].fir/d,a[i].sec/d));
}
int res;
void check(pll x,int y){
	for(int i=mp.head[mp.num(x)];i;i=mp.nxt[i])
		if(i!=y &amp;&amp; (res==-1 || dis(y,i)&lt;dis(y,res))) res=i;
}
bool upd(int x){
	ll xx=a[x].fir/d,yy=a[x].sec/d;
	res=-1;
	check(mkp(xx-1,yy-1),x);
	check(mkp(xx-1,yy  ),x);
	check(mkp(xx-1,yy+1),x);
	check(mkp(xx  ,yy-1),x);
	check(mkp(xx  ,yy  ),x);
	check(mkp(xx  ,yy+1),x);
	check(mkp(xx+1,yy-1),x);
	check(mkp(xx+1,yy  ),x);
	check(mkp(xx+1,yy+1),x);
	if(res!=-1 &amp;&amp; dis(x,res)&lt;ans){
		ans=dis(x,res);
		return true;
	}
	return false;
}
signed main(){
	srand(time(NULL));
	read(n);
	For(i,1,n) read(a[i].fir),read(a[i].sec);
	random_shuffle(a+1,a+1+n);
	ans=dis(1,2);
	rebuild(2);
	For(i,3,n)
		if(!upd(i)) mp.ins(i,mkp(a[i].fir/d,a[i].sec/d));	
		else if(i&lt;n) rebuild(i);
	printf("%lld\n",ans);
    return 0;
}
```
&lt;/details&gt;

## 分治

我们先将点按照 $x$ 坐标排序，然后归并按 $y$ 排序。

对于一次归并 $\{[l,mid),[mid,r)\}\to [l,r)$，设**所有归并操作之前的** $mid$ 点的 $x$ 坐标为 $tar$，即分治中间劈开的竖向线。

假设我们当前已经求出的最小点对距离（包含 $[l,mid),[mid,r)$ 内部的所有点对）为 $ans$，我们在 $[l,r)$ 中找到所有 $x$ 坐标与 $tar$ 相差 $&lt;ans$ 的点集（由于归并排序，按 $y$ 轴大小升序）$S$，因为两个点集合并后最小距离只会在 $S$ 之间更新。

顺序遍历 $S$ 中的每一个点，和从这个点**往后 $5$ 个点**求距离更新答案，我们证明这样一定不会漏掉最近点对。

* * *

**证明：**

因为 $ans$ 一定不大于两侧的最小距离，所以设当前点为 $x$，只有在下图黄和绿部分里的点才可能更新最小距离：

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220813202453199-979370650.png)

而黄绿部分分别**内部不会存在距离 $&lt;ans$ 的点**（同时与黄部与 $x$ 点也不能距离 $&lt;ans$），可知最多只有 $6$ 个点可放（包含 $x$ 点），所以只要 $x$ 点后遍历 $5$ 个点即可。

* * *

所以最终复杂度即为归并复杂度 $O(n\log n)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 400005
#define Pos pair&lt;int,int&gt;
Pos operator-(Pos x,Pos y){ return mkp(x.fir-y.fir,x.sec-y.sec); }
int pw(int x){ return x*x; }
int Len(Pos x){ return pw(x.fir)+pw(x.sec); }
bool cmp(Pos x,Pos y){ return x.sec&lt;y.sec; }//sort by y coo
int ans=1e18,n,tot,b[N];
Pos a[N];
void solve(int l,int r){
	if(l&gt;=r) return ;
	int mid=(l+r)&gt;&gt;1,tar=a[mid].fir;
	solve(l,mid);
	solve(mid+1,r);
	inplace_merge(a+l,a+mid+1,a+r+1,cmp);
	tot=0;
	For(i,l,r) if(pw(a[i].fir-tar)&lt;=ans) b[++tot]=i;
	For(i,1,tot){
		For(j,1,5) if(i+j&lt;=tot){
			ckmn(ans,Len(a[b[i]]-a[b[i+j]]));
		}else break;
	}
}
signed main(){
	n=read();
	For(i,1,n) a[i]=mkp(read(),read());//2D exchanged
	sort(a+1,a+1+n);
	solve(1,n);
	printf("%lld\n",ans);
return 0;}
```
&lt;/details&gt;

结合上文的平面最远点对，可做 [P6247 [SDOI2012]最近最远点对](https://www.luogu.com.cn/problem/P6247)。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define db double
#define Pos pair&lt;db,db&gt;
Pos operator-(Pos x,Pos y){ return mkp(x.fir-y.fir,x.sec-y.sec); }
db operator^(Pos x,Pos y){ return x.fir*y.sec-x.sec*y.fir; }
db operator*(Pos x,Pos y){ return x.fir*y.fir+x.sec*y.sec; }
db Len(Pos x){ return sqrt(x*x); }
#define N 100010
Pos a[N];
int b[N],tot,n;
db ans=1e18;
void insert(int x){
	while(tot&gt;=2 &amp;&amp; b[tot]!=n &amp;&amp; ((a[x]-a[b[tot]])^(a[b[tot]]-a[b[tot-1]]))&gt;=0) tot--;
	b[++tot]=x;
}
db solve_far(){
	b[tot=1]=1;
	For(i,2,n) insert(i);
	Rof(i,n-1,1) insert(i);
	tot--;
	int pos=2;
	db res=0;
	Pos tmp;
	auto nxt=[&amp;](int x)-&gt;int{ return x==tot?1:x+1; };
	For(i,1,tot){
		tmp=a[b[nxt(i)]]-a[b[i]];
		while((tmp^(a[b[nxt(pos)]]-a[b[i]]))&gt;(tmp^(a[b[pos]]-a[b[i]]))) pos=nxt(pos);
		ckmx(res,Len(a[b[pos]]-a[b[i]]));	
		ckmx(res,Len(a[b[pos]]-a[b[nxt(i)]]));		
	}
	return res;
}
bool cmp(Pos x,Pos y){ return x.sec&lt;y.sec; }
void solve_close(int l,int r){
	if(l&gt;=r) return ;
	int mid=(l+r)&gt;&gt;1;
	db tar=a[mid].fir;
	solve_close(l,mid);
	solve_close(mid+1,r);
	inplace_merge(a+l,a+mid+1,a+r+1,cmp);
	tot=0;
	For(i,l,r) if(fabs(a[i].fir-tar)&lt;ans) b[++tot]=i;
	For(i,1,tot) For(j,1,5) if(i+j&lt;=tot)
		ckmn(ans,Len(a[b[i]]-a[b[i+j]]));
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cout&lt;&lt;fixed&lt;&lt;setprecision(4);
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i].fir&gt;&gt;a[i].sec;
	sort(a+1,a+1+n);
	db tmp=solve_far();//this doesn't change {a}, but the other changes
	solve_close(1,n);//result-&gt;ans
	cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;tmp&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

# 直线交点

这里直线用**点向式**表达。

设两条直线分别是 $p_0+t_0\vec v_0$，$p_1+t_1\vec v_1$（$p$ 是点坐标，$\vec v$ 是方向向量），由于是交点，所以要求 $t_0,t_1$ 使得
$$
p_0+t_0\vec v_0=p_1+t_1\vec v_1
$$
设
$$
\vec p=p_0-p_1
$$
这里当然可以硬解方程（拆出来其实是二元一次方程组）：
$$
\begin{cases}
t_0=\dfrac{\vec v_1 \times \vec p}{\vec v_0 \times \vec v_1}
\\
t_1=\dfrac{\vec v_0\times \vec p}{\vec v_0\times \vec v_1}
\end{cases}
$$
（其实只要知道上面一个 $t$ 就行了）

这个式子很美妙，我来说明一下咋优雅推。

我们将叉乘看作向量张成的三角形面积两倍。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221118180500802-621201135.png)

主要用到了等底三角形面积之比等于高之比。

(图片很明显了)

# 半平面交

以下“左侧”指向量的逆时针侧，“右侧”指顺时针侧。

每条直线都保留左侧的半平面。

先将平面加四条边构成外边框，旨在解决无限的情况。

将直线极角升序排序（`atan2(y,x)`），维护一个边集的双端队列。

顺序加入边，如果加之前队列尾端两条边交点在新加入的边的右侧（或非左侧）则 pop_back。

当然也可能踢掉队首的，当队列头端两条边交点在新加入的边的右侧则 pop_front。

如果加入前队尾和当前边平行的话保留更靠左的。

最后 while 队尾两条边交点在队首的右侧，pop_back。

上述 pop 条件是队列长度 $\ge 2$。

最后形成的如果是无限面积，则是无解。

如果最后队列中边集包含外边框中的任意一个，则是无限。

否则直线相邻两两交点就是半平面交凸包上的点集。

[P4196 [CQOI2006]凸多边形 /【模板】半平面交](https://www.luogu.com.cn/record/94583824)

[P3222 [HNOI2012]射箭](https://www.luogu.com.cn/record/94745887)

[P3194 [HNOI2008]水平可见直线]()

[P1663 山]()

[P2283 [HNOI2003]多边形]()

[P2600 [ZJOI2008]瞭望塔]()

[P3297 [SDOI2013] 逃考]()

# 最小圆覆盖

[P1742 最小圆覆盖](https://www.luogu.com.cn/problem/P1742)

给定$n$个点，求一个最小的圆包含所有的点。

**结论：** 如果点 $p$ 在集合 $S$ 的最小覆盖圆外，则 $p$ 一定在 $S\cup\{p\}$ 的最小覆盖圆上。

枚举第一个点 $i$，若不在目前圆内，设它为圆心。

枚举第二个点 $j$，若不在当前圆内，设当前圆为以 $i,j$ 为直径的圆。

枚举第三个点 $k$，若不在当前圆内，设当前圆为 $i,j,k$ 的外接圆。

显然最优解一定是两个点为直径的圆或者一个三角形的外接圆，否则肯定能缩的更小。那么这么枚举的正确性是比较显然的了。

写成伪代码的形式非常简单：

```cpp
圆 C;
for(i=1 to n)
{
	if(P[i] 不在 C 内)
	{
		C = {P[i], 0};
		for(j=1 to i-1)
		{
        	if(P[j] 不在 C 内)
			{
				C = {0.5*(P[i]+P[j]), 0.5*dist(P[i], P[j])};
				for(k=1 to j-1)
				{
					if(P[k] 不在 C 内)
					{
						C = 外接圆(P[i], P[j], P[k]);
					}
				}
			}
		}
	}
}

```

复杂度：

由于一堆点最多只有 $3$ 个点确定了最小覆盖圆，因此 $n$ 个点中每个点参与确定最小覆盖圆的概率不大于 $3/n$。

所以，每一层循环在第$i$个点处调用下一层的概率不大于 $3/i$。

那么设算法的三个循环的复杂度分别为$T_1(n),T_2(n),T_3(n)$，则有：

$$\begin{aligned}T_1(n) &amp; = O(n) + \sum_{i=1}^{n}{\frac{3}{i}T_2(i)}\\T_2(n) &amp; = O(n) + \sum_{i=1}^{n}{\frac{3}{i}T_3(i)}\\T_3(n) &amp; = O(n)\end{aligned}$$


不难解得，$T_1(n)=T_2(n)=T_3(n)=O(n)$。

[代码](https://www.luogu.com.cn/record/94780919)

[P2533 [AHOI2012]信号塔](https://www.luogu.com.cn/record/94785919)

# 梯形剖分

[CF223D Spider](https://codeforces.com/contest/223/problem/D)

做完这道题可以变身 Spider Man。

给你一个不自交/自切的多边形，内部是空腔。有一个蜘蛛要从一个多边形顶点到另一个，可以用两种方式走：

* 沿着多边形边走。

* 从一个位置松手，垂直下落，直到碰到多边形的边或点。

求最短欧氏距离（下落距离也算距离）。

多边形 $n\le 10^5$。

* * *

结论：下落只会从顶点下落或下落到顶点。

反证：若不是，必然可以调整下落的 $x$ 坐标使得更优。

所以如果求出所有可能的下落方案，则可以跑 dijkstra $O(n\log n)$ 解决单源有向图最短路。

考虑一条竖直的直线从左往右扫，维护与直线相交的多边形的边以及这条边的上 / 下方向是空腔，这个可以 set 实现，比较函数引用全局变量（直线的 $x$ 坐标），空腔方向可以由 set 前驱后继推得。

扫到顶点时判断是否可以从上方落到这里 / 可以下落到哪里。

细节巨多，5ab 称之为 shit，但是只要条理清楚还是好写的。

[代码](https://codeforces.com/contest/223/submission/208283190)

# 多边形重心

多边形重心**不等于**顶点坐标的平均数，反例：在一个多边形的一条边上不断加点，重心不变但求出来的位置变了。

但是三角形是对的，所以将多边形三角剖分后把每个三角形看作质点后加权平均即为重心。

例题：CF975E Hag's Khashba

# 向量的加权平均

两个不同向量 $A,B$，$(1-k)A+kB$ 的点集是过 $A,B$ 的直线，证明考虑这条直线的点向式 $A+k(B-A)=(1-k)A+kB$。

例题：CF605C Freelancer's Dreams

就是多个向量乘系数加起来要到 $x\ge p\land  y\ge q$ 的区域。

先考虑只能到 $(p,q)$ 咋做。由刚刚的结论，我们将向量求凸包，接下来求原点到 $(p,q)$ 的射线和凸包的交点即可。

接着考虑原问题，发现就是 $(p,q)$ 可以向上和向右移动，转化成这些向量整体向左和向下移动，也就是加上 $(\max_x,0)$ 和 $(0,max_y)$ 这两个向量，一样做即可。

# 旋转扫描线

[My Blog - P6237 [CEOI2012] Printed Circuit Board](https://www.cnblogs.com/shaojia/p/simu.html#draw--p6237-ceoi2012-printed-circuit-board)

[My Blog - CF1860F Evaluate RBS](https://www.cnblogs.com/shaojia/p/simu.html#c--cf1860f-evaluate-rbs)

# 两两斜率极角排序后 DP

字面意思，是一种 trick。

P2924 [USACO08DEC] Largest Fence G

枚举凸包出发点 $x$，$f_i$ 表示从 $x$ 出发经过目前枚举过的斜率的子序列到达 $i$ 点的最多的点数，按极角顺序枚举斜率转移即可，最后答案为 $\max f_x$。

复杂度 $O(n^3)$。

CF852H Bob and stages

与上一题的区别是：最大化面积，凸包内部没有点，恰好 $k$ 个点。

最大化面积可以在转移的时候从最大点数改为最大面积（从 $x$ 点三角剖分面积之和），多记录一维点数 $[0,k]$，如果我们预处理所有三元点对形成的三角形内部有没有别的点就做完了。

至于这个预处理，显然有 $O(n^4)$ 做法，我们也可以维护两两点之间有向直线一侧的点集（用 bitset 存），三角形内无点等价于三个 bitset 与起来为 $0$，复杂度 $O(n^4/w)$。

其实我们有 $O(n^3)$ 预处理做法：枚举一个点 $x$，将其他点以 $x$ 为原点极角排序，再枚举点 $y$，再从 $y$ 开始逆时针枚举 $z$，扫 $z$ 的时候维护上一次三角形内无点的 $z'$，$z$ 合法的充要条件是 $z'$ 不在 $(x,y,z)$ 三角形内。

![](https://img2023.cnblogs.com/blog/2213867/202310/2213867-20231013101629422-1421184944.png)

👆大概是这个意思 $z_1$ 是新的合法，将会成为新的 $z'$，$z_2$ 不合法。

复杂度 $O(n^3k)$。

# 平面两两欧几里得距离之和

[欧几里得距离之和 - Problem - QOJ.ac](https://qoj.ac/problem/55)

发现如果是一维 $(x_i,0)$ 的话是非常好做的：
$$
x_1\le\dots\le x_n
\\
ans=\sum_{i=1}^n\left((i-1)x_i-\sum_{j=1}^{i-1}x_j\right)
$$
由于精度要求只有 $10^{-4}$，考虑用足够多的一维来近似二维。

具体地，枚举 $\forall x\in[0,B)\cap\mathbb Z$，将所有点正交映射到极角为 $\theta=\frac{\pi x}{B}$ 的直线上，作上述的一维问题。

对于相距 $L$ 的点对，当 $\theta\sim U[0,\pi)$，我们得到的一维问题答案的期望是：
$$
\frac{2}{\pi}\int^{\pi/2}_0 L\sin\theta\,\text{d}\theta=\frac{2}{\pi}L
$$
所以我们将 $B$ 个一维问题的答案求平均值后 $\times\frac{\pi}{2}$ 即为近似答案。

误差分析我不会，反正取 $B=100$ 过了。

[Submission #211663 - QOJ.ac](https://qoj.ac/submission/211663)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16491700.html</id>
    <title type="text">3b1b 题 多项式+单位根-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-18T11:15:00Z</published>
    <updated>2022-07-18T11:15:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16491700.html" />
    <content type="text">[原视频链接](https://www.bilibili.com/video/BV1R34y1W7Xn)

我这里梳理一下思路~~，并夹带个人私货。~~

&gt; $S=\{1,2,\dots,2020\}$，问有多少个 $T\subseteq S$，使得 $T$ 的元素和为 $5$ 的倍数（空集的元素和定义为 $0$）。
&gt; 
&gt; 要手算能得出答案的方法。

我们很快发现很难暴力算，想到背包，即多项式
$$
f(x)=\prod_{i=1}^{2020}(1+x^i)
$$
其中 $x^{5k}(k\in\N)$ 的系数和即为答案。

但是这出锅了，我们很难统计上述的答案。

我们先考虑简单版本：$x^{2k}(k\in\N)$ 的系数和。

发现我们可算 $f(1),f(-1)$，然后 $\frac{f(1)+f(-1)}{2}$ 即为所求。

发现上述方法可行的主要原因是 $f(1),f(-1)$ 中 $x$ 的奇数次幂被抵消了。

那 $x^{5k}(k\in\N)$ 是否能抵消出来呢？

想到单位根，即 $\omega^5=1$。

学过 FFT 的小盆友都知道（相当于傅里叶变换）：
$$\begin{aligned}
\sum_{i=0}^4 \omega^{ik}&amp;=5\cdot[ik\bmod 5=0]
\\&amp;=5\cdot[k\bmod 5=0]
\end{aligned}$$
我们求 $f(\omega^0),\dots,f(\omega^4)$，由上面这个柿子，得到
$$\begin{aligned}
\frac{1}{5}\sum_{i=0}^4f(\omega^i)&amp;=\frac{1}{5}\sum_{j}\sum_{i=0}^4([x^j]f)\omega^{ij}
\\&amp;=\frac{1}{5}\sum_{j}([x^j]f)\sum_{i=0}^4\omega^{ij}
\\&amp;=\sum_{j}([x^j]f)[j\bmod 5=0]
\end{aligned}$$
即为答案。

（这巧妙运用了单位根循环的特性）

所以我们的任务变为了求 $f(\omega^0),\dots,f(\omega^4)$。

若有 $x^5=1$ 的条件则
$$
f(x)=g(x)^{404}
\\
g(x)=\prod_{i=0}^4(1+x^i)
$$
由于 $5$ 是素数，得到
$$
\{\omega^{i},\omega^{2i},\dots,\omega^{4i}\}=\{\omega^{j},\omega^{2j},\dots,\omega^{4j}\}
\\
(1\le i,j\le4)
$$
所以
$$
f(\omega^i)=f(\omega^j)\quad(1\le i,j\le4)
$$
所以答案简化成
$$
\frac{f(\omega^0)+4f(\omega^1)}{5}=\frac{f(1)+4f(\omega)}{5}=\frac{2^{2020}+4f(\omega)}{5}
$$
任务简化成求 $f(\omega)$，等价于 $g(\omega)$。
$$\begin{aligned}
g(\omega)&amp;=\prod_{i=0}^4(1+\omega^i)
\\&amp;=-\prod_{i=0}^4((-1)-\omega^i)
\end{aligned}$$
这时候，我们回到开始的开始……单位根的定义 $x^5-1=0$，我们将 $x^5-1$ 因式分解得到
$$
x^5-1=\prod_{i=0}^4(x-\omega^i)
$$
所以上面 $g(\omega)$ 的柿子相当于将 $x=-1$ 带入了，所以
$$
g(\omega)=-((-1)^5-1)=2
$$
皆大欢喜！我们最终的答案为
$$
\frac{2^{2020}+4\times 2^{404}}{5}=\frac{2^{2020}+2^{406}}{5}
$$
（验算一下分子真的是 $5$ 的倍数）

当然如果将 $2020$ 换成非 $5$ 的倍数（如 $2022$）也是可做的，但是
$$
f(\omega^i)=f(\omega^j)\quad(1\le i,j\le4)
$$
就不成立了，所以我们 $5$ 个 $f$ 都要算（甚至可能后面 $(1+\omega)$ 的因子消不完），较为麻烦。

当然将 $5$ 换成别的素数也是可行的，非素数的做法也类似。 </content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16499806.html</id>
    <title type="text">子序列自动机-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-20T12:52:00Z</published>
    <updated>2022-07-20T12:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16499806.html" />
    <content type="text">[照着抄的](https://www.luogu.com.cn/blog/BlankAo/sqam1)

## 介绍

~~vector 就是自动机。~~

子序列自动机，是接受且仅接受一个字符串的子序列的自动机，是一个处理子序列的锐利武器。

对于一个字符串 $S$，我们可以通过使用子序列自动机得到它的每一个子序列，并方便地去维护、查询它们，让人惊喜不已。

~~相信大家已经知道咋建自动机了。~~

设字符集为 $\Sigma$，设 $S$ 的下标 $1\sim n$。

我们维护指针 $to_{i,c}$，其中 $i$ 是一个下标、$c\in\Sigma$。它代表 $S$ 的第 $i$ 个位置后，**第一个**字符 $c$ 所处的位置。如果 $i$ 位置后没有 $c$ 了，我们可以默认它指向 $n+1$。

我们发现这样的定义让 $to_{0,c}$ 也有了意义。

而子序列自动机就是这样。点为 $0\sim n$，对于所有 $i\in[0,n],c\in\Sigma$，若 $to_{i,c}\ne n+1$，则从 $i$ 向 $to_{i,c}$ 连一条边。

这样，**从 $0$ 出发的任意一条路径都是一个子序列**，而且他们**本质不同**，且覆盖所有。

本质不同的原因是前文所述的 **「第一个」**，这样**贪心**选择子序列**不重不漏**！

当 $|\Sigma|$ 较小的时候，我们当然可以这样建立子序列自动机，这样是 $O(|\Sigma|n)$。

但是 $|\Sigma|$ 较大时，我们不得不优化：

具体地，我们将每种字符开个 vector，升序存这种字符在 $S$ 出现的下标。也不用去真的建自动机的边，只要每次跳边时在 vector 二分查找（upper_bound）即可。

~~所以说 vector 就是自动机。~~

这样建自动机 $O(n)$（若值域需离散化则 $O(n\log n)$），但是跳边要带 $\log$。

## 例题

### P5826 - 【模板】子序列自动机

&gt; 询问 $B$ 是否是 $S$ 的子序列。

注意：第一篇 WYXkk 的题解不是本文所说的子序列自动机，一扶苏一 的题解才是。

直接在自动机上跑即可。

### P4608 - [FJOI2016]所有公共子序列问题 &amp; P1819 公共子序列 &amp; P3856 [TJOI2008]公共子串（三倍经验）

&gt; 求两个字符串 $S,T$ 的本质不同公共子序列个数。
&gt;
&gt; 长度 $\le 3000$

相当于在两个自动机上同时跑。

设 $f(i,j)$ 为从 $S_i$ 和 $T_j$ 开始的公共子序列个数。

设两个的 $to$ 分别为 $to,to'$，则
$$
f(i,j)=\sum_{c\in\Sigma}f(to_{i,c},to_{j,c}')
$$
DP 就做完啦！</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16503449.html</id>
    <title type="text">杭电多校 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-04T12:33:00Z</published>
    <updated>2022-08-04T12:33:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16503449.html" />
    <content type="text">[wsyear 的游记](https://www.cnblogs.com/wsyear/p/2022HDUMultiSch.html)

~~其实没有游，都在ez机房。~~

人生第二次打 ACM（第一次算是 THUPC 吧（没比，场外观摩了 wsyear 三人组））。

（好多题的题解在 2022 简思里）

## 7.19

中午去面馆吃面，会到二中已经 11:55 ，跑去机房就开始了。

先开了一个 1009，发现是简单计算几何，过了（但是sb错误 WA 了好几发）。

然后开 1003，发现是一个背包，暴力做要 $O(n^3)(n=1000)$，然后用 bitset 过了（很快），赛后发现正解就是 bitset 优化背包。

最后就是 1007 毒瘤题了（具体见 2022 简思 HDU 7144.Treasure），我写了个 Kruskal 重构树+树上倍增+树剖+线段树，调到快结束的时候过了（原因是 DFS 爆栈了），1900多ms（时限 2s）。

赛后发现正解是 $O(10n\log n)$ 比我少一个 $\log$。

正解是 Kruskal 重构树+树上倍增+DFS 序+树上差分+树状数组。

然后 hdu 把题目放题库了，我交了发现 TLE，然后改成正解 TLE，然后卡了 2 天的常数，最后发现 hdu 下发的 std 也 TLE/px。

反正最后是没有卡进 2s。

接下来几天状态不好就是因为这道题ex，难写，毒瘤（但赛场上过了真的爽）。

Solved 6 problems，Rank 79。

## 7.21

吸取 Day1 的教训，早点出去吃饭，顺便换了一家快餐店。

到场离开始还有几分钟，和 wsyear 打了一场 Generals 2V2，成功偷家。

看 1009

![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220721200508639-2045908546.png)

名称就来了兴趣，然后就过了（就是素因数分解）。~~栓Q。~~

然后开了 1001，发现又是树剖 + 线段树（啊啊啊啊啊树剖远离我），但是这道题还好写，所以就一发过。

然后是 1008 Keyboard Warrior（键盘侠），然后 hash 搞过（base 写了 19491001 和 13331/ww）。

但是特判有些坑，所以 WA 了两发。

（发现我做的题ez别的队都是比赛快结束时才写出来）

看 1006，发现是概率期望题，比较毒瘤，推出柿子只有算量 $10^9$ 的方法，就没写。

然后帮 wsyear 看了 1005，但是他没写出来，好可惜。

排名海星 Solved 8 problems，Rank 56。

## 8.2

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220804200305766-280336497.png)

开场看到 Slipper，被吸引，然后发现就是一个优化建图的 dij，切了。

然后 wsyear 说 1012 是水题，然后~~一发罚时~~切了。

1010 cxny 和 wsyear 说 ez 他们想复杂了（其实确实是签到）然后博弈细节巨多，WA 了三发。

1006 好题，我先把柿子写出来了，然后 wsyear 套一个多项式优化背包就过了，当时周（z）转（z）了好久。

&gt; 很激动，第一次做多项式题就过了。——wsyear

接下来由于我没睡好，我和 cxny 开始打 gen（时不时帮帮 wsyear 看积性函数），wsyear 写 1002。

&gt; 于是去看 1002，证了一下发现这是个积性函数，可以直接 Min_25 筛。但是以前没写过，怎么办呢？贺板子。
&gt; 
&gt; 先贺了 OI-wiki 的板子，调了半天结果 TLE 了，十分愤怒，直接弃题。——wsyear

Solved 5 problems，Rank 92。

非常演，赛后发现 1002 的做法非常巧妙，已放在简思短解。

## 8.4

~~我发现我每次开场总能先蒙到水题（盲狙一直很准~~

今天感觉神清气爽，开干！（打滴滴差点迟到

开场开 1006 ![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220804202405037-774783537.png)

因为名字短看起来好做。

没想到蒙到签到题了，直接 $O(n)$ 算子树 sz 等基本操作即可。

6min 半拿下 1006，~~我是快男！~~

然后开 1009，发现是经典的问题：两个不同比例的世界地图随意叠放，必然有一个点在两张地图上重合。

然后被卡常了一发，过了。

1009 yzc、hy 说啥高斯消元四元方程，我偷笑（

（其实就是基础的计算几何和二元一次方程组

此时 wsyear 和 cxny 好像没有缓过来，wsyear 来帮我看 1008。

然后推了好久（其实没必要的，想多了），我写过了，相当于这道题我和 wsyear 平分。

然后 wsyear 从网上粘板子，把 1010 过了。

cxny 搞了好久发现又想多了，把 1012 过了，代码非常简短，~~我们都说 cxny 在演。~~

接下来 wsyear 把 1007 自己的见解告诉我，我开搞。

大概是一道同余原根的题目，我想想想推推推发现有 BSGS + exgcd
 的算法，但是时间有点卡。

~~然后作弊看别的队的代码，发现就是这样写的，我自己骄傲死。~~

正准备写，wsyear 又看了 cxy 他们队直接逆元 + unordered_map 过，时间复杂度飞快，我非常尴尬，他们嘲笑我qwq。

然后我就写 cxy 的写法（忘记判 $0$ 罚时 $\times 1$）过了。

然后~~礼尚往来~~我告诉 wsyear 1011 我的心得，然后搞了好久我们俩。

~~最后绷不住，直接看 wxw 队的代码，wsyear 直接抄，过不了 TLE。~~

回头检查一下发现他们算次是 $10^9$ 级别的，本因过不了，但是他们就蜜汁过了。

wsyear 改了一下，从枚举因数到倍数 $\sqrt n\to \log n$，过了。

当时 wsyear 不会写线性筛积性函数~~被我嘲讽~~，我本想在 wsyear 之前写出来，结果失败了（差一点点，但是我交后用时 $&lt;$ wsyear 的，开心）。

然后我就在琢磨 wxw 队的柿子的奥妙，好久终于懂了。

此时 wsyear 就一路猛杀，调参把 1002 过了。

~~cxny 抱怨说为啥你俩讨论不带我~~

最后，我：4 题，wsyear：3 题，cxny：1 题。

~~cxny 太演了。~~

Solved 8 problems，Rank 29，ez 没有垫底。

这场非常爽。

## 8.9

由于 wsyear 上次直接把我的抄到他的 blog 了，所以他再抄的话我~~透死他~~（（（

（我们把 zhy 挖过来了~~非常无耻~~，~~因为 cxny 太演了~~

开场看到 1004 Black Magic，~~感觉这首歌很好听~~感觉好做，发现真的就是水题，就是细节有点多，WA 两发过。

结果我不是我们 team1035 第一个 A 的，wsyear 和 zhy 撞题一起把 1008 博弈论过了，非常尴尬。

然后我去看 1003，发现就是一个简单的树形 DP（赛后发现题解好复杂）直接哐哐哐写，TLE，一直以为是 IO 的问题，结果

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220809193328884-1402252976.png)

贡献 $5$ 发罚时（快来喷我（wsyear 赛时一直在打我，~~看起来他有点 S 倾向~~

之后 zhy 超强援助开始打 1001。

我和 wsyear 开始研究 1006，发现是一个较为 ex 的数位 DP，然后听到隔壁 team1036 的 xsc 说他会了（藐视），我们更加紧张，于是 wsyear 催促我写。

真的非常复杂的数位 DP 啊，四维 + 分讨，3K 代码。

而且中间还 UB+小错误，真的不是人能调的，wsyear 写了一个对拍，拍出来了，我排查掉头发，终于 50min 解出来了，WA*2。

1006 AC 提交之前：

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220809193545424-1703615660.png)

正当我刚刚说的排查掉头发时，cxny 开始和同桌的 zqs 打 florr，还时不时戳我让我看游戏局面，当时我非常恼火。

&gt; cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！cxny 不要再演了！！

我和 wsyear 探讨 1002，发现就是 DP（可能是树形？），发现一开始想复杂了，然后 wsyear 通过不懈努力把 1002 过了。

快结束时，zhy 过了 1001，贡献 $4$ 罚时（祝贺）。

~~最后 xsc 1006 一发都没有交，怎么回事呢。~~

Rk 86 solve 6

## 8.11

上午本想爆切 tg，结果发现 lj 的 tg 模拟赛难度不允许，切到一半有点不爽。

开场 wsyear 盲狙 $3$ 道签到题（1004 1001 1008）。

&gt; 非常的爽，抢人头，一道树形 dp 第一遍还推假了，非常傻逼。——wsyear

然后我发现一道类似整除分块的题 1011，第一次非常 sb 地 WA 了，后面过了。

然后 cxny 在写 $O(n\sqrt{n})$ 的 1007，难卡过去，7A，罚时多。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220811224911276-2076221073.png)

↑ 但是 xsc 更惨，换了桶排 47 发才过。

此时我在写 1005，推结论 + 三棵线段树。

wa 了一发，根本调不了，与别的过的队拍，发现 $3$ 次 sb 错误，过了。

然后 wsyear 把 1002 过了，写的时候非常激动。

接下来我写 1010，是凸包板子 + 结论，结果 zhy 抢在我之前过了……

&gt; 不要再骂 cxny 演了！不要管他了，他是演王！

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220811225403692-1741946202.png)

zhy 的压线提交，结束时间 17:00。

题数：ShaoJia*2，wsyear*4，cxny*1，zhy*1。

solve 8 rk 50。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220811225731541-1247683723.png)

总排名上升到 45。

## 8.16

寄这场忘记记了，这里是 8.18 的 ShaoJia 在写。

wsyear 先开场两道签到题切了，非常强大。

然后一起想 1008，一开始以为是某一种容斥，后来写写拍拍发现错了，后来发现更暴力的容斥可过。

此时我把 1001 过了，只是一个二进制翻转 + 排序即可。

然后我就把 1006 贺了，非常巧妙的解法。

cxny 把 1003 过了。

rk51 solved 6 我有点颓。

## 8.18

最后一场！！！

wsyear 开场 1007。

然后 cxny 1003 都 tql。

wsyear 发现 1001 是网络流，然后秒过。

wsyear 又过了 1009。

这段时间我都在和 zhy 讨论 1004，发现难推，写了一个暴力，然后连猜两个结论，第一个结论证出来后我直接开写，过了。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220821220409041-1444033190.jpg)

直接拿 ez rk1。

（**有一种闪击波兰的美感**）

然后没过半小时又被超了。

然后我和 wsyear 讨论 1002，我推柿子他写，然后我柿子多推了个 $1$，wsyear 连交几发都没过，改完一发过，wsyear 开始打我。

然后一起想 1008，有 LCT 启发式合并 树剖 倍增四种写法，然后 wsyear 挑了一种过了。

rk41 solved 7

## 结语

终于算是结束了，10 场真的练耐力。

最终我们队总分 rk46。

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220821220931362-146194246.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16514646.html</id>
    <title type="text">重修 ST 表 与 RMQ-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-24T07:55:00Z</published>
    <updated>2022-07-24T07:55:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16514646.html" />
    <content type="text">RMQ 的查询是可以 $O(1)$ 的 qwq。

具体用 ST 表取前 $2$ 的幂和后 $2$ 的幂的最值的最值即可。

同理，只要树形不变，两点的 $lca$ 是可以 $O(1)$ 求的（dfs 序上 RMQ）

但是前提都是空间 $O(n\log n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16524726.html</id>
    <title type="text">树的中心重心直径一些特殊的东西-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-27T06:27:00Z</published>
    <updated>2022-07-27T06:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16524726.html" />
    <content type="text"># 中心

&gt; 所有直径的中点。

所以中点可能是一条边。

# 重心

&gt; 最大的子树最小的点。

（“子树”都是指无根树的子树，即包括“向上”的那棵子树，并且不包括整棵树自身。）

* 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。

* 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。

* 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。

* 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

# 直径

&gt; 树上任意两节点之间最长的简单路径。

求法为两遍 DFS。

推论：

&gt; $(u,v)$ 为树的直径，当且仅当 $u$ 是 $v$ 的最远点，且 $v$ 是 $u$ 的最远点。

一棵树可以有多条直径，在多条直径之间有以下结论：

&gt; 任意两条直径必然有公共点，且长这样：
&gt;
&gt; ![](https://img2022.cnblogs.com/blog/2213867/202207/2213867-20220727144250301-1019735562.png)
&gt;
&gt; 其中 $A=B,D=E,A+C\ge D,D+C\ge A$。

进一步

&gt; 对于任意一点 $x$，$x$ 距最远点 $d$ 距离。
&gt;
&gt; 则任意一条直径 $(s,t)$，$dis(s,x)=d \lor dis(t,x)=d$。

# 总结

遇最远点/最长距离，考虑直径。

遇直径/距离和，考虑重心/中心。

“研究距离，考虑直径” “研究直径，考虑中心”</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16525300.html</id>
    <title type="text">Boruvka-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-27T08:21:00Z</published>
    <updated>2022-07-27T08:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16525300.html" />
    <content type="text">这是一个古老的算法了，结果我不会。

咕咕咕咕咕咕咕咕咕</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16533771.html</id>
    <title type="text">Sublime Text 配置-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-17T13:40:00Z</published>
    <updated>2022-08-17T13:40:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16533771.html" />
    <content type="text">网上信息良莠不齐，这里总结一下。

（以下内容本人 Win11 实测有效）

# 配置 C++ 编译运行环境

## 0

安装 Sublime Text （最好汉化）（简称 st），C++ 编译器。

## 1

st -&gt; ctrl+shift+P -&gt; Package Control: Install Package -&gt; ConvertToUTF8 安装。

解决字符编码问题。

## 2

st -&gt; 工具 -&gt; 编译系统 -&gt; 新建编译系统 -&gt; 用以下替换：

&lt;details&gt;
&lt;summary&gt;点击查看&lt;/summary&gt;

```text
{
    "cmd":[
    "g++","${file}",
    "-std=c++17","-Wall","-Wextra","-Wshadow","-O2",
    "-o","${file_path}\\\\${file_base_name}","&amp;&amp;",
    "start","cmd","/c",
    "${file_path}\\\\${file_base_name} &amp; echo. &amp; echo / = = = F I N = = = / &amp; pause"
    ],
    "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "${file_path}",
    "selector": "source.c, source.c++",
    "shell":true,
    "encoding":"cp936", 
    "variants":
    [
        {
            "name" : "qwq",
            "cmd" : ["start", "cmd", "/c", "echo  = = = qwq = = =  &amp; pause"]
        }
    ]
}
```
&lt;/details&gt;

↑ 这里可调编译运行参数。

保存为 ...\Packages\User\Cpp_My.sublime-build （默认的路径）（Cpp_My 可改）。

## 3

st -&gt; 工具 -&gt; 编译系统 -&gt; Cpp_My 勾选

## 4

写好 .cpp 后 ctrl+shift+B 调整操作。

ctrl+B 沿用上一次的操作。

**注意文件路径中文件夹名不要有空格。**

## 5

按 F7 或 ctrl+b 可以 build，但是我~~手短~~喜欢 alt+b。

st -&gt; 首选项 -&gt; 快捷键设置 -&gt; ctrl+f 找到 "ctrl+b" -&gt; 替换为 "alt+b" 后 ctrl+s 走人。

# 破解许可

## 0

安装 Notepad++（简称 npp）。

## 1

npp -&gt; 插件 -&gt; 插件管理 -&gt; 搜索 `HEX-Editor` 并安装。

安装好后重启 npp。

## 2

`C:\Windows\System32\drivers\etc\hosts` 文本后面**追加**：

```
127.0.0.1 www.sublimetext.com 
127.0.0.1 license.sublimehq.com
```

前者防止 st 更新，后者防止 st 注册码二次验证。

## 3

找到 sublime_text.exe 的位置，用 npp 打开，插件 -&gt; HEX-Editor -&gt; View in HEX。

然后 ctrl+F 查找 `97 94 0D`，改为 `00 00 00`。

注意这里得一个一个数改，删掉再填上会崩。

**如果没有进行上述操作下面烂大街的证书将不能成功激活 sublime。**

## 4

st -&gt; 帮助 -&gt; 输入注册码：

&lt;details&gt;
&lt;summary&gt;点击查看&lt;/summary&gt;

```text
—– BEGIN LICENSE —–
Mifeng User
Single User License
EA7E-1184812
C0DAA9CD 6BE825B5 FF935692 1750523A
EDF59D3F A3BD6C96 F8D33866 3F1CCCEA
1C25BE4D 25B1C4CC 5110C20E 5246CC42
D232C83B C99CCC42 0E32890C B6CBF018
B1D4C178 2F9DDB16 ABAA74E5 95304BEF
9D0CCFA9 8AF8F8E2 1E0A955E 4771A576
50737C65 325B6C32 817DCB83 A7394DFA
27B7E747 736A1198 B3865734 0B434AA5
—— END LICENSE ——
```
&lt;/details&gt;

# 自动头文件

st -&gt; ctrl+shift+P -&gt; Package Control: Install Package -&gt; FileHeader 安装。

然后

st -&gt; 首选项 -&gt; 浏览插件目录 -&gt; FileHeader -&gt; template -&gt; header -&gt; C++.tmpl 打开

改成

```text
/*
* Author: ShaoJia
* Last Modified time: {{last_modified_time}}
* Motto: We'll be counting stars.
*/


```

（注意最后的两个换行最好别漏掉）

保存即可。

打开新文件或删空一个文件后保存再刷新页面后会出现这个片段。

# 爬样例

先装好 Competitive Companion 浏览器插件，然后按[这个](https://www.luogu.com.cn/problem/U173674)做即可（不用 sublimelinter）。

# 告别

别的不多说了，基本不用了，原因：

* c++ python java 干不过 cp editor 精。

* 别的语言干不过 notepad++ 广。

* 大文件展示 notepad++ 也行。

* 不过离开 sublime 交互题测试还得靠 dev c++。

再见了 sublime text，感谢和你的时光。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16537265.html</id>
    <title type="text">整体二分-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-31T07:37:00Z</published>
    <updated>2022-07-31T07:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16537265.html" />
    <content type="text">[OI wiki](https://oi-wiki.org/misc/parallel-binsearch/)

个人感觉整体二分就像归并的逆操作。

### P3527 [POI2011]MET-Meteors &amp; LOJ2169. 「POI2011 R3 Day2」流星 Meteors

### P1527 [国家集训队]矩阵乘法

### P3332 [ZJOI2013]K大数查询

[自己去看原题吧](https://www.luogu.com.cn/problem/P3332)

树套树 $\times$，整体二分 $\sqrt{}$（离线算法常数吊打树套树）。

我们每次可以定一个阈（yù）值 $mid$，通过线段树判断每一个询问的答案是否 $\ge mid$：

* 若是，则归到第二类。

* 若否，则**将询问的要求 $-$ 当前 $\ge mid$ 的数量**，然后归到第一类。

将修改按照值也分为两类，**同一类中的询问和修改的顺序要保持原样**。

撤销刚才的线段树操作，递归做即可。

&lt;details&gt;
&lt;summary&gt;一定要点开来看的代码，不然大概率听不懂&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 50002
struct node{ int op,l,r,c,ans; }q[N];
int n,m,a[N],a1[N],a2[N],t1,t2,t[N&lt;&lt;2],lz[N&lt;&lt;2];
#define mid ((l+r)&gt;&gt;1)
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
void tag(int rt,int l,int r,int val){
	t[rt]+=(r-l+1)*val;
	lz[rt]+=val;
}
void pd(int rt,int l,int r){
	if(lz[rt]){
		tag(ls,l,mid,lz[rt]);
		tag(rs,mid+1,r,lz[rt]);
		lz[rt]=0;
	}
}
void add(int rt,int l,int r,int x,int y,int val){
	if(x&lt;=l &amp;&amp; r&lt;=y){
		tag(rt,l,r,val);
		return ;
	}
	pd(rt,l,r);
	if(x&lt;=mid) add(ls,l,mid,x,y,val);
	if(y&gt;mid) add(rs,mid+1,r,x,y,val);
	t[rt]=t[ls]+t[rs];
}
int que(int rt,int l,int r,int x,int y){
	if(x&lt;=l &amp;&amp; r&lt;=y) return t[rt];
	pd(rt,l,r);
	int res=0;
	if(x&lt;=mid) res+=que(ls,l,mid,x,y);
	if(y&gt;mid) res+=que(rs,mid+1,r,x,y);
	return res;
}
void solve(int l,int r,int L,int R){
	if(L&gt;R || l&gt;r) return ;
	t1=t2=0;
	For(i,L,R){
		if(q[a[i]].op==1){
			if(q[a[i]].c&gt;=mid){
				a2[++t2]=a[i];
				add(1,1,n,q[a[i]].l,q[a[i]].r,1);
			}else{
				a1[++t1]=a[i];
			}
		}else{
			int tmp=que(1,1,n,q[a[i]].l,q[a[i]].r);
			if(tmp&gt;=q[a[i]].c){
				q[a[i]].ans=mid;
				a2[++t2]=a[i];
			}else{
				q[a[i]].c-=tmp;
				a1[++t1]=a[i];
			}
		}
	}
	For(i,L,R){
		if(q[a[i]].op==1){
			if(q[a[i]].c&gt;=mid){
				add(1,1,n,q[a[i]].l,q[a[i]].r,-1);
			}
		}
	}
	For(i,1,t1) a[L+i-1]=a1[i];
	For(i,1,t2) a[L+t1+i-1]=a2[i];
	int gap=L+t1;
	solve(l,mid-1,L,gap-1),solve(mid+1,r,gap,R);
}
signed main(){
	n=read(),m=read();
	For(i,1,m) q[i]=(node){read(),read(),read(),read(),0};
	iota(a+1,a+1+m,1);
	solve(-n,n,1,m);
	For(i,1,m) if(q[i].op==2) printf("%lld\n",q[i].ans);
return 0;}
```
&lt;/details&gt;

**本题的注意事项：**

由于有类似于偏序的关系，我们只能将整体二分写成削弱询问的形式：

```cpp
void solve(l,r,part){
	decrease the queries to the left part while splitting into two parts by value mid
	revoke the operations have just done
	solve(l,mid-1,leftpart)
	solve(mid+1,r,rightpart)
}
```

而不能写成撤销的形式：

```cpp
void solve(l,r,part){
	split into two parts by value mid 
	solve(l,mid-1,leftpart)
	revoke
	solve(mid+1,r,rightpart)
}
```

（所以说整体二分没有固定的写法，因题而异）

### P3834 【模板】可持久化线段树 2

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822201803015-91440364.png)

我还是用常数小的 $O(n\log^2 n)$ 整体二分艹过去了，抱歉（

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
//global erfen
#define N 200010
#define low (x&amp;(-x))
struct Que{
	int l,r,k;
}q[N];
int b[N],a[N],c[N],n,m,lim,s[N],s0[N],s1[N],t0,t1,ans[N];
vector&lt;int&gt; p[N];
void add(int x,int y){
	while(x&lt;=n){
		c[x]+=y;
		x+=low;
	}
}
int que(int x){
	int res=0;
	while(x){
		res+=c[x];
		x-=low;
	}
	return res;
}
void work(int val,int opt){ for(int i:p[val]) add(i,opt); }
bool calc(Que x){ return que(x.r)-que(x.l-1)&gt;=x.k; }
void solve(int l,int r,int L,int R){
	if(l&gt;r || L&gt;R) return ;
	int mid=(l+r)&gt;&gt;1;
	For(i,l,mid) work(i,1);
	t0=t1=0;
	For(i,L,R){
		if(calc(q[s[i]])){
			ans[s[i]]=mid;
			s0[++t0]=s[i];
		}else{
			s1[++t1]=s[i];
		}
	}
	int tmp=L+t0-1;
	For(i,1,t0) s[L-1+i]=s0[i];
	For(i,1,t1) s[tmp+i]=s1[i];
	solve(mid+1,r,tmp+1,R);
	For(i,l,mid) work(i,-1);
	solve(l,mid-1,L,tmp);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	For(i,1,n) cin&gt;&gt;a[i];
	copy(a+1,a+1+n,b+1);
	sort(b+1,b+1+n);
	lim=unique(b+1,b+1+n)-b-1;
	For(i,1,n) a[i]=lower_bound(b+1,b+1+lim,a[i])-b;
	For(i,1,n) p[a[i]].pb(i);
	For(i,1,m) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k;
	iota(s+1,s+1+m,1);
	fill(ans+1,ans+1+m,lim+1);
	solve(1,lim,1,m);
	For(i,1,m) assert(ans[i]&lt;=lim);
	For(i,1,m) cout&lt;&lt;b[ans[i]]&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16537382.html</id>
    <title type="text">动态区间 Kth-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-07-31T08:39:00Z</published>
    <updated>2022-07-31T08:39:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16537382.html" />
    <content type="text">[P2617 Dynamic Rankings 例题](https://www.luogu.com.cn/problem/P2617)

## 静态整体 Kth

sort 即可。

$O(n\log n+q)$。

## 动态整体 Kth

离散化 + 权值线段树即可。

若强制在线则使用权值平衡树。

$O(n\ /\ n\log n+q\log n)$

## 静态区间 Kth

主席树。

$O(n\log n+q\log n)$

## 动态区间 Kth

类似树状数组，但是每个位置是一棵权值线段树。

每次修改一个位置的元素时，要修改 $\log n$ 棵树上的该位置（树状数组 add）。

区间查询的时候是 $\log n$ 和 $\log n$ 线段树之间做差（树状数组 que）。

$O(n\log^2n+q\log^2n)$

[Code](https://www.luogu.com.cn/record/81958208)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16541917.html</id>
    <title type="text">bitset 和 builtin-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-01T13:27:00Z</published>
    <updated>2022-08-01T13:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16541917.html" />
    <content type="text">## bitset

`b.size()` 返回大小（位数）
`b.count()` 返回 $1$ 的个数
`b.any()` 返回是否有 $1$
`b.none()` 返回是否没有 $1$
`b.set()` 全都变成 $1$
`b.set(p)` 将第 $p$ 位（最低位为第 $0$ 位）变成 $1$
`b.set(p, x)` 将第 $p$ 位变成 $x$
`b.reset()` 全都变成 $0$
`b.reset(p)` 将第 $p$ 位变成 $0$
`b.flip()` 全都取反
`b.flip(p)` 将第 $p$ 位取反
`b.to_ullong()` 返回它转换为 ull 的结果（超范围则报错）
`b.to_string()` 返回它转换为 string 的结果
遍历所有 set 的位置：
```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	bitset&lt;1001&gt; B;
	B.set(2); B.set(4); B.set(233);
	for(int i=B._Find_first();i!=B.size();i=B._Find_next(i)) 
		cout&lt;&lt;i&lt;&lt;" ";
 	cout&lt;&lt;"\n";
}
```

# builtin

以下均为**无符号**整型的函数，ll 版本请在后面追加 `ll`。

`__builtin_clz` 返回前导 $0$ 的个数
`__builtin_ctz` 返回末尾连续 $0$ 的个数
`__builtin_popcount` 返回 $1$ 的个数
`__builtin_ffs` $=$ `__builtin_ctz` $+1$
`__builtin_parity` $=$ `__builtin_popcount` $\&amp;1$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16546961.html</id>
    <title type="text">圆周率，复平面，素数，高斯，共轭和积性函数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-03T06:23:00Z</published>
    <updated>2022-08-03T06:23:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16546961.html" />
    <content type="text">[比这篇 blog 好的视频](https://www.bilibili.com/video/av12131743)

[费马平方和定理](https://www.cnblogs.com/shaojia/p/17114835.html)

## 圆周率

我们都知道一个关于圆周率的公式：
$$
\frac{\pi}{4}=1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}\dots
$$
这是莱布尼茨公式，他用微积分证明的，我们尝试用另一种方式来证明它。

## 复平面

我们最原始的想法是：找一个半径 $R$ 尽量大的圆，放在单位正方形网格中，数有多少个格点被包含在这个圆内（接近于 $\pi R^2$），以此来算出 $\pi$ 的近似值。

&gt; 数学里比较常见的是，当你看到和二维平面有关的问题时，就把这个平面看作全体复数的集合，再看问题或许会有意外收获。——3b1b

所以我们在复平面上考虑，一个半径足够大的圆（圆心定为 $0$）内有多少格点。

我们枚举格点到圆心的距离，必然属于 $S=\{\sqrt x\ |\ x\in[0,R^2]\cap \mathbb N \}$（勾股）。

考察特定的距离 $\sqrt L$，我们计算半径为 $\sqrt L$ 的圆会经过多少格点，将结果设为 $f(L)$，则圆内的点数为
$$
\sum_{L=0}^{R^2}f(L)
$$

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220804084348727-67941236.png)

（上图 $12$ 个点表示 $f(25)=12$）

那 $f(L)$ 咋求呢？

我们发现，相当于 $x^2+y^2=L$ 的整数解个数（还是勾股）。

例如
$$
0^2+5^2=3^2+4^2=4^2+3^2=5^2+0^2=25
$$
以及每个数分别作相反数共 $12$ 对数的平方和为 $25$。

## 素数

接下来先扯一堆看起来离题的知识。

### 素数

emmm，不用多说。

### 唯一分解定理

也不用多说。

有时 $-1$ 这个因子要特判啥的。

### 高斯整数

&gt; 实部和虚部都是整数的复数。

这个很好理解。

### 高斯素数

由于高斯整数形成了不可以转成有序环的欧几里德整环，所以是**唯一因子分解**整环。

相当于在高斯整数集中也有唯一分解定理。

那么不可或缺的就是在高斯整数集中的质元素，称为高斯素数。

## 高斯

注意，有些素数不是高斯素数，比如说 $5=(2+i)(2-i),2=(1+i)(1-i)$。

&gt; 费马平方和定理：奇素数**能表示为两个平方数之和**的充分必要条件是该质数**模 $4$ 余 $1$**。

所以说，模 $4$ 余 $3$ 的奇素数是高斯素数，而对于模 $4$ 余 $1$ 的奇素数 $p$：
$$
p=a^2+b^2=(a+bi)(a-bi)
$$
不是高斯素数。

看上面的柿子，是否和我们刚刚留下的方程很像？

没错，我们留下的「$x^2+y^2=L$ 的整数解个数」相当于问：

&gt; $L$ 分解成两个**共轭**的**高斯整数**的方案数。

## 共轭

复数 $z$ 的共轭记为 $\bar z$。

### 共轭乘共轭还是共轭
$$
\bar{xy}=\bar x\cdot \bar y
$$

### 复数、其倒数、其模长与其共轭的关系
$$
\frac{1}{z}=\frac{\bar z}{|z|^2}
$$

平方差公式可证。

### 共轭的逆还是共轭的

通过上面的可以推导。

### 共轭除以共轭还是共轭

通过上面的可以推导。

### 一个高斯整数分解成两个共轭的高斯整数必然将所有共轭的因子都分在两边

反证法，若不是，则将所有分在两边的共轭均除掉，剩下的两边还是共轭。

设此时左边的集合为 $S$，右边为 $T$。

我们记 $\hat S$ 表示将 $S$ 中所有都变换为其共轭后的集合。

可知 $\hat S$ 和 $T$ 元素乘积相等，且没有相同的元素，有背唯一分解定理，原命题得证。

↑ 证明过程非常不靠谱，请多指教。

## 积性函数

我们将 $L$ 高斯素因数分解，每一对共轭的因子选择哪一个放在左边，而共轭不存在于此的因子我们必须将其平分在两侧。

所以，将 $L$ **实数域**上素因数分解后，模 $4$ 余 $3$ 的素数必须出现偶数次。

我们定义 $\chi(n)$ 函数，它是**完全积性函数**：

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220804093939746-1448596971.png)

再结合 $2$ 因子不影响分解数量，$-1,i$ 因子会将最后的结果 $\times 4$（在复平面上转 $90^{\circ}$ 的倍数），

我们终于得到 $L$ 的高斯分解方案数了：
$$
f(L)=4\sum_{p^k|| L}\sum_{i=0}^k\chi(p^i)
$$
（模 $4$ 余 $3$ 的素数根据幂 $0/1$ 震荡 $^{*}$，模 $4$ 余 $1$ 的素数为幂次 $+1$，代表有几种分配方案）

$^{*}$ 3b1b 翻译组原话：若一个只有实部的高斯素数幂次不是偶数，哦，那就完蛋了。

($p^k||L$ 代表 $p^k|L\land p^{k+1}\nmid L$)

（上述分解均在实数域内）

由于这是完全积性函数（积性其实就够了），上面的柿子可以简化为
$$
f(L)=4\sum_{d|L}\chi(d)
$$
最后的最后（柿子的所有化简均以 $R\to \infty$ 考虑）：
$$\begin{aligned}
\sum_{L=0}^{R^2}f(L)&amp;=\sum_{L=1}^{R^2}4\sum_{d|L}\chi(d)
\\&amp;=4\sum_{L=1}^{R^2}\sum_{d|L}\chi(d)
\\&amp;=4\sum_{d=1}^{R^2}\sum_{L=1}^{R^2/d}\chi(d)
\\&amp;=4\sum_{d=1}^{R^2}\chi(d)\frac{R^2}{d}
\\&amp;=4R^2\sum_{d=1}^{R^2}\frac{\chi(d)}{d}
\end{aligned}$$

再比较 $\pi R^2$，得到
$$
\pi=4\sum_{d=1}^{\infty}\frac{\chi(d)}{d}
$$
也就是
$$
\frac{\pi}{4}=1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}\dots
$$
完结撒花！

## 结语

[P2508 [HAOI2008]圆上的整点](https://www.luogu.com.cn/problem/P2508)

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
int ans=1,cnt,n;
int calc(int p,int k){//sum of chi of same prime
	if(p%4==1) return k+1;
	else if(p%4==3) return (k&amp;1)?0:1;//The 0 case cannot exist in this problem
	else return 1;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;//n^2 prime factorization in fact.
	for(int i=2;i*i&lt;=n;i++) if(n%i==0){
		cnt=0;
		while(n%i==0) cnt++,n/=i;
		ans*=calc(i,2*cnt);
	}
	if(n&gt;1) ans*=calc(n,2);
	cout&lt;&lt;4*ans&lt;&lt;endl;//dont forget to mul 4
return 0;}
```
&lt;/details&gt;

~~恭喜你看了视频和 blog 后切了一道省选题。~~</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16554731.html</id>
    <title type="text">重修 莫比乌斯反演-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-05T08:08:00Z</published>
    <updated>2022-08-05T08:08:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16554731.html" />
    <content type="text">[/youl 乐团 题解](https://www.cnblogs.com/shaojia/p/16555685.html)

[狄利克雷知识](https://www.cnblogs.com/shaojia/p/15138057.html)

好像没啥好说的……

$$
[n=1]=\sum_{d|n}\mu(d)
$$

$$
\gcd(n,m)=\sum_{d|n\ d|m}\varphi(d)
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16555685.html</id>
    <title type="text">/youl 乐团 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-05T12:31:00Z</published>
    <updated>2022-08-05T12:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16555685.html" />
    <content type="text">[P5518 [MtOI2019]幽灵乐团 / 莫比乌斯反演基础练习题](https://www.luogu.com.cn/problem/P5518)

以下 $/$ 表示下取整除法（时间复杂度除外），分数线才是真正的除法。

以下时间复杂度中的 $n$ 表示 $\max(A,B,C)$。

对于不平常的柿子推导顺序，深感抱歉。

# 冗长の前置

## 0

注意别将 $\sum$ 和 $\prod$ 搞混，并且清楚他们的基础变换。

## 1 

明白这个转换（$f$ 为任意函数）：
$$
\begin{aligned}
\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}\gcd(i,j,k)f(i,j,k)
&amp;=\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}f(i,j,k)\sum_{d|i\ d|j\ d|k}\varphi(d)
\\
&amp;=\sum_{d=1}^{\min(A,B,C)}\varphi(d)\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}\sum_{k=1}^{C/d}f(di,dj,dk)
\end{aligned}
$$

## 2

今天的 mvp 是（因为等会儿会用得多，先写上来）：
$$
mvp(n)=\sum_{d|n}d^{\mu(\frac{n}{d})}
$$
（没错起名就是这么随意）

她的前缀积预处理配合上整除分块可以 $O(\sqrt n\log n)$ 解决这个问题（**由对称性**，不妨设 $A\le B$；幂太长了，用 $\text{pow}$ 代替）：
$$
\begin{aligned}
F(A,B)&amp;=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}[\gcd(i,j)=1])
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}\sum_{x|i\ x|j}\mu(x))
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{x=1}^{A/d}\mu(x)(A/(xd))(B/(xd)))
\\&amp;=\prod_{d=1}^A\prod_{x=1}^{A/d} \text{pow}(d,\mu(x)(A/(xd))(B/(xd)))
\\&amp;=\prod_{T=1}^A\prod_{d|T} \text{pow}(d,\mu(\frac{T}{d})(A/T)(B/T))
\\&amp;=\prod_{T=1}^A\left(\prod_{d|T} d^{\mu(\frac{T}{d})}\right)^{(A/T)(B/T)}
\\&amp;=\prod_{T=1}^A mvp(T)^{(A/T)(B/T)}
\end{aligned}
$$

## 3

设 $DC(n)=\frac{n(n+1)}{2}=1+\dots+n$（Deng Cha）。

Mvp 的变形（机翻 deformation）：
$$
dmvp(n)=\left(\sum_{d|n}d^{\mu(\frac{n}{d})}\right)^{n^2}
$$

她很类似，前缀积预处理配合上整除分块可以 $O(\sqrt n\log n)$ 解决下面这个问题（设 $A\le B$）：
$$
\begin{aligned}
G(A,B)&amp;=\prod_{i=1}^A\prod_{j=1}^B\gcd(i,j)^{ij}
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}d^2ij[\gcd(i,j)=1])
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}d^2ij\sum_{x|i\ x|j}\mu(x))
\\&amp;=\prod_{d=1}^A \text{pow}(d,\sum_{x=1}^{A/d}\mu(x)d^2x^2\sum_{i=1}^{A/xd}i\sum_{j=1}^{B/xd}j)
\\&amp;=\prod_{d=1}^A\prod_{x=1}^{A/d} \text{pow}(d,\mu(x)(xd)^2 DC(A/xd)DC(B/xd))
\\&amp;=\prod_{T=1}^A\prod_{d|T} \text{pow}(d,\mu(\frac{T}{d})T^2 DC(A/T)DC(B/T))
\\&amp;=\prod_{T=1}^A dmvp(T)^{DC(A/T)DC(B/T)}
\end{aligned}
$$

# 简短の主干

看看我们要求的柿子：
$$
\begin{aligned}
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}&amp;=\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{ij}{\gcd(i,j)\gcd(i,k)}\right)^{f(type)}
\\&amp;=\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}i^{f(type)}j^{f(type)}\gcd(i,j)^{-f(type)}\gcd(i,k)^{-f(type)}
\end{aligned}
$$
所以说我们转化成了两个子问题：
$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}i^{f(type)}
\quad
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\gcd(i,j)^{f(type)}
$$

## type=0

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}i=(A!)^{BC}
$$

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\gcd(i,j)=\left(\prod_{i=1}^{A}\prod_{j=1}^{B}\gcd(i,j)\right)^C=F(A,B)^C
$$

## type=1

$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}i^{ijk}=\left(\prod_{i=1}^{A}i^i\right)^{DC(j)DC(k)}
$$

里面的连乘预处理即可。
$$
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\gcd(i,j)^{ijk}=\left(\prod_{i=1}^{A}\prod_{j=1}^{B}\gcd(i,j)^{ij}\right)^{DC(C)}=G(A,B)^{DC(C)}
$$

## type=2

注意到原柿子
$$
\begin{aligned}
\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{\gcd(i,j,k)}&amp;=\exp\ln\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{\gcd(i,j,k)}
\\&amp;=\exp\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{k=1}^{C}\gcd(i,j,k)\ln\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)
\\&amp;=\exp\sum_{d=1}^{\min(A,B,C)}\varphi(d)\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}\sum_{k=1}^{C/d}\ln\left(\frac{\text{lcm}(di,dj)}{\gcd(di,dk)}\right)
\\&amp;=\exp\sum_{d=1}^{\min(A,B,C)}\varphi(d)\sum_{i=1}^{A/d}\sum_{j=1}^{B/d}\sum_{k=1}^{C/d}\ln\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)
\\&amp;=\prod_{d=1}^{\min(A,B,C)}\text{work}_{type=0}(A/d,B/d,C/d)^{\varphi(d)}
\end{aligned}
$$

所以就转化成了 type=0 的情形。

# 难算の时间

首先预处理是 $O(n\log n)$ 的，因为有逆元。

type=0 和 type=1 均是 $O(T\sqrt n\log n)$ 的，已经说过。

type=2 调用了 type=0，较为难算（以下比较符号均代表 $O$ 的比较）：
$$
\begin{aligned}
Time&amp;\le\sum_{i=1}^{\sqrt n}\sqrt i\log i+\sum_{i=1}^{\sqrt n}\sqrt \frac{n}{i}\log  \frac{n}{i}
\\&amp;=\int_1^{\sqrt n}\sqrt x\log x\, \text{d}x+\int_1^{\sqrt n}\sqrt\frac{n}{x}\log  \frac{n}{x}\, \text{d}x
\\&amp;\le \log n\int_1^{\sqrt n}\sqrt x\, \text{d}x+\sqrt n\log n\int_1^{\sqrt n}\sqrt\frac{1}{x}\, \text{d}x
\\&amp;= \log n\ x^{3/2}|_{1}^{\sqrt n}+\sqrt n\log n\ x^{1/2}|_{1}^{\sqrt n}
\\&amp;=n^{3/4} \log n+n^{3/4} \log n
\\&amp;=n^{3/4} \log n
\end{aligned}
$$
所以总时间 $O(n\log n+Tn^{3/4}\log n)$。

# 条理の代码

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define int long long
const int N=100000,M=100001;//number, memory
int mod,phi[M],mu[M],f[M],mp[M],mvp[M],imvp[M],dmvp[M],idmvp[M];
bool vis[M];
vector&lt;int&gt; p;
inline int pw(int x,int y){int r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
inline int inv(int x){ return pw(x,mod-2); }
void init(){
	p.reserve(9593);
	phi[1]=mu[1]=1;
	For(i,2,N){
		if(!vis[i]){
			p.emplace_back(i);
			phi[i]=i-1,mu[i]=-1;
		}
		for(int j:p){
			if(i*j&gt;=N) break;
			vis[i*j]=1;
			if(i%j==0){
				phi[i*j]=phi[i]*j,mu[i*j]=0;
				break;
			}else{
				phi[i*j]=phi[i]*(j-1),mu[i*j]=-mu[i];
			}
		}
	}
	For(i,1,N) phi[i]+=phi[i-1];
	f[0]=1; For(i,1,N) f[i]=f[i-1]*i%mod;
	mp[0]=1; For(i,1,N) mp[i]=mp[i-1]*pw(i,i)%mod;
	fill(mvp+1,mvp+N,1);
	int x;
	For(i,1,N){
		x=inv(i);
		For(j,1,N/i)
			if(mu[j]==1) (mvp[i*j]*=i)%=mod;
			else if(mu[j]==-1) (mvp[i*j]*=x)%=mod;
	}
	For(i,1,N) dmvp[i]=pw(mvp[i],i*i%(mod-1));
	mvp[0]=dmvp[0]=1;
	For(i,1,N) (mvp[i]*=mvp[i-1])%=mod;
	For(i,0,N) imvp[i]=inv(mvp[i]);
	For(i,1,N) (dmvp[i]*=dmvp[i-1])%=mod;
	For(i,0,N) idmvp[i]=inv(dmvp[i]);
}
inline int DC(int x){ return x*(x+1)/2%(mod-1); }
inline int F(int A,int B){
	if(A&gt;B) swap(A,B);
	int ans=1;
	for(int l=1,r;l&lt;=A;l=r+1){
		r=min(A/(A/l),B/(B/l));
		(ans*=pw(mvp[r]*imvp[l-1]%mod,(A/l)*(B/l)%(mod-1)))%=mod;
	}
	return ans;
}
inline int G(int A,int B){
	if(A&gt;B) swap(A,B);
	int ans=1;
	for(int l=1,r;l&lt;=A;l=r+1){
		r=min(A/(A/l),B/(B/l));
		(ans*=pw(dmvp[r]*idmvp[l-1]%mod,DC(A/l)*DC(B/l)%(mod-1)))%=mod;
	}
	return ans;
}
int work0(int A,int B,int C){
	return pw(pw(f[A],B)*pw(f[B],A)%mod,C)*
	inv(pw(F(A,B),C)*pw(F(A,C),B)%mod)%mod;
}
int work1(int A,int B,int C){
	return pw(pw(mp[A],DC(B))*pw(mp[B],DC(A))%mod,DC(C))*
	inv(pw(G(A,B),DC(C))*pw(G(A,C),DC(B))%mod)%mod;
}
int work2(int A,int B,int C){
	int ans=1,lim=min({A,B,C});
	for(int l=1,r;l&lt;=lim;l=r+1){
		r=min({A/(A/l),B/(B/l),C/(C/l)});
		(ans*=pw(work0(A/l,B/l,C/l),(phi[r]-phi[l-1])%(mod-1)))%=mod;
	}
	return ans;
}
signed main(){
	int T,A,B,C;
	scanf("%lld%lld",&amp;T,&amp;mod);
	init();
	while(T--){
		scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;C);//A,B,C of 'work*()' CANNOT exchange!!!
		printf("%lld %lld %lld\n",work0(A,B,C),work1(A,B,C),work2(A,B,C));
	}
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16559843.html</id>
    <title type="text">斯特林数和下降幂-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-07T12:44:00Z</published>
    <updated>2022-08-07T12:44:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16559843.html" />
    <content type="text">

## P5395 第二类斯特林数·行

给定$n$，对于所有的整数 $i\in[0,n]$，你要求出 ${n\brace i}$，$n\le 2\times 10^5$。

做法是 NTT 卷积
$$
{n\brace m}=\sum_{i=0}^m \frac{i^n}{i!}\frac{(-1)^{m-i}}{(m-i)!}
$$
如果你不知道哪里有卷积：
$$
\begin{aligned}
\\H(x)&amp;=F(x)G(x)
\\H(x)&amp;=\sum_{i=0}^n{n\brace i}x^i
\\F(x)&amp;=\sum_{i=0}^n\frac{i^n}{i!}x^i
\\G(x)&amp;=\sum_{i=0}^n\frac{(-1)^i}{i!}x^i
\end{aligned}
$$
&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-06 21:42:02
* Motto: We'll be counting stars.
*/
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
const int N=1&lt;&lt;19;
const ll mod=167772161;
ll pw(ll x,ll y){
	ll res=1;
	while(y){
		if(y&amp;1){
			(res*=x)%=mod;
		}
		y&gt;&gt;=1;
		(x*=x)%=mod;
	}
	return res;
}
ll f[N],ivf[N],F[N],G[N],st[N],w[N];
int n,lim,B=0,tax[N];
void mktw(){
	tax[0]=0;
	For(i,1,lim-1) tax[i]=(tax[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(B-1));
	ll wn=pw(3,(mod-1)/lim);
	w[0]=1;
	For(i,1,lim-1) w[i]=w[i-1]*wn%mod;
}
void DFT(ll *a){
	For(i,0,lim-1) if(i&lt;tax[i]) swap(a[i],a[tax[i]]);
	ll x,y;
	for(int len=2;len&lt;=lim;len&lt;&lt;=1){
		for(int i=0;i&lt;lim;i+=len){
			For(j,0,(len&gt;&gt;1)-1){
				x=a[i+j];
				y=a[i+j+(len&gt;&gt;1)]*w[lim/len*j]%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+(len&gt;&gt;1)]=(x-y+mod)%mod;
			}
		}
	}
}
void IDFT(ll *a){
	ll x=pw(lim,mod-2);
	reverse(a+1,a+lim);
	DFT(a);
	For(i,0,lim-1) (a[i]*=x)%=mod;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	f[0]=1; For(i,1,n) f[i]=f[i-1]*i%mod;
	ivf[n]=pw(f[n],mod-2); Rof(i,n,1) ivf[i-1]=ivf[i]*i%mod;
	For(i,0,n) F[i]=pw(i,n)*ivf[i]%mod;
	For(i,0,n) G[i]=(i&amp;1?mod-1:1)*ivf[i]%mod;
	while((1&lt;&lt;B)&lt;=2*n) B++;
	lim=1&lt;&lt;B;
	mktw(),DFT(F),DFT(G);
	For(i,0,lim-1) st[i]=F[i]*G[i]%mod;
	IDFT(st);
	For(i,0,n) cout&lt;&lt;st[i]&lt;&lt;" "; cout&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

## P2791 幼儿园篮球题

~~只因你太美~~

我们要求的是
$$
\frac{\sum_{i=0}^ki^L\binom{m}{i}\binom{n-m}{k-i}}{\binom{n}{k}}
$$
分母平凡，算分子，发现 $i^L$ 难搞，直接下降幂
$$
\begin{aligned}
&amp;\sum_{i=0}^ki^L\binom{m}{i}\binom{n-m}{k-i}
\\=&amp;\sum_{i=0}^k\binom{m}{i}\binom{n-m}{k-i}\sum_{j=0}^i\binom{i}{j}j!{L\brace j}
\\=&amp;\sum_{j=0}^kj!{L\brace j}\sum_{i=j}^k\binom{i}{j}\binom{m}{i}\binom{n-m}{k-i}
\\=&amp;\sum_{j=0}^kj!{L\brace j}\binom{m}{j}\sum_{i=j}^k\binom{m-j}{i-j}\binom{n-m}{k-i}
\\=&amp;\sum_{j=0}^kj!{L\brace j}\binom{m}{j}\sum_{i=0}^{k-j}\binom{m-j}{i}\binom{n-m}{k-i-j}
\\=&amp;\sum_{j=0}^kj!{L\brace j}\binom{m}{j}\binom{n-j}{k-j}
\end{aligned}
$$

NTT 卷积 $O(L\log L)$ 求出 $\forall x\in[0,L]\cap\mathbb{Z},{L\brace x}$。

我们发现最后的式子其实是
$$
\sum_{i=0}^{\min(k,m,L)}i!{L\brace i}\binom{m}{i}\binom{n-i}{k-i}
$$
最终复杂度 $O(L\log L+SL)$（$S$ 是数据组数），略卡空间。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-06 21:12:45
* Motto: We'll be counting stars.
*/
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
const ll mod=998244353;
const int N=1&lt;&lt;19,V=20000001;
ll pw(ll x,ll y){
	ll res=1;
	while(y){
		if(y&amp;1){
			(res*=x)%=mod;
		}
		y&gt;&gt;=1;
		(x*=x)%=mod;
	}
	return res;
}
int n,m,k,L,B,lim,tax[N],f[V],ivf[V];//f &amp; ivf longlong MLE
ll F[N],G[N],st[N],w[N];
void mktw(){
	tax[0]=0;
	For(i,1,lim-1) tax[i]=(tax[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(B-1));
	ll wn=pw(3,(mod-1)/lim);
	w[0]=1;
	For(i,1,lim-1) w[i]=w[i-1]*wn%mod;
}
void DFT(ll *a){
	For(i,0,lim-1) if(i&lt;tax[i]) swap(a[i],a[tax[i]]);
	ll x,y;
	for(int len=2;len&lt;=lim;len&lt;&lt;=1){
		for(int i=0;i&lt;lim;i+=len){
			For(j,0,(len&gt;&gt;1)-1){
				x=a[i+j];
				y=a[i+j+(len&gt;&gt;1)]*w[lim/len*j]%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+(len&gt;&gt;1)]=(x-y+mod)%mod;
			}
		}
	}
}
void IDFT(ll *a){
	ll x=pw(lim,mod-2);
	reverse(a+1,a+lim);
	DFT(a);
	For(i,0,lim-1) (a[i]*=x)%=mod;
}
void init(){
	f[0]=1;
	For(i,1,V-1) f[i]=1ll*f[i-1]*i%mod;
	ivf[V-1]=pw(f[V-1],mod-2);
	Rof(i,V-1,1) ivf[i-1]=1ll*ivf[i]*i%mod;
	For(i,0,L) F[i]=pw(i,L)*ivf[i]%mod;
	For(i,0,L) G[i]=(i&amp;1?mod-1:1ll)*ivf[i]%mod;
	B=0;
	while((1&lt;&lt;B)&lt;=2*L) B++;
	lim=1&lt;&lt;B;
	mktw();
	DFT(F);
	DFT(G);
	For(i,0,lim-1) st[i]=F[i]*G[i]%mod;
	IDFT(st);
	// For(i,0,L) cout&lt;&lt;st[i]&lt;&lt;"*"; cout&lt;&lt;"\n";
}
ll C(ll x,ll y){ return 1ll*f[x]*ivf[y]%mod*ivf[x-y]%mod; }
ll iC(ll x,ll y){ return 1ll*ivf[x]*f[y]%mod*f[x-y]%mod; }
void work(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int tot=min({k,m,L});
	ll ans=0;
	For(i,0,tot) (ans+=f[i]*st[i]%mod*C(m,i)%mod*C(n-i,k-i))%=mod;
	cout&lt;&lt;ans*iC(n,k)%mod&lt;&lt;"\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int T;cin&gt;&gt;n&gt;&gt;m&gt;&gt;T&gt;&gt;L;
	init();while(T--)work();
return 0;}
```
&lt;/details&gt;

## CF1528F AmShZ Farm

后面部分就是 第二类斯特林数·行，前面部分见 2023sol2。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16560119.html</id>
    <title type="text">平面图转对偶图-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-07T14:36:00Z</published>
    <updated>2022-08-07T14:36:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16560119.html" />
    <content type="text">平面图转对偶图常用于解决平面图的最小割问题。

一般的平面图转对偶图的通法是 **“最小左转法”**（其实也可以说成“最大左转法”，看你如何理解旋转角度）。

每一条无向线段，拆成两个方向的有向线段各一条。

每一条有向线段 $u\to v$，在 $v$ 的出边按 **atan2** lower_bound 找 nxt：

![image](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220807222845252-575737836.png)

当一条边**一直沿着 nxt 走回到了自己**，就**形成**了一个**平面**。

对每一个没有被 vis 的边执行上述操作，然后将新增的面编号，再将这些边编号挂在这个面上（此 vector 不妨叫做 coat），最后将这些边 vis=1。

唯一**面积**算出来（用叉积算）**为负数**的面即为**无界面**。

对了，**反向边**最好 i^1 像网络流那样**前向星建图**，这样方便找一个面的相邻面。

## P2046 [NOI2010] 海拔

## P3249 [HNOI2016] 矿区

## P4073 [WC2013]平面图</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16567429.html</id>
    <title type="text">2022 简思短解（中）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-09T12:03:00Z</published>
    <updated>2022-08-09T12:03:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16567429.html" />
    <content type="text">## CF1375E Inversion SwapSort

&gt; 给定一个长度为 $n$ 的序列 $a$，求 $a$ 中的所有逆序对 $(i_1, j_1), (i_2, j_2), \cdots, (i_m, j_m)$ 的一个排列 $p$，
&gt;
&gt; 使得依次交换 $(a_{i_{p_1}}, a_{j_{p_1}}), (a_{i_{p_2}}, a_{j_{p_2}}), \cdots, (a_{i_{p_m}}, a_{j_{p_m}})$ 后序列单调不降。
&gt;
&gt; $1 \le n \le 10^3$，$1 \le a_i \le 10^9$。

[题解不想贺了直接上链接](https://www.cnblogs.com/dysyn1314/p/13246526.html)

## arc148_d mod M Game

&gt; 有 $2n$ 个数，A 和 B 轮流选，每人最终各 $n$ 个，若 A 和 B 手上数的和模 $m$ 意义下相同，则 B 赢，否则 A 赢，求最后谁赢。
&gt;
&gt; $n\le 2\times 10^5,2\le m\le 10^9$。

vp 自己想出来的，但是还是有必要记录一下。

将游戏改为一个数初始为 $0$，A 选数加 B 选数减（模 $m$ 意义下）则最终 B 想让这个数变为 $0$，A 不想。

我们考察 $n=1$ 的情形，设仅剩的两个数为 $x,y$，若 $x-y$ 和 $y-x$ 在模 $m$ 意义下不同，则 A 必赢（必然能先选一个最终无法到达 $0$ 的数）。

所以若 B 要赢，则两个数必须 $x=y$，或者当 $m$ 为偶数的时候，可以有 $|x-y|=m/2$。

称两个数 $x,y$ **匹配**当且仅当 $x=y$ 或模意义下 $|x-y|=m/2$。

则显然若 B 要赢这 $2n$ 个数要构成 $n$ 组匹配，否则最终数的不确定性由 A 掌握。

而这还不够，B 要赢还要两两匹配的数差的和模意义下要 $=0$。

发现将两者结合一下就是充要条件了。

开一个 set 维护就做完了。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-12 14:38:38
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 400010
int n,m,a[N];
set&lt;int&gt; s;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	int x;
	For(i,1,n&lt;&lt;1){
		cin&gt;&gt;x;
		if(s.find(x)!=s.end()) s.erase(x);
		else s.insert(x);
	}
	if(m&amp;1){
		if(!s.empty()) cout&lt;&lt;"Alice"&lt;&lt;endl;
		else cout&lt;&lt;"Bob"&lt;&lt;endl;
		return 0;
	}
	m&gt;&gt;=1;
	n=0;
	for(auto i:s) a[++n]=i;
	s.clear();
	int pan=0;
	For(i,1,n){
		x=a[i];
		if(s.find((x+m)%(2*m))!=s.end()) s.erase((x+m)%(2*m)),pan++;
		else s.insert(x);
	}
	if(!s.empty() || (pan&amp;1)) cout&lt;&lt;"Alice"&lt;&lt;endl;
	else cout&lt;&lt;"Bob"&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## HDU7095.Add or Multiply 1

题自己看，中文的。

连续出现一段乘或加顺序可随意交换。

将连续的打包，发现一定是加乘交错。

所以分四类：

* $+\times +\times \dots +\times$

* $\times +\times +\dots\times +$

* $+\times +\times\dots \times +$

* $\times +\times +\dots +\times$

分别计算等价类个数，求和即为最终答案。

不妨以第一类为例，其他类似。

发现就是一个集合划分问题，设加乘分别有 $n,m$ 个，各有 $x$ 个连续包，则等价类个数为
$$
f(n,x)\cdot f(m,x)
$$
其中
$$
f(n,m)=m!{n \brace m}
$$
为第二类斯特林数乘阶乘。

第二类斯特林数：表示将 $n$ 个两两不同的元素，划分为 $m$ 个互不区分的非空子集的方案数。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-10 18:20:25
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1e9+7;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 3000
int s[N+1][N+1],fac[N+1];
void init(){
    fac[0]=1; For(i,1,N) fac[i]=fac[i-1]*i%mod;
    s[0][0]=1;
    For(i,1,N){
        For(j,1,i){
            s[i][j]=(s[i-1][j-1]+j*s[i-1][j])%mod;
        }
    }
    For(i,0,N) For(j,0,i) (s[i][j]*=fac[j])%=mod;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
    init();
    int T,x,y,ans;cin&gt;&gt;T;
    while(T--){
        cin&gt;&gt;x&gt;&gt;y;
        ans=0;
        For(i,1,x){
            (ans+=s[x][i]*s[y][i-1]+2*s[x][i]*s[y][i])%=mod;
            if(i&lt;y) (ans+=s[x][i]*s[y][i+1])%=mod;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
return 0;}
```
&lt;/details&gt;

## LOJ3362. 「JOI Open 2020」黑白点

&gt; 环上有 $n$ 个黑点和 $n$ 个白点。现在要将黑点、白点通过 $n$ 条线段两两匹配，问最多几对线段相交。
&gt;
&gt; $n\le 2\times 10^5$

首先，对于依次排列的 `B1 B2 W1 W2`，最优方案一定不包含 `B1-W2 B2-W1`，因为可以调整成 `B1-W1 B2-W2`，一定更不劣。

有推论：设黑、白点位置序列分别为 $b_1,b_2,\dots,b_n$ 和 $w_1,w_2,\dots,w_n$，最优方案一定是 $b$ 的某个循环移位和 $w$ 在所有下标相同的位置匹配。

聚焦于一条线段，可推得：与之不相交的线段条数为 $|len−n|$，$len$ 为线段长度。

因此，把所有白点移动到正对面，问题转化为：将黑白点匹配，最小化匹配距离之和。

数轴上的问题是容易的（每段单位长度的贡献为其左侧黑点数与白点数之差的绝对值）。考虑把环复制无穷遍，相当于可以将极左侧的黑、白点数之差赋为任意整数。因此取中位数最优。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-09 10:03:42
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 200010
char s[N&lt;&lt;1];
int n,m,a[N&lt;&lt;1];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;(s+1);
	m=n&lt;&lt;1;
	For(i,1,m) if(s[i]=='B') a[i]++; else a[i&lt;=n?i+n:i-n]--;
	For(i,1,m) a[i]+=a[i-1];
	sort(a+1,a+1+m);
	int ans=n*(n-1);
	For(i,1,n) ans+=a[i];
	For(i,n+1,m) ans-=a[i];
	cout&lt;&lt;(ans&gt;&gt;1)&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## P3521 [POI2011]ROT-Tree Rotations

&gt; 一棵二叉树树每个叶子有一个权值，构成排列。求一个 DFS 序，使得这些叶子按顺序构成的排列逆序对最少。

维护每个树上节点的权值线段树，线段树合并时统计 左$\to$右 与 右$\to$左 哪种逆序对少。

统计逆序对只要在合并线段树时加上前边的 sz[rs] * 后边的 sz[ls] 即可。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Create Time:        2022-08-23 19:44:02
* Last Modified time: 2022-08-23 21:19:46
* Motto: We'll be counting stars.
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define int long long
#define N 7500000
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
int n,ans=0,sz[N],ls[N],rs[N],tot=0,a0,a1;
#define mid ((l+r)&gt;&gt;1)
void build(int &amp;rt,int l,int r,int val){
	rt=++tot;
	sz[rt]=1;
	if(l==r) return ;
	if(val&lt;=mid) build(ls[rt],l,mid,val);
	else build(rs[rt],mid+1,r,val);
}
int merge(int x,int y){// x &lt;- y
	if(!x || !y) return x^y;
	a0+=sz[rs[x]]*sz[ls[y]];
	a1+=sz[rs[y]]*sz[ls[x]];
	ls[x]=merge(ls[x],ls[y]);
	rs[x]=merge(rs[x],rs[y]);
	sz[x]+=sz[y];
	return x;
}
int work(){
	int tmp=read(),res;
	if(tmp){
		build(res,1,n,tmp);
	}else{
		int L=work(),R=work();
		a0=a1=0;
		res=merge(L,R);
		ans+=min(a0,a1);
	}
	return res;
}
signed main(){
	n=read();
	work();
	printf("%lld\n",ans);
return 0;}
```
&lt;/details&gt;

## CF25E Test &amp; SP7155 CF25E - Test

&gt; 给定三个长度 $10^5$ 级别的小写字母串，问你最短的串使得包含这三个作为子串。

首先先考虑两个的咋做，发现就是一个 KMP。

三个的话只要 $6$ 次规定顺序然后每次两个 KMP 即可。

代码去原题看。（我 KMP 一遍写对！）

## CF10E Greedy Change

论文题~~很新颖的题，虽然很老了。~~

~~这里本来写了两页结果半途而废。~~

[直接看题解区吧](https://www.luogu.com.cn/problem/solution/CF10E)

## P8078 [WC2022] 秃子酋长

回滚中的只删除莫队 + 链表的撤销操作。

$O(n\sqrt m)$

非常卡常。

## HDU7233.Arithmetic Subsequence

&gt; 给定 $a_1,\dots,a_n$，要你构造一个重排 $\{a\}$ 的序列，使得不存在长度为 $3$ 的等差子序列，有可能无解。
&gt;
&gt; 要求单 $\log$ 做。

首先发现若一个数出现了 $\ge 3$ 次则无解，否则我们构造来证明一定有解。

1. 将 $\{a\}$ 中偶数分在左半边 $\{a_0\}$，奇数分在右半边 $\{a_1\}$。

2. 由奇偶性，发现这样 $\{a_0\}$ 和 $\{a_1\}$ 之间不会有任何的长度为 $3$ 的等差子序列。

3. 所以 $\{a_0\}$，$\{a_1\}$ 分别递归做，按 $\bmod 4$ 的余数分类，再次递归按 $\bmod 8$……

实现时只要将 $\{a\}$ 中元素全部二进制翻转（上下颠倒）后排序，再逆回来即可。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define N 5005
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
int n,a[N];
map&lt;int,int&gt; mp;
int rev(int x){
	int y=0;
	For(i,0,29) if((1&lt;&lt;i)&amp;x){
		y|=(1&lt;&lt;(29-i));
	}
	return y;
}
void work(){
	n=read();
	For(i,1,n) a[i]=read();
	mp.clear();
	For(i,1,n) mp[a[i]]++;
	for(auto i:mp) if(i.sec&gt;=3){
		puts("NO");
		return ;
	}
	puts("YES");
	For(i,1,n) a[i]=rev(a[i]);
	sort(a+1,a+1+n);
	For(i,1,n) a[i]=rev(a[i]);
	For(i,1,n) printf("%d%c",a[i]," \n"[i==n]);
}
signed main(){
	int T=read();
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## HDU7248.Apples

&gt; 算是 [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016) 的超级加强版。
&gt;
&gt; 加了边权（相当于费用流中的 cost），和修改边权操作。

考虑枚举 $(1,n)$ 之间传输了多少货物，设为 $x$。则接下来每两人之间传输的苹果数是固定的，可知答案为 $\sum_{i=1}^{n}l_i|x-a_i|$。容易知道这个式子的最小值在 $x$ 取 $a_1,\dots,a_n$ 的加权中位数时取到。将 $\{a\}$ 先离散化、排序，用序列数据结构维护 $\{l\}$ 的前缀和即可。

时间复杂度 $O(n\log n)$。

## HDU7247.Average Replacement

&gt; 给定一个无向图，点有点权，每次操作将每个点同时取为与其相邻点点权的平均值，求最后每个点收敛的值，精度 $6$ 位。
&gt;
&gt; 注意相邻点包括本身。

**结论 1：** 每个连通块最终收敛值一定相同。

证明：最小值会不断增大，最大值不断减小。

**结论 2：** 设 $a_i$ 为 $i$ 的点权，$d_i$ 为 $i$ 的相邻点个数（包括自己），每次操作 $\sum a_id_i$ 始终不变。

证明：我们只要证明一个点权为 $1$ 其余为 $0$ 的情况操作一次原式不变即可。

设一开始为 $1$ 的点为 $x$。

原本是柿子求值是 $d_x$。

后来的柿子为
$$
d_x\frac{1}{d_x}+\sum_{(x,y)\in E}d_y\frac{1}{d_y}=d_x
$$
得证。

所以求出连通块中度之和与点权加权和后即可平均分配最终答案。

一遍 DFS 解决。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Create Time:        2022-08-18 12:43:20
* Last Modified time: 2022-08-18 13:07:37
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define db double
#define N 100010
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
vector&lt;int&gt; e[N];
int vis[N],n,m;
db deg[N],a[N],ans[N],tot,di;
inline void dfs(int rt){
	tot+=deg[rt]*a[rt];
	di+=deg[rt];
	vis[rt]=1;
	for(int i:e[rt]){
		if(vis[i]==0) dfs(i);
	}
}
inline void dfs2(int rt){
	ans[rt]=tot;
	vis[rt]=2;
	for(int i:e[rt]) if(vis[i]==1){
		dfs2(i);
	}
}
void work(){
	n=read(),m=read();
	For(i,1,n) a[i]=read();
	For(i,1,n) e[i].clear();
	int x,y;
	fill(deg+1,deg+1+n,1);
	For(i,1,m){
		x=read(),y=read();
		e[x].pb(y);
		e[y].pb(x);
		deg[x]++;
		deg[y]++;
	}
	fill(vis+1,vis+1+n,0);
	For(i,1,n){
		if(vis[i]==0){
			tot=0;
			di=0;
			dfs(i);
			tot/=di;
			dfs2(i);
		}
	}
	For(i,1,n) printf("%.6lf\n",ans[i]);
}
signed main(){
	int T=read();
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## CF1715E Long Way Home

凸壳优化 DP，其实类似斜率优化。

场上想通但是被迫睡觉赛后 AC，就不记了。

## CF671D Roads in Yusland

线性规划的对偶 + 带 lazy tag 左偏树。

线性规划的对偶柿子：
$$
\min\{b^Tx|Ax\ge c\}=\max\{c^Ty|A^Ty\le b\}
$$
我们原问题是左式，其中：

* $A$ 是一个 $n-1$ 行 $m$ 列的矩阵，表示每一条链覆盖了哪些树上的边（所以是 01 矩阵）。

* $x$ 为 $m$ 个未知量组成的列向量，表示 $m$ 条链取不取。

* $c$ 是一个 $n-1$ 行的全 $1$ 列向量，表示最终每一条树边都要至少被覆盖一次。

* $b$ 是一个 $m$ 行的列向量，表示每一条链选取的代价。

显然，一个点多次被同一条链覆盖显然是不优的，所以最终取到最优解的 $x$ 向量必然有一种使得 $x$ 是 01 向量，所以不会存在某个 $x$ 中的元素 $\ge 2$ 的非法情况。

接下来我们转换成对偶问题，右式的定义同上，但是右式整体的意义变了：

&gt; 给每一条树边赋一个权值，使得每条链上的边权之和不超过链权，问整棵树边权和最大是多少。

感觉完全不是一个问题了对吧，但是确实她们答案相同。

然后由于每条链都是直上直下的，所以我们尽可能让更下方的边权更大，即从下到上贪心取最大边权。

限制可用左偏树维护。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 300010
#define pi pair&lt;int,int&gt;
vector&lt;int&gt; e[N],c[N];
pi a[N];//up val
// 由于要有 lazy tag 所以要用左偏树不能用配对堆 qwq
struct node{
	int ls,rs,val,up,dis,tag;
}t[N];
int n,m,dep[N],ans=0,pan[N],root[N],tot=0;
int nnd(int x){
	tot++;
	t[tot].up=a[x].fir;
	t[tot].val=a[x].sec;
	return tot;
}
void tag(int rt,int val){
	t[rt].tag+=val;
	t[rt].val+=val;
}
void pd(int rt){
	if(t[rt].tag){
		tag(t[rt].ls,t[rt].tag);
		tag(t[rt].rs,t[rt].tag);
		t[rt].tag=0;
	}
}
int merge(int x,int y){
	if(!x || !y) return x^y;
	pd(x);
	pd(y);
	if(t[x].val&gt;t[y].val) swap(x,y);//x is root
	t[x].rs=merge(t[x].rs,y);
	if(t[t[x].ls].dis&lt;t[t[x].rs].dis) swap(t[x].ls,t[x].rs);
	t[x].dis=t[t[x].ls].dis+1;
	return x;
}
int dele(int rt){
	return merge(t[rt].ls,t[rt].rs);
}
void dfs(int rt,int fa){
	dep[rt]=dep[fa]+1;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
		root[rt]=merge(root[rt],root[i]);
		pan[rt]+=pan[i];
	}
	if(rt!=1 &amp;&amp; pan[rt]==0) cout&lt;&lt;-1&lt;&lt;endl,exit(0);
	for(auto i:c[rt]) root[rt]=merge(root[rt],nnd(i));
	while(dep[t[root[rt]].up]&gt;=dep[rt]) root[rt]=dele(root[rt]);
	if(rt!=1){
		assert(root[rt]);
		ans+=t[root[rt]].val;
		tag(root[rt],-t[root[rt]].val);
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	int x,y;
	For(i,1,n-1){
		cin&gt;&gt;x&gt;&gt;y;
		e[x].pb(y);
		e[y].pb(x);
	}
	For(i,1,m){
		cin&gt;&gt;x&gt;&gt;a[i].fir&gt;&gt;a[i].sec;
		c[x].pb(i);
		pan[x]++;
		pan[a[i].fir]--;
	}
	dfs(1,0);
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## P4113 [HEOI2012]采花

离线询问，用树状数组维护哪些位置是右数第二个相同值的。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 2000010
#define low (x&amp;(-x))
//P4113
struct node{
	int l,r,id;
	friend bool operator&lt;(node x,node y){ return x.r&lt;y.r; }
}q[N];
int n,m,lst[N],pos[N],c[N],ans[N];
void add(int x,int y){
	while(x&lt;=n){
		c[x]+=y;
		x+=low;
	}
}
int que(int x){
	int res=0;
	while(x){
		res+=c[x];
		x^=low;
	}
	return res;
}
signed main(){
	n=read(),read(),m=read();
	int x;
	For(i,1,n){
		lst[i]=pos[x=read()];
		pos[x]=i;
	}
	For(i,1,m) q[i]=(node){read(),read(),i};
	sort(q+1,q+1+m);
	int p=1;
	For(i,1,n){
		if(lst[i]){
			if(lst[lst[i]]) add(lst[lst[i]],-1);
			add(lst[i],1);
		}
		while(p&lt;=m &amp;&amp; q[p].r==i)
			ans[q[p++].id]=que(i)-que(q[p].l-1);
	}
	For(i,1,m) printf("%d\n",ans[i]);
return 0;}
```
&lt;/details&gt;

## Darkbzoj 2739. 最远点

&gt; 给你一个 $n\le 500000$ 个点的凸包，求离每一个点最远的点。

首先破环成链（复制一倍），对于每一个 $[1,n]$ 之中的点 $x$，我们求 $[x,x+n)$ 中离她最近（若相等则初始号最小）的点，设为 $f(x)$。

由凸包的性质，发现 $f(x)$ 随着 $x$ 递增而非减，所以我们分治做。

有点类似整体二分的弱化版。

具体地，我们当前要处理 $[l,r]$ 中的 $f$，且保证答案在 $[L,R]$ 中（$1\le L\le R\le 2n$），取中点 $mid$，在 $[L,R]$ 中暴力寻找最近的点，然后赋值至 $f(mid)$，然后分治 $[l,mid-1]$ 取值在 $[L,f(mid)]$，$[mid+1,r]$ 取值在 $[f(mid),r]$。

复杂度 $O(n\log n)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 500005
struct node{
	int x,y,id;
}a[N];
int pw(int x){ return x*x; }
int Dis(node x,node y){
	return pw(x.x-y.x)+pw(x.y-y.y);
}
int n,ans[N];
bool cmp(int id,int x,int y){//for node id,is x greater than y?
	if(x&lt;id || x&gt;=id+n) return false;//only allow [id,id+n)
	if(y&lt;id || y&gt;=id+n) return true;
	int d1=Dis(a[x],a[id]),d2=Dis(a[y],a[id]);
	return d1!=d2?d1&gt;d2:a[x].id&lt;a[y].id;
}
void solve(int l,int r,int L,int R){
	if(l&gt;r) return ;
	int mid=(l+r)&gt;&gt;1,pos=L;
	For(i,L+1,R) if(cmp(mid,i,pos)) pos=i;
	ans[mid]=a[pos].id;
	solve(l,mid-1,L,pos);
	solve(mid+1,r,pos,R);
}
void work(){
	n=read();
	For(i,1,n) a[i].x=read(),a[i].y=read(),a[i].id=i;
	For(i,1,n) a[i+n]=a[i];
	solve(1,n,1,2*n);
	For(i,1,n) printf("%lld\n",ans[i]);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int T=read();
	while(T--)work();
return 0;}
```
&lt;/details&gt; 

## CF1712E2 LCM Sum (hard version)

正难则反，我们考虑不好的三元组个数，然后被 $\binom{r-l+1}{3}$ 减去即为答案。

发现不好的三元组当且仅当
$$
\text{lcm}(i,j,k)=k\ \lor\ (\text{lcm}(i,j,k)=2k\ \land\ i+j&gt;k)
$$
也就等价于
$$
(i|k\ \land\ j|k)\ \lor\ (\text{lcm}(i,j)=2k\ \land\ i+j&gt;k)
$$
发现 $\lor$ 两侧并无交集，所以我们分开求。

我们将问题离线下来，将询问按挂在 $l$ 上。

我们降序遍历 $l$，同时开树状数组维护每个值有多少个真因子 $\ge l$（及其平方）。这个添加一个数倍数是 $O(n\log n)$ 的。

对于**第一部分**
$$
\sum_{i=l}^{r}\binom{\sum_{j=l}^{i-1}[j\ |\ i]}{2}=
\frac{1}{2}\left(\sum_{i=l}^{r}(\sum_{j=l}^{i-1}[j\ |\ i])^2-\sum_{i=l}^{r}\sum_{j=l}^{i-1}[j\ |\ i]\right)
$$
这就两棵树状数组的区间和问题了。

**第二部分**我们观察到 $j$ 最大是 $\frac{2}{3}k$（因为 $&lt;k$ 且是 $2k$ 的因数），进一步得到 $i$ 最小是 $\frac{2}{6}k=\frac{1}{3}k$。

所以 $i,j$ 只有这些取值：
$$
\frac{2}{3}k,\frac{1}{2}k,\frac{2}{5}k,\frac{1}{3}k
$$
经过两两尝试 $&gt;k$ 和 $\text{lcm}$ 的限制，得到只有这两对是合法的：
$$
\{\frac{2}{3}k,\frac{1}{2}k\},\{\frac{2}{3}k,\frac{2}{5}k\}
$$
所以总数是
$$
\sum_{i=l}^r[6|i\ \land\ \frac{1}{2}i\ge l]+\sum_{i=l}^r[15|i\ \land\ \frac{2}{5}i\ge l]
$$
上式可以 $O(1)$ 算。

复杂度双 $\log$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define int long long
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read(){
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
const int N=200000,M=200010,Q=100010;
#define pi pair&lt;int,int&gt;
vector&lt;pi&gt; q[M];
int n,a[M],out[Q],c[2][M];
#define low (x&amp;(-x))
void add(bool T,int x,int y){
	while(x&lt;=N){
		c[T][x]+=y;
		x+=low;
	}
}
int que(bool T,int x){
	int res=0;
	while(x){
		res+=c[T][x];
		x-=low;
	}
	return res;
}
void insert(int x){
	for(int i=2*x;i&lt;=N;i+=x){
		add(1,i,2*a[i]+1);//a[i]^2
		add(0,i,1);//a[i]
		a[i]++;
	}
}
signed main(){
	n=read();
	int x,y;
	For(i,1,n){
		x=read(),y=read();
		q[x].pb(mkp(y,i));
	}
	int ans,len,R;
	Rof(L,N,1){
		insert(L);
		for(auto i:q[L]){
			len=(R=i.fir)-L+1;
			ans=len*(len-1)*(len-2)/6;
			ans-=((que(1,R)-que(1,L-1))-(que(0,R)-que(0,L-1)))/2;
			if(L*2&lt;=R) ans-=R/6-(L*2-1)/6;// 2/3k &amp; 1/2k
			if((L*5+1)/2&lt;=R) ans-=R/15-((L*5+1)/2-1)/15;// 2/3k &amp; 2/5k
			out[i.sec]=ans;
		}
	}
	For(i,1,n) printf("%lld\n",out[i]);
return 0;}
```
&lt;/details&gt;

## CF1712D Empty Graph

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220814122345282-1514820518.png)

斩获最优解。/ww

先考虑没有修改如何求直径，设 $d(x,y)$ 表示 $x,y$ 点之间的最短距离。

首先我们发现，对于两个固定的点 $l&lt;r$：
$$
d(l,r)=\min(2M,\min_{i=l}^r a_i)
$$
$$
M=\min_{i=1}^na_i
$$
即要么直接走，要么绕道全局 $\min$。

所以我们进一步得到任意 $l'\le l&lt;r\le r'$：
$$
d(l',r')\le d(l,r)
$$
所以设 $D$ 为直径：
$$\begin{aligned}
D&amp;=\max_{l&lt;r} d(l,r)
\\&amp;=\max_{i=1}^{n-1} d(i,i+1)
\\&amp;=\max_{i=1}^{n-1} \min\{2M,a_i,a_{i+1}\}
\\&amp;=\min\{2M,\max_{i=1}^{n-1} \min(a_i,a_{i+1})\}
\end{aligned}$$

我们考虑修改，显然我们只会修改至 $10^9$。

考虑二分答案。若答案 $\ge val$，首先我们先要 $2M\ge val$，即我们将序列中所有值 $&lt;\frac{val}{2}$ 的元素都操作一遍，如果操作数不够直接 false。

接下来要满足 $\max_{i=1}^{n-1} \min(a_i,a_{i+1})\ge val$，若当前至少还有 $2$ 次操作可进行，我们只要将某相邻两个均赋值 $10^9$ 就一定满足，所以直接 true。

否则，按剩下的操作数 $0/1$ 分类：

* 剩下 $0$，直接 $O(n)$ 计算 $\max_{i=1}^{n-1} \min(a_i,a_{i+1})$，判断是否 $\ge val$ 即可。

* 剩下 $1$，找到全局 $\max$，将其相邻的一个赋值 $10^9$，这样最后的值就是全局 $\max$，所以只要判全局 $\max$ 是否 $\ge val$ 即可。


&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
const int inf=1e9,N=100010;
int n,k,a[N],b[N];
bool check(int val){
	copy(a+1,a+1+n,b+1);
	int tmp=k,mx;
	For(i,1,n) if(b[i]*2&lt;val) b[i]=inf,tmp--;
	if(tmp&lt;0 || tmp&gt;1) return tmp&gt;1;
	if(tmp==0){
		mx=min(b[1],b[2]);
		For(i,2,n-1) ckmx(mx,min(b[i],b[i+1]));
	}else{
		mx=b[1];
		For(i,2,n) ckmx(mx,b[i]);
	}
	return mx&gt;=val;
}
void work(){
	n=read(),k=read();
	For(i,1,n) a[i]=read();
	int l=2,r=inf,mid,res=1;
	while(l&lt;=r){
		mid=(l+r)&gt;&gt;1;
		if(check(mid)) res=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",res);
}
signed main(){
	int T=read();
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## Darkbzoj 4998. 星球联盟

&gt; 加边 $(u,v)$，之后查询 $u,v$ 是否在同一个双连通分量中，若是则再输出分量大小。
&gt;
&gt; 操作 &amp; 点数 $2\times 10^5$。

先把操作离线下来，顺序先假装做一遍，对于那些连接了本来属于两个并查集的边，我们钦定为树边。

易得知对于最终的每一个连通块，树边都构成了一棵生成树，而且**任意一条非树边 $(u,v)$ 加入前 $u,v$ 之间树上的路径都已存在**。

然后我们正式开始做，对于每一条树边的加入，$u,v$ 必然不在同一个双连通分量中。

对于非树边的加入，由于树上已存在 $(u,v)$ 的路径，$u,v$ 必然在同一个双连通分量中，我们通过并查集将路径上的所有点合并。

我们将生成树定根，记 $f_i$ 表示与 $i$ 节点处于同一个分量的最浅祖先，此时合并路径 $(u,v)$ 上的点可以像树剖跳 lca 操作。

由于并查集，（均摊得到） $O(n)$（吊打 $O(n\log n)$ LCT）。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define Fi(s) freopen(s,"r",stdin)
#define Fo(s) freopen(s,"w",stdout)
#define Fre(s) Fi(s".in"),Fo(s".out")
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 200010
#define pi pair&lt;int,int&gt;
vector&lt;int&gt; e[N];
pi q[N&lt;&lt;1];
int n,m,p,f[N],sz[N],b[N],dep[N];
bool ist[N&lt;&lt;1];
inline int gf(int x){
	return x==f[x]?x:f[x]=gf(f[x]);
}
void dfs(int rt,int fa){
	dep[rt]=dep[fa]+1;
	b[rt]=fa;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
	}
}
signed main(){
	// Fre("alliance");
	n=read(),m=read(),p=read();
	m+=p;
	p=m-p;
	iota(f+1,f+1+n,1);
	For(i,1,m){
		q[i]=mkp(read(),read());
		if(gf(q[i].fir)!=gf(q[i].sec)){
			ist[i]=true;
			e[q[i].fir].pb(q[i].sec);
			e[q[i].sec].pb(q[i].fir);
			f[gf(q[i].fir)]=gf(q[i].sec);
		}
	}
	For(i,1,n) if(!dep[i]) dfs(i,0);
	iota(f+1,f+1+n,1);
	fill(sz+1,sz+1+n,1);
	int x,y;
	For(i,1,m)
		if(!ist[i]){
			x=gf(q[i].fir),y=gf(q[i].sec);
			while(x!=y){
				if(dep[x]&lt;dep[y]) swap(x,y);
				f[x]=gf(b[x]);
				sz[f[x]]+=sz[x];
				x=f[x];
			}
			if(i&gt;p) printf("%lld\n",sz[x]);
		}else{
			if(i&gt;p) puts("No");
		}
return 0;}
```
&lt;/details&gt;

## P2184 贪婪大陆

&gt; 有 $[1,n]$ 共 $n$ 个位置，初始没有任何区间，你有 $m$ 次操作 $opt,[L,R]$：
&gt;
&gt; * $opt=1$，增加一个区间 $[L,R]$。
&gt;
&gt; * $opt=2$，询问当前有多少区间与 $[L,R]$ 有交。两个区间有交意思是存在 $x\in[1,n]$，使得 $x$ 同时被包含在两个区间里。
&gt;
&gt; $n,m\le 10^5,1\le L\le R\le n$

这里是非常简单但是难想到的 Fenwick Tree 解法。

难想的结论:

&gt; 与 $[L,R]$ 区间有交的区间个数为 $X-Y$，其中 $X$ 表示左端点 $\in[1,R]$ 的区间个数，$Y$ 表示右端点 $\in[1,L)$ 的区间个数。

其实这个结论列出来正确性就显然了，但是真的难以想到。

两个 Fenwick 维护区间左右端点前缀和。

## HDU 7211.Counting Stickmen

&gt; 给你 $n\le 5\times 10^5$ 的一棵树，问有多少个诱导子图长下图红色这样（像一个小人）：
&gt;
&gt;![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220809195303295-700965433.png)
&gt;
&gt; 答案模 $998244353$。

我们枚举小人的肩部（图中的 $3$ 号节点），发现我们需要连出去两条长度为 $2$ 的链（两只手臂），一条“人”形的（躯干和腿），一个长度为 $1$ 的链（头颈）。

我们可以先不管长度为 $1$ 的链（头颈）计算 $i$ 点作为肩部的答案为 $ans_i$，则答案为
$$
\sum_{i=1}^n[deg_i\ge 4](deg_i-3)ans_i
$$
设我们当前要计算 $ans_x$，我们求出与 $x$ 相邻点的度 $-1$ 的序列 $b_1,b_2,\dots,b_k$，则（设 $\{b\}$ 的和为 $sum$，平方和为 $sos$）
$$\begin{aligned}
ans_x&amp;=\sum_{y=1}^k\sum_{i=1}^k\sum_{j=i+1}^k[y\ne i\ \land\ y\ne j]\binom{b_y}{2}b_ib_j
\\&amp;=\sum_{y=1}^k\binom{b_y}{2}\sum_{i=1}^k\sum_{j=i+1}^k[y\ne i\ \land\ y\ne j]b_ib_j
\\&amp;=\sum_{y=1}^k\binom{b_y}{2}\frac{(sum-b_y)^2-(sos-b_y^2)}{2}
\end{aligned}$$

总复杂度 $O(n)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j);i&lt;=(k);i++)
#define Rof(i,j,k) for(int i=(j);i&gt;=(k);i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=998244353,iv2=499122177;
#define int ll
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
#define N 500010
vector&lt;int&gt; e[N];
int n,deg[N],ans[N],son[N],f[N],b[N],c[N],tot;
inline void dfs(int rt,int fa){
	son[rt]=0;
	f[rt]=fa;
	for(int i:e[rt]) if(i!=fa){
		son[rt]++;
		dfs(i,rt);
	}
}
inline int pw(int x){
	return x*x%mod;
}
inline int calc(){
	// For(i,1,tot) cout&lt;&lt;b[i]&lt;&lt;"&amp;"; cout&lt;&lt;endl;
	int sum=0,sos=0;
	For(i,1,tot) sum+=b[i],sos+=(c[i]=b[i]*b[i]);
	sos%=mod;
	// cout&lt;&lt;sum&lt;&lt;"***"&lt;&lt;tot&lt;&lt;endl;
	int res=0;
	For(i,1,tot) if(b[i]&gt;=2) (res+=(pw((sum-b[i]+mod)%mod)-sos+c[i]+mod)*(b[i]*(b[i]-1)/2)%mod*iv2)%=mod;
	return res;
}
void work(){
	n=read();
	For(i,1,n) e[i].clear();
	int x,y;
	For(i,1,n-1){
		x=read(),y=read();
		e[x].pb(y);
		e[y].pb(x);
	}
	For(i,1,n) e[i].shrink_to_fit();
	For(i,1,n) deg[i]=e[i].size();
	fill(ans+1,ans+1+n,0);
	dfs(1,0);
	For(i,1,n){
		tot=0;
		for(int j:e[i]) if(j!=f[i]) b[++tot]=son[j];
		if(f[i]) b[++tot]=son[f[i]]-(f[i]==1);
		ans[i]=calc();
	}
	int out=0;
	For(i,1,n) if(deg[i]&gt;=4) out+=(deg[i]-3)*ans[i];
	printf("%lld\n",out%mod);
}
signed main(){
	int T=read();
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## CF643G Choosing Ads

如果 $p = 50 + \varepsilon$，这便是一个经典问题：长度为 $n$ 的数列中存在一个出现次数大于 $n / 2$ 的数，设计一个算法找到它。

只要每次删除两个不同的数，最后留下的那个数（或那些数，但这些数全部相同）就是要求的答案。

对于拓展情况我们如法炮制，令 $k = \left\lfloor \frac{100}{p} \right\rfloor$。
​
每次删除 $k + 1$ 个数，则对的数一定会留下来。

因为 $k$ 最大是 $5$，建立一棵线段树，使用每次 $O (k^2)$ 的时间合并区间，不难维护答案。

时间复杂度为 $O (n k^2 \log n)$。

[Code](https://codeforces.com/contest/643/submission/165510102)

## CF1716F Bags with Balls

设 $m$ 个球中奇数的个数为 $odd=\lceil\frac{m}{2}\rceil$ 同理偶数为 $even=\lfloor\frac{m}{2}\rfloor$。

据题意得
$$
Ans=\sum\limits_{i=0}^n odd^i even^{n-i}\binom{n}{i}i^k
$$
但是我们 $O(n\log k)$ 的时间接受不了，尝试将复杂度中的 $n$ 转为 $k$。

不妨设 $A=\frac{even}{odd}$ ，接下来就是斯特林数和下降幂的 dirty work：
$$
\begin{aligned}
\sum\limits_{i=0}^n odd^i even^{n-i}\binom{n}{i}i^k&amp;=odd^n \sum\limits_{i=0}^n \left(\frac{even}{odd}\right)^{n-i}\binom{n}{i}i^k

\\&amp;=odd^n \sum\limits_{i=0}^n A^{n-i}\binom{n}{i}i^k

\\&amp;=odd^n \sum\limits_{i=0}^n A^{n-i}\binom{n}{i}\sum_{j=0}^{k}{k\brace j}i^{\underline j}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}\sum\limits_{i=0}^n A^{n-i}\binom{n}{i}i^{\underline j}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}\sum\limits_{i=0}^n A^{n-i}\frac{n!}{i!(n-i)!}\frac{i!}{(i-j)!}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}\sum\limits_{i=0}^n A^{n-i}\frac{(n-j)!n!}{(n-i)!(i-j)!(n-j)!}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}\sum\limits_{i=j}^n A^{n-i}\binom{n-j}{n-i}n^{\underline j}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}n^{\underline j}\sum\limits_{i=j}^n A^{n-i}\binom{n-j}{n-i}

\\&amp;=odd^n \sum_{j=0}^{k}{k\brace j}n^{\underline j}\sum\limits_{i=0}^{n-j} A^{n-j-i}\binom{n-j}{n-j-i}

\\&amp;=odd^n \sum_{i=0}^{k}{k\brace i}n^{\underline i}(A+1)^{n-i}
\end{aligned}
$$

时间复杂度 $O(k^2+Tk\log n)$。（其实可以把 $\log$ 去掉）</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16577886.html</id>
    <title type="text">关于随机-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-11T13:04:00Z</published>
    <updated>2022-08-11T13:04:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16577886.html" />
    <content type="text">## size_t(new(char))

返回一个新字符的地址，重复调用大概率会以 $1$ 递增，`size_t` 在 64 位电脑中可看作 unsigned long long。

## time(0)

返回自 1970 年来的**秒数**。

由于不够随机，所以前两者只能作为随机种子。

## random_device

```cpp
random_device seed;
//seed() return unsigne
//check seed.min() &amp; seed.max()
```

好像说 Linux 下她会调用熵池，非常 NB。

但有些机子上不支持这个随机，所以可能不靠谱，我也无法了解。

## mt19937

```cpp
random_device seed;
mt19937 rgen(seed());
//generator, rgen() return unsigned
//check seed.min() &amp; seed.max()
```

当然如果嫌 `random_device` 麻烦或不靠谱可以这样写（xpp 推荐）：

```cpp
mt19937 rgen(time(0)+size_t(new(char)));
```

## uniform_int_distribution

为简便，我们

```cpp
#define uid uniform_int_distribution
```

支持区间内整数等概率随机生成。

（由于 mt19937 为 int32 范围，所以当你要随机 long long 范围时必然会用到这个）

```cpp
uid&lt;unsigned long long&gt; qwq;
//qwq(rgen) return [0,2^64-1]
//check qwq.min() &amp; qwq.max()
uid&lt;long long&gt; qwq;//return [0,2^63-1]
uid&lt;unsigned&gt; qwq;//return [0,2^32-1]
uid&lt;&gt; qwq;//default int, return [0,2^31-1]
uid&lt;T&gt; qwq(l,r);//return [l,r]
```

所以奉上 Rand 模板（也许已经同步在 Luogu）：

```cpp
mt19937 rgen(time(0)+size_t(new(char)));
#define uid uniform_int_distribution
```

（没错就是这么短）</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16578138.html</id>
    <title type="text">护好，别被抄！-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-11T14:23:00Z</published>
    <updated>2022-08-11T14:23:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16578138.html" />
    <content type="text">## shuffle_run v1.0

`#define` 和标号双 shuffle。

```cpp
//We'll be counting stars.
#include&lt;bits/stdc++.h&gt;
using namespace std;
mt19937 rgen(time(0)+size_t(new(char)));
const string p="countingstars";
string s;
vector&lt;string&gt; t;
vector&lt;int&gt; a,b;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	//Please input the code without:'#'/ MultiLineNotes
	//(And end with '^Z')
	while(getline(cin,s)) t.push_back(s);
	int n=t.size();
	a.resize(n);
	iota(a.begin(),a.end(),0);
	shuffle(a.begin(),a.end(),rgen);
	b.resize(n);
	iota(b.begin(),b.end(),0);
	shuffle(b.begin(),b.end(),rgen);
	for(int i:b) cout&lt;&lt;"#define "&lt;&lt;p&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;t[i]&lt;&lt;'\n';
	for(int i:a) cout&lt;&lt;p&lt;&lt;i&lt;&lt;'\n';
return 0;}
```

## shuffle_run v2.0

先执行下面的去注释程序：

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
// 去注释（不能有续行符 / 多行字符串）
string s="",t="",v;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	while(getline(cin,v)) s+=v+"\n";
	char now=0;
	for(auto i=s.begin();i!=s.end();){
		if(*i=='\\' &amp;&amp; next(i)!=s.end() &amp;&amp; (*next(i)=='"' || *next(i)=='\'')){
			t+=*(i++);
			t+=*(i++);
			continue;
		}
		if(*i=='"' &amp;&amp; now!='\''){
			now^='"';
			t+=*(i++);
			continue;
		}
		if(*i=='\'' &amp;&amp; now!='"'){
			now^='\'';
			t+=*(i++);
			continue;
		}
		if(now){
			t+=*(i++);
			continue;
		}
		if(*i=='/' &amp;&amp; next(i)!=s.end() &amp;&amp; *next(i)=='*'){
			i+=2;
			while(i!=s.end()){
				if(*i!='*' || next(i)==s.end() || *next(i)!='/'){
					i++;
					continue;
				}
				break;
			}
			i+=2;
			continue;
		}
		if(*i=='/' &amp;&amp; next(i)!=s.end() &amp;&amp; *next(i)=='/'){
			i+=2;
			while(*i!='\n') i++;
			i++;
			continue;
		}
		t+=*(i++);
	}
	cout&lt;&lt;t;
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```

然后跑下面这个：

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
// 打乱（输入必须去注释）（不能有续行符 / 多行字符串）
string v,s="";
bool white(char x){ return x==' ' || x=='\n' || x=='\t'; }
map&lt;string,string&gt; mp,p;
mt19937 rgen(time(0)+size_t(new(char)));
#define uid uniform_int_distribution
uid&lt;char&gt; R('A','Z');
string ran(){
	string res="";
	rep(i,0,9) res+=R(rgen);
	return res;
}
void nnd(string v){
	string res=ran();
	while(p.count(res)) res=ran();
	p[res]=v;
	mp[v]=res;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	while(getline(cin,v)){
		auto i=v.begin();
		while(i!=v.end() &amp;&amp; white(*i)) i++;
		v=string(i,v.end());
		if(v.empty()) continue;
		if(v.front()=='#'){
			s+=v+"\n";
			continue;
		}
		if(!mp.count(v)) nnd(v);
		s+=mp[v]+"\n";
	}
	for(auto i:p) cout&lt;&lt;"#define "&lt;&lt;i.fir&lt;&lt;" "&lt;&lt;i.sec&lt;&lt;"\n";
	cout&lt;&lt;s;
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```

[效果](https://www.luogu.com.cn/record/111160259)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16581561.html</id>
    <title type="text">重修 BFS-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-12T14:12:00Z</published>
    <updated>2022-08-12T14:12:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16581561.html" />
    <content type="text"># 01BFS

不要在第一次扩展到某个点时就固定了这个点的 dis，因为有可能之后有更优的 dis。

Hack:

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221116221000659-30166818.png)

如果入队列顺序是 1234，就 gg 了（这样 2 会先扩展至 4）。

除非你能够证明第一次到达任一点时都是正确的最短 dis（比如有每个点的入边边权相同）。

## CF1340C Nastya and Unexpected Guest

把我调吐了，细节多（其实是我 nt）。

[Code](https://codeforces.com/contest/1340/submission/181214813)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16584317.html</id>
    <title type="text">attack 语录（我为啥写 blog）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-13T13:50:00Z</published>
    <updated>2022-08-13T13:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16584317.html" />
    <content type="text">ShaoJia：

qwq大佬请教一件事：最近我发现我写 blog 用时太长了，本意是学习笔记的，结果越写越长。假想着别人一看我的东西就会了，然后用了更短的时间超越了我的能力。/kel

attack：

就这么说吧，他看你的东西看会了，其实是有两种情况。

要是这个东西是**纯板子**的东西，比如 SAM 吧。他说他看会了，他**顶多知道**里面的**代码逻辑**是什么样子的，然后他看会了，他**还真的是会**了，因为考试的时候 SAM 也**不会变形**嘛，他**不需要知道**它里面最**底层**的东西是什么，他只要能把它**背出来就可以了**。所以这样看的话，其实学 SAM 这种板子，他这种看你看会的就已经可以叫抄了，就是像 SAM 这种东西**抄是要比自己新学收益高的**。

但是你如果整理的是一些**思想类**的，比如说树链剖分的一些常见用法。这种东西他看是**不可能看过来的**：这种东西**只有自己整理**一遍才能看会，他看是永远看不会的。

ShaoJia：有时候弄 LaTeX 和啥排版等太耗时了，写 blog 是否还值得捏。

写博客的**重点**还是放在**对知识的思考**上，就是**让自己的大脑转起来**，**增强自己对知识点的理解**，LaTeX 那种东西，**没有必要去花太长时间去排版**。就比如说你可以计时，写个 500 字，有多少时间是在排版，有多少时间是在思考。只要这个**思考时间远远超过排版时间**，花一点时间去排版也是可以的。就是要**计算好**你**写博客**的这个**收益**到底是怎么样的，如果说**时间充足**的话，我还是更推荐把博客写的**详细**一点，**尤其**是如果是这个东西**不是自己想出来的**，是看别人的博客看会的，那就**很有必要**自己写博客**总结**一下；要是**自己想出来的** idea 就**没必要**写了，**考场上一定可以再想出来的**。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16585470.html</id>
    <title type="text">重修 Lucas &amp; exLucas-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-19T13:18:00Z</published>
    <updated>2022-10-19T13:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16585470.html" />
    <content type="text"># Lucas

## 内容 
$$
\binom{ap+b}{cp+d}\equiv\binom{a}{c}\binom{b}{d}\pmod{p}
$$
其中 $p$ 为素数，$0\le b,d&lt;p$。

也就是说将两个数分别 $p$ 进制分解，对应位形成的组合数相乘。

## 推论（重要）

当 $p=2$ 时有
$$
\binom{n}{m}\equiv[m\subseteq n]\pmod{2}
$$
其中 $\subseteq$ 表示二进制（相当于状压）的包含。

## 证明
以下等号均指 $\bmod p$ 意义下相等。
$$
\begin{aligned}
\binom{ap+b}{cp+d}&amp;=[x^{cp+d}](x+1)^{ap+b}
\\&amp;=[x^{cp+d}]((x+1)^p)^a(x+1)^b
\\&amp;=[x^{cp+d}](x^p+1)^a(x+1)^b
\\&amp;=([x^{cp}](x^p+1)^a)([x^d](x+1)^b)
\\&amp;=([x^c](x+1)^a)([x^d](x+1)^b)
\\&amp;=\binom{a}{c}\binom{b}{d}
\end{aligned}
$$
其中
$$
(x+1)^p\equiv x^p+1\pmod p
$$
可用二项式定理证明。

# exLucas

将模数 $M$ 素因数分解，设当前枚举到因子 $p^e$，则求出 $\binom{n}{m}\bmod p^e$ 后 CRT 即可。
$$
\binom{n}{m}\equiv\frac{n!}{m!(n-m)!}\equiv \frac{\frac{n!}{p^x}}{\frac{m!}{p^y}\frac{(n-m)!}{p^z}}p^{x-y-z}\pmod{p^e}
$$
其中 $x,y,z$ 分别为三个阶乘中 $p$ 因子的个数，由于组合数为整数，$x-y-z\ge 0$。

此时分母中两部分都是与 $p^e$ 互质的整数了，存在逆元（exgcd）。所以我们只需要求出 $F(n)=\frac{n!}{p^x}\bmod p^e$ （$x$ 为 $n!$ 中 $p$ 因子个数）即可。

通过拆分 $n!$ 连乘中 $p$ 的倍数，非 $p$ 倍数的循环节和余项，得：
$$
n!=

p^{\lfloor n/p\rfloor}

(\lfloor\frac{n}{p}\rfloor)!

\left(\prod_{i=1,p\not\mid i}^{p^e}i\right)^{\lfloor n/p^e\rfloor}

\prod_{i=1,p\not\mid i}^{n\bmod p^e}i
$$
所以
$$
F(n)=F(\lfloor\frac{n}{p}\rfloor)

\left(\prod_{i=1,p\not\mid i}^{p^e}i\right)^{\lfloor n/p^e\rfloor}

\prod_{i=1,p\not\mid i}^{n\bmod p^e}i
$$
边界条件 $F(0)=1$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16586593.html</id>
    <title type="text">二次剩余-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-14T14:31:00Z</published>
    <updated>2022-08-14T14:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16586593.html" />
    <content type="text">[P5491 【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)

[(Cipolla)sol](https://kewth.blog.luogu.org/solution-p5491)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16589805.html</id>
    <title type="text">重修 斜率优化 Dp-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-15T13:54:00Z</published>
    <updated>2022-08-15T13:54:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16589805.html" />
    <content type="text">&gt; 斜率单调暴力移指针
&gt;
&gt; 斜率不单调二分找答案
&gt;
&gt; $x$ 坐标单调开单调队列
&gt;
&gt; $x$ 坐标不单调开平衡树 / cdq分治

## P4072 [SDOI2016]征途

我们要求方差最小，而总和不变，等价于要每天走的路程平方和最小。

设 $s(i)$ 表示前 $i$ 段路的距离总和。

首先我们有一个 naive 的 $O(n^3)$ DP：

设 $f(i,j)$ 表示走完前 $n$ 段，用了 $j$ 天的最小平方和。
$$
f(i,j)=\min_{k=0}^i f(k,j-1)+(s(i)-s(k))^2
$$
发现后面的 $(s(i)-s(k))^2$ 明显就是斜率优化 DP，我们转化一下形式：
$$
\begin{aligned}
f_j(i)&amp;=\min_{k=0}^i f_{j-1}(k)+s^2(i)+s^2(k)-2s(i)s(k)
\\&amp;=s^2(i)+\min_{k=0}^i f_{j-1}(k)+s^2(k)-2s(i)s(k)
\end{aligned}
$$
若转移至 $f_j(i)$ 时 $k_0$ 不比 $k$ 劣，则有
$$
f_{j-1}(k_0)+s(k_0)^2-2s(i)s(k_0)\le f_{j-1}(k)+s^2(k)-2s(i)s(k)
$$
将 $i$ 有关移到一侧:
$$
\frac{(f_{j-1}(k_0)+s(k_0)^2)-(f_{j-1}(k)+s^2(k))}{s(k_0)-s(k)}\le 2s(i)
$$
不妨设 $g(k)=f_{j-1}(k)+s^2(k)$，则
$$
\frac{g(k_0)-g(k)}{s(k_0)-s(k)}\le 2s(i)
$$
发现左边就是 $(s(k_0),g(k_0)),(s(k),g(k))$ 两点间的斜率。

所以说，我们对于每一次 $j-1\to j$，都进行斜率优化，复杂度 $O(n^2)$。

（$x$ 坐标单调开单调队列）

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define int long long
#define db double
#define N 3003 
int n,m,a[N],f[2][N],q[N],head,tail;
inline int pw(int x){ return x*x; }
db SL(bool o,int x,int y){//slope
	return 1.*((f[o][y]+pw(a[y]))-(f[o][x]+pw(a[x])))/(a[y]-a[x]);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	For(i,1,n) cin&gt;&gt;a[i];
	For(i,2,n) a[i]+=a[i-1];
	For(i,1,n) f[1][i]=pw(a[i]);
	bool o;
	int tmp;
	For(i,2,m){
		o=(i&amp;1)^1;
		head=1,tail=0;
		For(j,1,n){
			while(head&lt;tail &amp;&amp; SL(o,q[head],q[head+1])&lt;2*a[j])
				head++;
			tmp=q[head];
			f[o^1][j]=f[o][tmp]+pw(a[j]-a[tmp]);
			while(head&lt;tail &amp;&amp; SL(o,q[tail-1],q[tail])&gt;=SL(o,q[tail],j))
				tail--;
			q[++tail]=j;
		}
	}
	tmp=f[m&amp;1][n];
	cout&lt;&lt;m*tmp-pw(a[n]);
return 0;}
```
&lt;/details&gt;

## P5468 [NOI2019] 回家路线 &amp; P6302 [NOI2019] 回家路线 加强版

咕咕咕~

## CF1083E The Fair Nut and Rectangles

一眼斜优，记个题号而已。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16595220.html</id>
    <title type="text">最小斯坦纳树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-17T06:54:00Z</published>
    <updated>2022-08-17T06:54:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16595220.html" />
    <content type="text">[转自（稍加修改）](https://www.luogu.com.cn/blog/ix-35/solution-p6192)

最小斯坦纳树，就是在一个无向连通图要花费最小的代价，连通给定的 $k$ 个关键点（一般 $k\le 10$），这是一个组合优化问题。

这个问题可以用状压 DP 来解决，首先容易发现一个结论：

**答案一定是树。**~~你猜为啥叫最小斯坦纳树。~~

证明：如果答案存在环，则删去环上任意一条边，代价变小。

于是我们为这棵树钦定一个树根，设 $f(S,i)$ 表示以 $i$ 为根的一棵树，包含集合 $S$ 中所有点的最小代价（只考虑关键点，即 $S$ 是关键点集合的子集）。

考虑如何**不重不漏**地转移。

一棵以 $i$ 为根的树有两种情况，第一种是 $i$ 的 $deg=1$，另一种是 $deg&gt;1$。

对于 $deg=1$ 的情况，可以考虑枚举树上与 $i$ 相邻的点 $j$，则：
$$
f(S,j)+w(i,j)\to f(S,i)\quad(A)
$$
对于 $deg&gt;1$ 的情况，可以划分成几个子树考虑，即：
$$
f(T,i)+f(S-T,i)\to f(S,i)\quad(T\subsetneq S\land T\ne \varnothing)\quad(B)
$$
这里的转移顺序是有讲究的，这可以理解成一个类似背包的 DP，按 $S$（二进制形态）升序枚举即可。

这两种转移具体如何实现呢？对于 $(B)$ 式较为简单，枚举子集即可，时间复杂度为 $O(3^k n)$。

对于 $(A)$ 式，可以想到最短路的松弛。所以在 $(B)$ 式枚举子集后，在同一个 $S$ 中 $n$ 个点跑 dij 即可，这部分时间复杂度为 $O(2^km\log m)$。

所以总时间复杂度为 $O(3^kn+2^km\log m)$。

[P6192 【模板】最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define N 101
#define V (1&lt;&lt;10)
#define pi pair&lt;int,int&gt;
const int inf=1e9;
int n,m,k,S,f[V][N];
vector&lt;pi&gt; e[N];
priority_queue&lt;pi&gt; q;
bool vis[N];
void dij(int *dis){
	fill(vis+1,vis+1+n,false);
	int x;
	while(!q.empty()){
		x=q.top().sec;
		q.pop();
		if(vis[x]) continue;
		vis[x]=true;
		for(auto i:e[x]){
			if(dis[i.fir]&gt;dis[x]+i.sec){
				dis[i.fir]=dis[x]+i.sec;
				q.push(mkp(-dis[i.fir],i.fir));
			}
		}
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	S=1&lt;&lt;k;
	int x,y,z;
	For(i,1,m){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
		e[x].pb(mkp(y,z));
		e[y].pb(mkp(x,z));
	}
	For(i,1,S-1) fill(f[i]+1,f[i]+1+n,inf);
	For(i,1,k){
		cin&gt;&gt;x;
		f[1&lt;&lt;(i-1)][x]=0;
	}//dont change x after this (x for a representative)
	For(s,1,S-1){
		For(i,1,n){//f(S,i)&lt;-f(T,i)+f(S^T,i) (T|S=S)
			for(int ss=s&amp;(s-1);ss;ss=s&amp;(ss-1))
				ckmn(f[s][i],f[ss][i]+f[s^ss][i]);
			if(f[s][i]&lt;inf) q.push(mkp(-f[s][i],i));
		}
		dij(f[s]);//f(S,i)&lt;-f(S,j)+w(i,j)
	}
	cout&lt;&lt;f[S-1][x]&lt;&lt;endl;
return 0;}
```

[P4294 [WC2008]游览计划](https://www.luogu.com.cn/problem/P4294)

这里是点权，所以我们的 DP 转移要改一下：
$$
f(S,j)+a_i\to f(S,i)
$$
$$
f(T,i)+f(S-T,i)-a_i\to f(S,i)\quad(T\subsetneq S\land T\ne \varnothing)
$$
后者 $-a_i$ 的原因是被算了两遍。

一样做。

最后 DFS 求方案即可。

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define N 101
#define V (1&lt;&lt;10)
const int inf=1e9;
int n,m,lim,S,k=0,a[N],f[V][N],pre[V][N];
bool ans[N],vis[N],used[V][N];
vector&lt;int&gt; e[N];
priority_queue&lt;pair&lt;int,int&gt; &gt; q;
int num(int x,int y){ return (x-1)*m+y; }
void adde(int x,int y){
	e[x].pb(y);
	e[y].pb(x);
}
void dij(int *dis,int *p){
	fill(vis+1,vis+1+lim,false);
	int x;
	while(!q.empty()){
		x=q.top().sec;
		q.pop();
		if(vis[x]) continue;
		vis[x]=true;
		for(int i:e[x]){
			if(dis[i]&gt;dis[x]+a[i]){
				dis[i]=dis[x]+a[i];
				q.push(mkp(-dis[i],i));
				p[i]=x;
			}
		}
	}
}
void dfs(int x,int y){
	if(used[x][y]) return ;
	used[x][y]=true;
	ans[y]=true;
	if(pre[x][y]){
		int tmp=pre[x][y];
		while(tmp){
			dfs(x,tmp);
			tmp=pre[x][tmp];
		}
	}else{
		for(int s=x&amp;(x-1);s;s=x&amp;(s-1)){
			if(f[x][y]==f[s][y]+f[x^s][y]-a[y]){
				dfs(s,y);
				dfs(x^s,y);
				break;
			}
		}
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	lim=n*m;
	For(i,1,lim) cin&gt;&gt;a[i];
	For(i,1,lim) if(!a[i]) k++;
	if(!k){
		cout&lt;&lt;0&lt;&lt;endl;
		For(i,1,n){
			For(j,1,m) cout&lt;&lt;"_";
			cout&lt;&lt;endl;
		}
		return 0;
	}
	S=1&lt;&lt;k;
	For(i,1,S-1) fill(f[i]+1,f[i]+lim+1,inf);
	int x=0,rep;
	For(i,1,n) For(j,1,m){
		if(!a[num(i,j)]) f[1&lt;&lt;(x++)][num(i,j)]=0,rep=num(i,j);
		if(i&lt;n) adde(num(i,j),num(i+1,j));
		if(j&lt;m) adde(num(i,j),num(i,j+1));
	}
	For(s,1,S-1){
		For(i,1,lim){
			for(int ss=s&amp;(s-1);ss;ss=s&amp;(ss-1))
				ckmn(f[s][i],f[s^ss][i]+f[ss][i]-a[i]);//double calced a[i] so subtract it
			if(f[s][i]&lt;inf) q.push(mkp(-f[s][i],i));
		}
		dij(f[s],pre[s]);
	}
	cout&lt;&lt;f[S-1][rep]&lt;&lt;endl;
	dfs(S-1,rep);
	For(i,1,n){
		For(j,1,m){
			if(!a[num(i,j)]) cout&lt;&lt;"x";
			else if(ans[num(i,j)]) cout&lt;&lt;"o";
			else cout&lt;&lt;"_";
		}
		cout&lt;&lt;endl;
	}
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16610799.html</id>
    <title type="text">我的密码-ShaoJia</title>
    <summary type="html">qwq</summary>
    <published>2022-08-21T12:29:00Z</published>
    <updated>2022-08-21T12:29:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16610799.html" />
    <content type="text">MD5 获取：

* “一个木函”软件 $\to$ MD5 摘要 手机端 或 [网页版](https://ol.woobx.cn/tool/md5-hash)

* 电脑：将文本输入 1.txt 然后 cmd 中 `certutil -hashfile 1.txt MD5`。

Linux 则输入 `echo -n "hello world"|md5sum`，不用通过新建文件。

对于每次登录都要输入的密码：我们不动，因为只有一个电脑（5 位）一个手机（4 位）。

对于一些常用的、社交的、利益相关的，我们进行操作。

```text
哔哩哔哩:blbl
洛谷:lg(多个号相同密码)
CodeForces:cf(多个号相同密码)
acwing:acw
uoj
loj
微信:wx
博客园:bky(多个号相同密码)
qq &amp; tim:qq
淘宝:tb
支付宝:zfb
知乎:zh
百度网盘 &amp; 百度:bd
atcoder:atc
twitter:tt
Pixiv:pix
GeoGebra:geo
MetaMask:meta
立创:lc
Apple ID:apple
热铁盒（青柠起始页）:rth
```

将 网站简称字符串拼接上「密码子」后求 MD5，设为 $T$。

密码为 `"Az_"` 拼接上 $T$ 的前 5 位。

网站简称字符串一般为网站名称拼音小写首字母或每个单词的首字母的拼接分母。

(以下代码中四个星号请自行替换为密码子)

此代码在 win11 下有效

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
string exec(string cmd,bool output=true) {
    FILE* pipe = _popen(cmd.c_str(), "r");
    if (!pipe) return "ERROR";
    char buffer[128];
    string result = "";
    while(!feof(pipe)) {
        if(fgets(buffer, 128, pipe) != NULL)
            result += buffer;
    }
    _pclose(pipe);
    if(output) cout&lt;&lt;res&lt;&lt;endl;
    return result;
}
const string Cmd="certutil -hashfile 1.txt MD5";
string t;
string work(string res){
    int pos=0;
    while(res[pos]!='\n') pos++;
    return "Az_"+res.substr(pos+1,5);
}
signed main(){
    cout&lt;&lt;"Please input the short name of the web."&lt;&lt;endl;
    cin&gt;&gt;t;
    FILE *qwq=fopen("1.txt","w");
    fprintf(qwq,"%s****",t.c_str());
    fclose(qwq);
    cout&lt;&lt;"Password is:"&lt;&lt;endl;
    cout&lt;&lt;work(exec(Cmd,false))&lt;&lt;endl;
    exec();
return 0;}
```

Linux

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;s;
	s=system(("echo -n \""+s+"****\"|md5sum").c_str());
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16613971.html</id>
    <title type="text">wqs忘情水二分-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-22T11:20:00Z</published>
    <updated>2022-08-22T11:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16613971.html" />
    <content type="text">![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193258376-313089253.png)

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193402263-456235218.png)

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193426080-74176837.png)

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193511091-116227647.png)

## P4983 忘情

&gt; 给定一段长度为 $n$ 的正整数序列，把它分为 $m$ 段，每一段的价值为 $(1+\sum_{i=l}^r a_i)^2$。求最小价值
和。
&gt;
&gt; $m\le n\le 10^5$

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193703528-180923609.png)

## wqs二分中重要的细节

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220822193823872-1855280137.png)

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
const int N=100005,inf=1e18;
int n,m,a[N],val,f[N],g[N],q[N],head,tail;//f[]: value g[]: cnt(minimize when f is minimized)
int W(int l,int r){//(l,r]
	return (a[r]-a[l]+1)*(a[r]-a[l]+1)+val;
}
#define db long double
db Val(int x){
	return f[x]+a[x]*a[x]-2*a[x];
}
db slope(int x,int y){
	return (Val(y)-Val(x))/(a[y]-a[x]);
}
void work(){//Slope Optimization DP
	f[0]=0;
	q[head=tail=1]=0;
	int x;
	For(i,1,n){//because the decision is increasing, so g[] is also increasing, so the leftest is the smallest.
		while(head&lt;tail &amp;&amp; slope(q[head],q[head+1])&lt;2*a[i]) head++;
		x=q[head];
		f[i]=f[x]+W(x,i);
		g[i]=g[x]+1;//increasing
		while(head&lt;tail &amp;&amp; slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) tail--;
		q[++tail]=i;
	}
}
signed main(){
	n=read(),m=read();
	For(i,1,n) a[i]=a[i-1]+read();
	int l=0,r=inf,res=0;
	while(l&lt;=r){///wqs erfen
		val=(l+r)&gt;&gt;1;
		work();
		if(g[n]&lt;=m) r=val-1,res=val;
		else l=val+1;
	}
	val=res;
	work();
	printf("%lld\n",f[n]-m*res);
return 0;}
```

## 更多例题

P2619 P5896</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16625956.html</id>
    <title type="text">Linux 逼疯人实录-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-25T14:20:00Z</published>
    <updated>2022-08-25T14:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16625956.html" />
    <content type="text"># 2023年3月24日

这个好用，像末地传送门：

VMware 共享文件夹。

[正常配置后出错点我](https://blog.csdn.net/chinoukin/article/details/84984947)

# 远古

之前的 Virtual Box 耗费了我太久的时间了，非常 lj。

所以我重装了，konata 全程提供帮助，谢谢！！！！！！！！！

[先下载一个 vmware workstation pro](https://www.vmware.com/go/getworkstation-win)

啥？你说要激活码？给，三选一：

```text
ZF3R0-FHED2-M80TY-8QYGC-NPKYF

YF390-0HF8P-M81RQ-2DXQE-M2UT6

ZF71R-DMX85-08DQY-8YMNC-PPHV8
```

同时在 [NOI 官网](https://www.noi.cn/gynoi/jsgz/2021-07-16/732450.shtml) 上下载 .iso 文件。

然后就装呗，一切按默认值。

虚拟机路径可以改一下，否则找不到。

最好将虚拟磁盘存储为单个文件。

机子用户密码啥的随意。

然后让她自己装装装，特别慢，有很多次。

直到你看到了这样的界面：

![](https://img2022.cnblogs.com/blog/2213867/202208/2213867-20220825222440245-855917947.png)

然后就装完了。

然后可能会跳出来啥更新，**千万不要搞**，一来超级费时间，二来可能会覆盖掉 NOI 装的东西。

~~中文包啥的也不需要，相信您的英文水平。~~ 最好装一下中文包，region&amp;language 里搞。

壁纸最好换成非黑色的，否则容易误判是否开机。

然后先**全屏模式**，搞分辨率（设置里 display）。

可以将字体调大一丢丢，设置里面 Universal Access 里 Large Text 选上即可。

再不行的话选上 display 里的 Fractional Scaling。

虚拟机**内外可以互相 ctrl+c ctrl+v 文件**，但是拖动好像不行。

ctrl+alt 可以快速切换鼠标内外。所以 ctrl+alt 再 alt+tab 快速切出虚拟机。

ctrl+alt+t 快速打开终端，也可以把 terminal 放入侧边栏。（其实不常用这两种方式）

自行百度学习 Linux 终端操作，反正 cd 和 dir 都是有的。

```text
ls:类似 dir。
touch abc.cpp:创建名为 abc.cpp 的空文件夹。
```

根目录是 `/`，`~` **不是根目录**，是用户目录。

好了，最好别装啥额外的软件。

用 Linux 环境和评测机一样就能避免很多程序的问题。

Linux 不是主力操作系统，大部分时间都是用 win 的，只是在需要用 linux 尝试一些情况的时候用一下。

反正只能说用惯linux会更好。

然后 [配置一下 sublime](https://www.cnblogs.com/shaojia/p/16533771.html) 就可以写代码了。

自定义编译的时候换成这个：

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```text
{
    "working_dir":"${file_path}",
    "shell_cmd":"g++ -o \"${file_base_name}\" \"${file_name}\"&amp;&amp;gnome-terminal -- bash -c \"./\"${file_base_name}\";echo;echo / = = = F I N = = = /;read\"",
    "selector":"source.c,source.c++"
}
```
&lt;/details&gt;

下载完安装包（举例 `​​edge.deb`）后在该文件夹终端：

```text
​​sudo dpkg -i edge.deb
```

进行安装。

[Linux pwd命令：显示当前路径](http://c.biancheng.net/view/3620.html)

[Linux 目录软链接](https://www.cnblogs.com/willwuss/p/13696573.html)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16629508.html</id>
    <title type="text">线段树结构题（包含ZJOI传统艺能D1T2线段树）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-26T14:52:00Z</published>
    <updated>2022-08-26T14:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16629508.html" />
    <content type="text">## P7143 [THUPC2021 初赛] 线段树
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16632758.html</id>
    <title type="text">重修 重载运算符-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-28T06:45:00Z</published>
    <updated>2022-08-28T06:45:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16632758.html" />
    <content type="text">感谢 rui_er 的大力支持。

## 普通情况

建议这样写（用友元函数）：

```cpp
struct node{
	...
	friend ... operator...(const node &amp;x,const node &amp;y){
		...
	}
};
```

## 注意事项 1

### &amp;

函数传 `&amp;`，相当于传的是一个指针，而不是将原 `node` 复制一份。

要是不写 `&amp;`，考虑以下代码：

```cpp
struct node{
	int a[10];
	friend bool operator&lt;(const node x,const node y){
		return x.a[0]&lt;y.a[0];
	}
}b[1000000];
int main(){
	...
	sort(b,b+1000000);
}
```

这样 `sort` 每次比较都会复制一份，直接 MLE / RE。

### const

由于我们用了引用 `&amp;`，所以是实参，为了不改动原值，用 const 保证原值不变，即下面这段代码会报错：

```cpp
struct node{
	int a;
	friend bool operator&lt;(const node&amp; x,const node&amp; y){
		x.a&gt;&gt;=1;
		y.a&gt;&gt;=1;
		return x.a&lt;y.a;
	}
};
```

## node 和别人

当然可以 `node` 和别的进行运算：

```cpp
struct qwq{
	int q;
};
struct node{
	int x;
	friend bool operator&lt;(const node&amp; x,const qwq&amp; y){
		return x.x&lt;y.q;
	}
};
```

```cpp
struct node{
	int x;
	friend bool operator&lt;(const node&amp; x,const int y){
		return x.x&lt;y;
	}
};
```

## 注意事项 2

这里 `const int y` 没有加 `&amp;`，因为 `int`（甚至是 `long long`）的空间不比指针（64 位下）大。

也就是说不用实参甚至空间更省。

## 别人和别人

```cpp
struct qwq{
	int q;
};
struct awa{
	int a;
};
struct node{
	int x,y;
	friend node operator+(const qwq&amp; x,const awa&amp; y){
		return (node){x.q,y.a};
	}
};
```

这是一种有病但是编译能过的写法，完全和 `node` 无关：

```cpp
struct qwq{
	int x;
};
struct node{
	int _114514;
	friend bool operator&lt;(const qwq&amp; x,const qwq&amp; y){
		return x.x&lt;y.x;
	}
};
```

## 需要调用在 node 外面定义的函数

```cpp
struct node{
	int x;
};
int func(int x){ return x*3; }
bool operator&lt;(const node&amp; x,const node&amp; y){
	return func(x.x)&lt;func(y.x);
}
```

（rui_er 的高精板子就有这种）

可能的情况是有一个函数后面反复用到，然后重载也要用，以此来降低代码复杂度。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16632847.html</id>
    <title type="text">重修 指针与引用-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-08-28T07:31:00Z</published>
    <updated>2022-08-28T07:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16632847.html" />
    <content type="text">有如下操作：

```cpp
typedef int* pint;
typedef int&amp; nint;
```

（`rint` 被 cmath 用了）

而且若前面有 `#define int long long` 则这里也是 `long long`。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16647957.html</id>
    <title type="text">长链剖分-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-01T13:55:00Z</published>
    <updated>2022-09-01T13:55:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16647957.html" />
    <content type="text">能 $O(n)$ 时空解决部分 dsu on tree / 线段树合并 / 倍增 $O(n\log n)$ 时空的问题。

长链剖分的机制是**选子树内深度最大的儿子作为长儿子**（类比重链剖分的重儿子）。

然后有几个性质：

1. 一条链向上跳一条链，则链上最大深度不减。

2. 由 1 可知任何一个点向上跳链次数不会超过 $\sqrt n$ 次。（但是这个性质不是很有用）。

3. 任意一个点 $x$ 的 $k$ 次祖先 $y$ 所在的长链的长度大于等于 $k$，因为 $x\to y$ 长度为 $k$，长儿子必然更长。

## P5903 【模板】树上 k 级祖先

对树进行长链剖分，记录每个点所在链的顶点和深度。

树上倍增求出每个点的 $2^c$ 级祖先。

对于每条链，如果其长度为 $len$，那么在顶点处记录顶点向上的 $len$ 个祖先和向下的 $len$ 个链上的儿子。

预处理出每个数的二进制最高位。

对于每次询问 $x$ 的 $k$ 级祖先：

利用倍增数组先将 $x$ 跳到最大的 $2^c$ 级祖先。
​
设剩下还有 $k'$。
​
由刚刚的性质，此时 $x$ 所在长链长度 $\ge 2^c&gt;k'$。

因此可以先将 $x$ 跳到 $x$ 所在链的顶点，若之后剩下的级数为正，则利用向上的数组求出答案，否则利用向下的数组求出答案。

复杂度为 $O(n\log n)−O(1)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Create Time:        2022-09-01 21:12:55
* Last Modified time: 2022-09-01 21:53:13
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ui unsigned int
ui S;
inline ui get(ui x) {
	x ^= x &lt;&lt; 13;
	x ^= x &gt;&gt; 17;
	x ^= x &lt;&lt; 5;
	return S = x; 
}
//-------------------------
#define C 18
#define N 500010
int n,q,root,dep[N],md[N],wson[N],top[N],f[N][C+1],lg[N];
vector&lt;int&gt; e[N],up[N],dn[N];
void dfs(int rt,int fa){
	f[rt][0]=fa;
	For(i,1,C) f[rt][i]=f[f[rt][i-1]][i-1];
	md[rt]=dep[rt]=dep[fa]+1;
	for(int i:e[rt]){
		dfs(i,rt);
		ckmx(md[rt],md[i]);
		if(md[wson[rt]]&lt;md[i]) wson[rt]=i;
	}
}
void dfs2(int rt,int tp){
	top[rt]=tp;
	if(rt==tp){
		int x=rt;
		For(i,0,md[rt]-dep[rt]){
			up[rt].pb(x);
			x=f[x][0];
		}
		x=rt;
		For(i,0,md[rt]-dep[rt]){
			dn[rt].pb(x);
			x=wson[x];
		}
	}
	if(wson[rt]) dfs2(wson[rt],tp);
	for(int i:e[rt]) if(i!=wson[rt]) dfs2(i,i);
}
int que(int x,int y){
	if(!y) return x;//0 dont have lg
	x=f[x][lg[y]];
	y-=1&lt;&lt;lg[y];
	y-=dep[x]-dep[top[x]];
	x=top[x];
	return y&gt;0?up[x][y]:dn[x][-y];
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;q&gt;&gt;S;
	For(i,2,n) lg[i]=lg[i&gt;&gt;1]+1;
	int x,k,ans=0;
	long long out=0;
	For(i,1,n){
		cin&gt;&gt;x;
		if(x) e[x].pb(i);
		else root=i;
	}
	dfs(root,0);
	dfs2(root,root);
	For(i,1,q){
		x=(get(S)^ans)%n+1;
		k=(get(S)^ans)%dep[x];
		out^=(long long)i*(ans=que(x,k));
	}
	cout&lt;&lt;out&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## P3899 [湖南集训]更为厉害

长链剖分优化 DP。

时空 $O(n)$。

相当于按 $mxdep$ 启发式合并（？）

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-02 10:54:28
* Motto: We'll be counting stars.
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ll long long
#define pi pair&lt;int,int&gt;
const int N=300010;
int n,q,dep[N],wson[N],md[N],sz[N];
ll ans[N],*f[N];//f: dp's sufsum
vector&lt;int&gt; e[N];
vector&lt;pi&gt; g[N];
void dfs(int rt,int fa){
	dep[rt]=dep[fa]+1;
	sz[rt]=1;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
		sz[rt]+=sz[i];
		if(md[i]&gt;md[wson[rt]]) wson[rt]=i;
	}
	if(wson[rt]) md[rt]=md[wson[rt]];
	else md[rt]=dep[rt];
}
void work(int rt,int fa,int tp){
	if(rt==tp) f[rt]=new ll[md[rt]-dep[rt]+1];//top
	f[rt][0]=sz[rt]-1;
	if(wson[rt]){
		f[wson[rt]]=f[rt]+1;
		work(wson[rt],rt,tp);
		f[rt][0]+=f[wson[rt]][0];
	}
	for(int i:e[rt]) if(i!=fa &amp;&amp; i!=wson[rt]){
		work(i,rt,i);
		For(j,0,md[i]-dep[i]) f[rt][j+1]+=f[i][j];
		f[rt][0]+=f[i][0];
	}
	for(auto [k,x]:g[rt]){
		ans[x]=(ll)(sz[rt]-1)*min(dep[rt]-1,k);//b is anc of a
		ans[x]+=f[rt][0]-(sz[rt]-1);
		if(k&lt;md[rt]-dep[rt]) ans[x]-=f[rt][k+1];//sufsum get range sum
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;q;
	int x,y;
	For(i,1,n-1){
		cin&gt;&gt;x&gt;&gt;y;
		e[x].pb(y);
		e[y].pb(x);
	}
	dfs(1,0);
	For(i,1,q){
		cin&gt;&gt;x&gt;&gt;y;
		g[x].pb(y,i);
	}
	work(1,0,1);
	For(i,1,q) cout&lt;&lt;ans[i]&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## CF570D Tree Requests

跳坑：传 wson 时忘记 `f[wson[rt]]=f[rt]+1;`，求答案时忘记判 `k&gt;md[rt]-dep[rt]`。

## CF526G Spiders Evil Plan

复合题。

### 题意简述


给定一棵 $n$ 个节点的无根树，每条边有边权。


有 $q$ 次询问，每次询问给出 $x,y$，你需要选择 $y$ 条树上的路径，使这些路径形成一个包含 $x$ 的连通块，且连通块中包含的边 权和最大。


强制在线。


* $1 \le n, q \le 10^5$。


### 题解


可以证明：使用 $k$ 条路径就可以覆盖一棵有 $2 k$ 的叶子的树。


先以任意方式匹配叶子。如果有两条路径不相交，可以调整成相交的情况。

不断调整就可以让任意两条路径都相交，于是显然覆盖了整棵树。

（证明不严谨，因为没有说明调整能在有限步内结束，不过这不重要）


所以当询问 $y$ 的时候，就是要在原树中选取不超过 $2 y$ 个叶子，让这些叶子组成的极小连通块的边权和尽量大。


再考虑：每次询问中，一定存在一种方案使得直径的两端中至少有一端被选取。

那么我们以两个直径端点为根，每次询问在两棵树中分别查询即可。


那么，现在根是一个叶子（直径端点必然是叶子），且根必选。

也就是说，需要选其它至多 $2 y - 1$ 个叶子，打通他们到根的链，并且最大化边权和。


考虑带边权的长链剖分，发现这和选取过程是等价的，也就是贪心地选取前 $2 y - 1$ 个最长链即可。


但是选完之后不一定经过 $x$，所以需要做一下调整。


首先打通 $x$ 子树中最深的点到根的路径，然后需要去掉另一个叶子，使得减小量尽量小。


可以发现，要不然是删掉第 $2 y - 1$ 个最长链，也就是仅选取前 $2 y - 2$ 个最长链，然后把 $x$ 接上。


要不然就是在选取前 $2 y - 1$ 个最长链的基础上，先把 $x$ 接上，然后删去第一个碰到的点的其它子树。


最优解，一定符合这两种情况之一，且不会统计到错误的情况（叶子数都不超过 $2 y - 1$），所以是正确的。

向上跳的过程可以倍增，但是我喜欢省空间，写了一个重剖。

时间复杂度为 $O ((n + q) \log n)$，空间倍增 $O(n\log n)$，树剖 $O(n)$。

[倍增](https://codeforces.com/contest/526/submission/180989229)

[树剖](https://codeforces.com/contest/526/submission/180991360)

[再卡空间的树剖](https://codeforces.com/contest/526/submission/180991842)

## CF1009F Dominant Indices</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16686116.html</id>
    <title type="text">5 份代码，让你彻底搞懂 std::swap() 在干嘛-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-12T06:20:00Z</published>
    <updated>2022-09-12T06:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16686116.html" />
    <content type="text">## 1

```cpp
int a,b,*c,*d;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	a=1,b=2;
	c=&amp;a,d=&amp;b;
	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;*c&lt;&lt;" "&lt;&lt;*d&lt;&lt;endl;
	swap(a,b);
	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;*c&lt;&lt;" "&lt;&lt;*d&lt;&lt;endl;
return 0;}
```

结果为

```text
1 2 1 2
2 1 2 1
```

说明 swap 不是交换指针，而是内存内容的改变。

## 2

```cpp
#define N 10000000
int a[N],b[N],*c,*d;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	fill(a,a+N,1);
	fill(b,b+N,2);
	c=a,d=b;
	cout&lt;&lt;a[0]&lt;&lt;" "&lt;&lt;b[0]&lt;&lt;" "&lt;&lt;c[0]&lt;&lt;" "&lt;&lt;d[0]&lt;&lt;endl;
	swap(a,b);
	cout&lt;&lt;a[0]&lt;&lt;" "&lt;&lt;b[0]&lt;&lt;" "&lt;&lt;c[0]&lt;&lt;" "&lt;&lt;d[0]&lt;&lt;endl;
return 0;}
```

结果为

```text
1 2 1 2
2 1 2 1
```

说明数组的 swap 也不是交换指针，而是内存内容的改变。

所以一次 swap 的**复杂度是数组长度**的，请注意。

## 3

```cpp
#define N 10000000
int a[N],b[N],*c,*d;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	fill(a,a+N,1);
	fill(b,b+N,2);
	c=a,d=b;
	cout&lt;&lt;a[0]&lt;&lt;" "&lt;&lt;b[0]&lt;&lt;" "&lt;&lt;c[0]&lt;&lt;" "&lt;&lt;d[0]&lt;&lt;endl;
	swap(c,d);
	cout&lt;&lt;a[0]&lt;&lt;" "&lt;&lt;b[0]&lt;&lt;" "&lt;&lt;c[0]&lt;&lt;" "&lt;&lt;d[0]&lt;&lt;endl;
return 0;}
```

结果为

```text
1 2 1 2
1 2 2 1
```

指针 swap，但是内存没有换，这样是 $O(1)$ 的。

**写滚动数组时最好用这种方式。**

## 4

那有的人就要慌了，swap 的复杂度就这么高吗。

```cpp
#define N 10000000
vector&lt;int&gt; a,b;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	a.resize(N);
	b.resize(N);
	fill(a.begin(),a.end(),1);
	fill(b.begin(),b.end(),2);
	For(i,1,N) swap(a,b);
return 0;}
```

结果不会 TLE。

vector 是 $O(1)$ 交换指针。

## 5

```cpp
#define N 1000000
set&lt;int&gt; a,b;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	For(i,1,N) a.insert(i);
	For(i,1,N) b.insert(-i);
	For(i,1,N) swap(a,b);
return 0;}
```

结果不会 TLE。

其他 STL 也是 $O(1)$ 交换指针。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16697894.html</id>
    <title type="text">2022 贺题解记录（原名简思短解）（下）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-15T12:34:00Z</published>
    <updated>2022-09-15T12:34:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16697894.html" />
    <content type="text">[TOC]

~~其实也不一定是贺的。~~

## CF1153E Serval and Snake

我们可以发现，如果询问结果是奇数，那么头尾中必有一个在矩形里面而另一个不在，否则必然两个同在外或在内。

我们可以对每行每列进行询问，如果一行的结果为奇数，就二分这一行找到答案。

最多 $2n+2\lceil \log n\rceil$ 次。

当 $n=1000$ 是 $2020$ 次，小寄。

如果前面只有一个解，第 $1000$ 列不用问了，直接二分，刚好省一次。

[Code](https://codeforces.com/contest/1153/submission/177313479)

## abc246_g Game on Tree 3

~~之前我用 sjzhang 补过了，结果现在用 i_am_accepted 又交了，对比代码真没啥长进。~~

注意题目 title 是 (Game on Tree) 3 而不是 Game on (Tree 3)。

我们二分答案，接下来就转化成了一个判定问题：

&gt; 树上节点有黑白两种颜色，根节点保证是白色。
&gt;
&gt; Aoki 每次可以将一个点涂成白色，Takahashi 每次将棋子移动至一个儿子。
&gt;
&gt; Takahashi 获胜当且仅当移到了一个黑色节点，这样我们这个二分的值可以算入答案。

考虑 DP，$f_i$ 表示到达 $i$ 节点之前至少要几次在 $i$ 子树内涂白才能保证之后走不到黑点，我们最终的答案即为 $[f_1&gt;0]$。
$$
f_x=[a_x\text{ is black}]+\max(0,\sum_{i\in son_x}f_i-1)
$$
复杂度 $O(n\log n)$。

[现在的 Code](https://atcoder.jp/contests/abc246/submissions/35810877)

[远古的 Code（比现在的慢了一倍多）](https://atcoder.jp/contests/abc246/submissions/31133993)

## CF1743G Antifibonacci Cut

看完题解秒会，注意以下 Fib 可能指代 Fib 01 串或者正常的斐波那契数列。

我们将 $s_1,\dots,s_n$ 拼接成一个串 $S$。

先研究一下规律，发现除了 $f_0$ 其他 Fib 串都是同一个无限长的 01 串的前缀，大概是：

```text
101101011011010110101...
```

设 $F$ 为所有 Fib 串的集合 $\{f_0,f_1,f_2,\dots\}$。

我们先来一个 naive 的 DP，$dp_i$ 表示 $S$ 中长度为 $i$ 的前缀的划分方案数，则有：
$$
\begin{cases}
dp_0=1
\\
dp_i=\sum_{j=0}^{i-1}dp_j[S_{(j,i]}\notin F]
\end{cases}
$$
由于 Fib 串的长度以指数（底数为 $1.618$）增长，所以有用的 Fib 串是 $\log$ 级别的，所以我们改写一下上面的式子
$$
dp_i=\sum_{j=0}^{i-1}dp_j-\sum_{j=0}^{i-1}dp_j[S_{(j,i]}\in F]
$$
由于 $f_0$ 需要特判，所以
$$
\begin{aligned}
dp_i&amp;=\sum_{j=0}^{i-1}dp_j-dp_{i-1}[S_{[i,i]}\in F]-\sum_{j=0}^{i-2}dp_j[S_{(j,i]}\in F]
\\
&amp;=\sum_{j=0}^{i-2}dp_j-\sum_{j=0}^{i-2}dp_j[S_{(j,i]}\in F]\quad(\Delta)
\end{aligned}
$$
接下来题解用了 Zeckendorf 定理状物，但是我选择了更“暴力”的方法。

我们可以预处理出 Fib 的那个无限长的串（只需要前 $3\times 10^6$ 位）用 bitset 存，这样空间 2MB 够存。

然后我们每次往当前串的后面追加一个 0/1 位，并求出这位的 DP 值。若这一位正好是某个 $s_c$ 的末位，我们就输出其 $dp_i$。

我们记录多个 pair $(x,y)$，表示当前 $x$ 位置为起点的后缀是 Fib 无限长串的前缀，且 $dp_x=y$。

可以证明，对于每一个位置，pair 的数量是 $\log$ 级别的（官方也没给证明）。

所以我们动态维护这个东西，设当前位置为 $pos$，之中那些 $pos-x$ 为 $&gt;1$ 的 Fib 的二元组，$y$ 的和，就是 $(\Delta)$ 式要减掉的值。

$(\Delta)$ 前面加上的值我们简单求个和即可。

由于我要 lower_bound 判断一个数是否是 Fib，所以我的复杂度是 $O(n\log^2n)$ 的，当然也可以用移指针简单优化到 $O(n\log n)$，但是这道题考察的是空间对吧（时限 12s 慌啥）。

[Code](https://codeforces.com/contest/1743/submission/177001094)

## CF1738G Anti-Increasing Addicts

个人觉得 Alex_Wei 的题解图乱画的，所以别看。

我们称那些被迫留下的点为特殊点。

我们构建偏序关系，$A\to B$ 当且仅当 $n\times n$ 的二维平面中 $A$ 在 $B$ 的严格左上方。

首先特殊点构成长度 $\ge k$ 的链，就直接 NO。

否则答案一定是 YES，以下构造。

我们只需要求出一组 $k-1$ 条**不交**（指点不交）路径 $(a_1\to b_1),\dots,(a_{k-1}\to b_{k-1})$ 包含了所有特殊点即可，其中 $a_i=(n,i),b_i=(1,n-k+1+i)$。

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221018220621744-1868524237.png)

差不多像上图这样（自己画的有点丑）。

注意上面的路径必须是**最短路径**，即只能向右和上走。

我们选择这些路径覆盖的点集即为我们**留下**的点，发现正好
$$
(n-k+1)^2+(k-1)(n+(n-k+1))=n^2
$$
而且我们选择的路径均为反链，Dilworth 得到最长链长度 $&lt;k$，所以符合要求。

对于每一个特殊点，我们定义其权值为**偏序 DAG 中以她结束的最长链长度**（这里长度为经过的点数）。

我们第 $i$ 条边穿过所有权值为 $i$ 的特殊点，而且穿过 $(n-k+1+i,i),(i,n-k+1+i)$ 即可，可证这是可行的。

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221018222326786-1562582995.png)

时间 $O(n^2)$。

[Code](https://codeforces.com/contest/1738/submission/176889139)

（代码中 $b_i$ 的位置是 $(i,n)$，不过也一样做）

## CF1746F Kazaee

根号做法想了一万年，结果你告诉我是 $\log$ + 随机化？

我们将每种出现过的值离散化（最多 $n+q$ 种），然后每次 work，我们对于每种值以 $1/2$ 的概率「监察」她，以 $1/2$ 的概率「忽视」她。

然后询问的时候直接判断区间内「监察」的元素数量是否是 $k$ 的倍数，若不是则答案必然为 NO，否则答案可能为 YES。

这样一次 work 的错误率不高于 $1/2$，感性的证明：

我们错误在多个模 $k$ 非 $0$ 的加起来和模 $k$ 为 $0$。

由于类伪随机，$k=2$ 的时候错误率最高。设设区间内真实出现了奇数次的值有 $x$ 个，由于
$$
\sum_{k}\binom{x}{2k}=\sum_{k}\binom{x}{2k+1}
$$
所以我们的错误率（和为偶数的概率）为 $1/2$。

我们 work $30+$ 次即可保证错误率 $\le 2^{-30}$。

[Code](https://codeforces.com/contest/1746/submission/176465865)

## arc107_f Sum of Abs

题意自己看。

我们有 $|x|=\max(x,-x)$ 所以我们相当于说给每一个节点选择权值为 $(a_i+b_i)^{[1]}/ (a_i-b_i)^{[2]}/ 0$（$0$ 表示被删除），然后连边的两个点不能分别出现 $[1][2]$ 情况，问最大权值和（其实要减去 $\sum a_i$）。

发现就是一个二分图最大权独立集，Dinic 艹过去就行。

不过这个建模真的巧妙。

## P3429 [POI2005]DWA-Two Parties &amp; P6126 [JSOI2012]始祖鸟

&gt; 给定一个 $n=2000$ 个点的有向图（没有同向重边或自环），你要将点分成两个集合，使得每个点能直接到达的点有偶数个和它在同一个集合中。
&gt;
&gt; 给出一种方案或报告无解。

我们设 $a_1,\dots,a_n\ 01$ 序列表示每个点在 $0$ 集合还是 $1$ 集合。

对于点 $x$，设其连出去的点为 $b_1,\dots,b_m$，则我们的限制为：
$$
\begin{cases}
a_{b_1}\oplus a_{b_2}\oplus\dots\oplus a_{b_m}=0 &amp; m\text{ is even}
\\
a_{b_1}\oplus a_{b_2}\oplus\dots\oplus a_{b_m}\color{blue}{\oplus a_x}=1 &amp;  m\text{ is odd}
\end{cases}
$$
这样我们得到了 $n$ 元异或方程组，然后高斯消元即可。

由于值 $0/1$ 我们可以 bitset 优化成 $O(\frac{n^3}{64})$ 实际上跑得飞快。

&lt;details&gt;
&lt;summary&gt;如果你不知道异或方程组咋高斯消元（P6126 代码）&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-13 11:03:09
* Motto: We'll be counting stars.
*/
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define mkt make_tuple
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
#define N 2002
bitset&lt;N&gt; a[N];
int n;
vector&lt;int&gt; ans;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	int x,y;
	For(i,1,n){
		cin&gt;&gt;x;
		if(x&amp;1) a[i].set(i),a[i].set(n+1);
		while(x--){
			cin&gt;&gt;y;
			a[i].set(y);
		}
	}
	For(i,1,n){
		x=0;
		For(j,i,n) if(a[j][i]) x=j;
		if(!x) continue;
		if(x!=i) swap(a[x],a[i]);
		For(j,i+1,n) if(a[j][i]) a[j]^=a[i];
	}
	Rof(i,n,1){
		if(!a[i][i]) continue;
		For(j,1,i-1) if(a[j][i]) a[j]^=a[i];
	}
	For(i,1,n){
		if(!a[i][i] &amp;&amp; a[i][n+1]){
			cout&lt;&lt;"Impossible\n";
			return 0;
		}
	}
	For(i,1,n) if(a[i][n+1]) ans.pb(i);
	cout&lt;&lt;siz(ans)&lt;&lt;"\n";
	for(int i:ans) cout&lt;&lt;i&lt;&lt;" ";
	cout&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

## CF1737E Ela Goes Hiking

很简单啊，但是对于我来说很难，题目自己看。

发现 0：每两个蚂蚁之间的距离无关紧要（因为永远不会追及，只会相遇），重要的是每只蚂蚁的位置关系和方向。

发现 1：任意时刻蚂蚁从左往右编号递增，即不会改变相对位置。

发现 2：我们可以钦定 $1$ 和 $n$ 号蚂蚁方向分别是 $RL$，因为不然的话会撞墙掉头，等价。

发现 3：蚂蚁吃的过程一定分为 $2$ 个阶段：

1. 每一个初始方向为 $L$ 的蚂蚁吃掉其左侧极长的 $R$ 蚂蚁连续段。

2. 一排 $L$ 的蚂蚁逐个碰左墙掉头，然后逐个打擂台。

我们设 $a_1,\dots,a_n$ 为初始方向序列。

打擂台任意时刻必然是一个前缀决出一个 winner。

所以若 $a_x=L$，他打擂台赢了（指在前缀赢了，即不考虑守门）当且仅当 $a_{x-\lceil x/2\rceil+1},\dots,a_{x-1}$ 均为 $R$， $a_{x-\lceil x/2\rceil+1}$ 前面随意。

然后式子随便搞一搞就行了，[代码非常短](https://codeforces.com/contest/1737/submission/175200799)。

## P8576 「DTOI-2」星之界

&gt; 给你一个长度为 $n$ 的序列，$q$ 次操作，操作有以下两种：
&gt;
&gt; * 将 $[l,r]$ 内的所有值为 $x$ 的数改为 $y$。
&gt;
&gt; * 让你求出 $\displaystyle\prod_{i=l}^r\binom{\sum_{j=l}^ia_j}{a_i}\bmod 998244353$。
&gt;
&gt; $1\le n,q,a_i,x,y\le 10^5$。任意时刻 $\sum a_i\le 10^7$。

转化一下要求的式子：
$$
\frac{(\sum_{i=l}^ra_i)!}{\prod_{i=l}^ra_i!}
$$
由于 $\sum a\le 10^7$，我们预处理 $10^7$ 内的阶乘和其逆元。问题转化为求**区间和**与**区间阶乘逆元乘积**。

发现很难 Poly log 做，我们考虑分块。

每个块维护块内和、块内区间阶乘逆元乘积，以及对每种值做并查集，维护每种值并查集的 root 在哪个位置。

修改：

* 散块，我们暴力摊平修改重构。

* 整块，设我们要将 $x$ 值改为 $y(x\ne y)$。若 $y$ 值非空则将 $x$ 并查集 root father 指向 $y$ 并查集 root；否则，我们将 $x$ root 的值改为 $y$。最后记得修改区间和与区间阶乘逆元乘积。

查询：

* 散块暴力查询并查集 root 值。

* 整块直接查询记录的两个值即可。

修改区间阶乘逆元乘积时预处理每种值的阶乘逆元的每种正整数幂。

由于幂次不大于块长，所以我们预处理 $O(n\sqrt n)$，单整块修改就 $O(1)$ 了。

时空复杂度 $O(n\sqrt n)$。

注意卡空间，取模的东西开不得 longlong。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-08 16:06:28
* Motto: We'Z be counting stars.
*/
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define pi pair&lt;int,int&gt;
#define pz pair&lt;int,Z&gt;
template&lt;int P&gt;
class mod_int{
	using Z=mod_int;
private:
	static int mo(int x){return x&lt;0?x+P:x;}
public:
	int x;
	int val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;int&gt;(x_):mo(static_cast&lt;int&gt;(x_%P))){}
	bool operator==(const Z&amp;rhs)const{return x==rhs.x;}
	bool operator!=(const Z&amp;rhs)const{return x!=rhs.x;}
	Z operator-()const{return Z(x?P-x:0);}
	Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&amp;1)res*=t;if(k&gt;&gt;=1)t*=t;}return res;}
	Z&amp;operator++(){x&lt;P-1?++x:x=0;return *this;}
	Z&amp;operator--(){x?--x:x=P-1;return *this;}
	Z operator++(int){Z ret=x;x&lt;P-1?++x:x=0;return ret;}
	Z operator--(int){Z ret=x;x?--x:x=P-1;return ret;}
	Z inv()const{return pow(P-2);}
	Z&amp;operator+=(const Z&amp;rhs){(x+=rhs.x)&gt;=P&amp;&amp;(x-=P);return *this;}
	Z&amp;operator-=(const Z&amp;rhs){(x-=rhs.x)&lt;0&amp;&amp;(x+=P);return *this;}
	Z&amp;operator*=(const Z&amp;rhs){x=1ULL*x*rhs.x%P;return *this;}
	Z&amp;operator/=(const Z&amp;rhs){return *this*=rhs.inv();}
#define setO(T,o) friend T operator o(const Z&amp;lhs,const Z&amp;rhs){Z res=lhs;return res o##=rhs;}
	setO(Z,+)setO(Z,-)setO(Z,*)setO(Z,/)
#undef setO
};
const int P=998244353;
using Z=mod_int&lt;P&gt;;
const int N=1e5+5,B=350,bsz=300,K=1e7+5;
Z fac[K],ivf[K],Fac[B][N],ivF[B][N];//I have to use Z otherwise MLE!!
int n,q,a[N],b[N],L[B],R[B],bt;
void init(){
	fac[0]=1; For(i,1,K-1) fac[i]=fac[i-1]*i;
	ivf[K-1]=fac[K-1].inv(); Rof(i,K-1,1) ivf[i-1]=ivf[i]*i;
	fill(Fac[0],Fac[0]+N,1);
	fill(ivF[0],ivF[0]+N,1);
	For(i,1,B-1) For(j,0,N-1){
		Fac[i][j]=Fac[i-1][j]*fac[j];
		ivF[i][j]=ivF[i-1][j]*ivf[j];
	}
}
int f[N];
pz operator+(const pz&amp; x,const pz&amp; y){ return mkp(x.fir+y.fir,x.sec*y.sec); }
void operator+=(pz&amp; x,const pz&amp; y){ x=x+y; }
Z calc(pz x){ return fac[x.fir]*x.sec; }
pz val[B];//sum prod_infac
pi root[B][N];//rootid cnt
inline int gf(int x){ return x==f[x]?x:f[x]=gf(f[x]); }
void build(int x){
	val[x]=mkp(0,1);
	For(i,L[x],R[x]){
		val[x]+=mkp(a[i],ivf[a[i]]);
		pi &amp;tmp=root[x][a[i]];
		if(!tmp.fir){
			tmp=mkp(i,1);
			f[i]=i;
		}else{
			tmp.sec++;
			f[i]=tmp.fir;
		}
	}
}
void ruin(int x){
	For(i,L[x],R[x]){
		a[i]=a[gf(i)];
		root[x][a[i]]=mkp(0,0);
	}
}
void small(int x,int l,int r,int u,int v){
	if(l&gt;r) return ;
	ruin(x);
	For(i,l,r) if(a[i]==u) a[i]=v;
	build(x);
}
void big(int x,int u,int v){
	pi &amp;U=root[x][u],&amp;V=root[x][v];
	val[x]+=mkp((v-u)*U.sec,Fac[U.sec][u]*ivF[U.sec][v]);
	V.sec+=U.sec;
	if(V.fir) f[U.fir]=V.fir;
	else a[V.fir=U.fir]=v;
	U=mkp(0,0);
}
void work(int l,int r,int u,int v){
	if(b[l]==b[r]) return small(b[l],l,r,u,v);
	For(i,b[l]+1,b[r]-1) big(i,u,v);
	small(b[l],l,R[b[l]],u,v);
	small(b[r],L[b[r]],r,u,v);
}
pz que(int l,int r){
	pz res(0,1);
	int x;
	For(i,l,r){
		x=a[gf(i)];
		res+=mkp(x,ivf[x]);
	}
	return res;
}
Z query(int l,int r){
	if(b[l]==b[r]) return calc(que(l,r));
	pz res(0,1);
	For(i,b[l]+1,b[r]-1) res+=val[i];
	res+=que(l,R[b[l]]);
	res+=que(L[b[r]],r);
	return calc(res);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	init();
	cin&gt;&gt;n&gt;&gt;q;
	For(i,1,n) cin&gt;&gt;a[i];
	For(i,1,n) b[i]=(i-1)/bsz+1;
	For(i,1,n) R[b[i]]=i;
	Rof(i,n,1) L[b[i]]=i;
	bt=b[n];
	For(i,1,bt) build(i);
	int x,y,l,r,opt;
	while(q--){
		cin&gt;&gt;opt;
		if(opt==1){
			cin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;y;
			if(x!=y) work(l,r,x,y);
		}else{
			cin&gt;&gt;l&gt;&gt;r;
			cout&lt;&lt;query(l,r).val()&lt;&lt;"\n";
		}
	}
return 0;}
```
&lt;/details&gt;

## CF1738F Connectivity Addicts

[题目自个看](https://codeforces.com/contest/1738/problem/F)

膜拜 shz。

有一个好猜但不好证的结论：

&gt; 每次选择未染色的点中度数最大的点 $x$，然后一条一条询问其边。
&gt;
&gt; 若所有度数对面都没有染色过的点，我们就给这些点和 $x$ 新开一个颜色；否则我们询问到一个染色过的点 $y$ 就停止询问，我们将 $x$ 和询问过的点都染同 $y$ 的颜色。

归纳法证明：

显然的是，任意时刻每种颜色 $n_c&gt;$ 这种颜色度数最大点的度数。

对于我们新开一个颜色的情况：
$$n_c=deg_x+1,s_c\le deg_x(deg_x+1)&lt;n_c^2$$
对于我们合并到原有颜色的情况，我们设原来为 $n_c',s_c'$，现在新增了 $cnt$ 个点（包括 $x$）：
$$n_c=n_c'+cnt$$
$$\begin{aligned}s_c&amp;\le s_c'+deg_x\cdot cnt
\\&amp;&lt; (n_c')^2+n_c'\cdot cnt
\\&amp;&lt;(n_c'+cnt)^2
\\&amp;=n_c^2\end{aligned}$$

[Code](https://codeforces.com/contest/1738/submission/174634982)

## CF1739F Keyboard Design

膜拜 cxy。

先将每一个打入的 word 转换成要求键盘中存在某个字符串为子串或其 reverse 后为子串，若不行则必然不能拿到她的 $c_i$。

对于字符串长度为 $1$ 的 word，我们不论怎样必然可以打出这个 word，直接白拿她的 $c_i$。

所以剩下的 word 对应的字符串 $S$ 长度 $\ge 2$，得到 $S$ 和 $\text{rev}(S)$ 不可能同时存在于键盘中作为子串。

所以我们可以转化为有 $2000$ 个字符串，若存在于最终的键盘中则可以加上对应的分值（可证要是存在只会存在一次），问最大得分。

我们将这些 word 建 AC 自动机，可证自动机不超过 $4000$ 个节点。

我们 DP，顺序将字符填入最终键盘，设 $f(S,i)$ 表示我们已经填入了 $S$ 集合中的字符（状压），现在在自动机的 $i$ 节点上，现有的得分的最大值。

然后就可以跑自动机转移 DP 了，注意到了一个点的时候要把这个点及不断跳 fail 的贡献求和加入，这个可以 AC 
自动机 build 的时候计算。

复杂度 $O(2^{12}\times 12\times 4000)$。

[Link](https://codeforces.com/contest/1739/submission/174169820)

## CF1613F Tree Coloring

[看这里的 $O(n\log^2 n)$ 解法](https://www.luogu.com.cn/blog/Garyhuang1234567890/solution-cf1613f)

[简短的代码](https://codeforces.com/contest/1613/submission/173891418)

## U66520 生命游戏 &amp; P4804 [CCC2016] 生命中的圆

太高妙了。

显然每次将序列每个位置同时变成两侧的异或。

我们计算一个位置 $k$ 时刻的值是由哪些初始值异或得来，发现是一个谢尔宾斯基三角状物，不太好搞……

吗？

```text
          1
         101
        10001
       1010101
      100000001
     10100000101
    1000100010001
   101010101010101
  10000000000000001
 1010000000000000101
100010000000000010001
```

发现谢尔宾斯基三角任意 $2^c(c\in\N^{+})$ 行都是左右各一个 $1$，且距离为 $2^c$，可以快速计算异或。

我们将 $k$ 二进制拆分后每一位暴力做即可，复杂度 $O(n\log k)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-02 13:45:11
* Motto: We'll be counting stars.
*/
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
#define N 500010
#define int ll
int n,k;
bool s[N],t[N];
char c[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;c;
	For(i,0,n-1) s[i]=c[i]-'0';
	int len;
	For(i,0,61){
		if(k&amp;1){
			len=(1ll&lt;&lt;i)%n;
			For(j,0,n-1) t[j]=s[(j-len+n)%n]^s[(j+len)%n];
			For(j,0,n-1) s[j]=t[j];
		}
		k&gt;&gt;=1;
	}
	For(i,0,n-1) cout&lt;&lt;s[i]; cout&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

## arc148_e ≥ K

[官方](https://atcoder.jp/contests/arc148/editorial/4810)

&gt; 有多少 $a_1,\dots,a_n$ 的重排 $b_1,\dots,b_n$ 使得 $\{b\}$ 的任意两个相邻的元素的和都 $\ge k$。
&gt;
&gt; 答案 $\bmod 998244353$。
&gt;
&gt; 由于组合意义，$\{b\}$ 到底是本质不同还是按 $\{a\}$ 标号计数其实无所谓（两者可 $O(1)$ 转化）。

考虑一种奇特的元素插入顺序：

先设 $a_1\le a_2\le\dots\le a_c&lt; \frac{k}{2}\le a_{c+1}\le\dots\le a_n$。

将 $a_1,\dots,a_c$ 按 $\frac{k}{2}$ 翻着，也就是按 $|a_i-\frac{k}{2}|$ 降序排序，对于相同的这个绝对值则 $a_i\ge\frac{k}{2}$ 的优先。

与此等价的排序方式：

&gt; 双指针 $l=1,r=n$。
&gt;
&gt; 若 $a_l+a_r&lt;k$，我们放入 $a_l$，$l$ 加一。
&gt;
&gt; 否则 $a_l+a_r\ge k$，我们放入 $a_r$，$r$ 减一。

由于边界没有限制，不妨设 $b_0=b_{n+1}=\infty$。

$\{b\}$ 中没有填数的地方我们设为 $\text{Null}$，相当于我们看作链表而不是数组。

设“空隙”为两个 $\ge \frac{k}{2}$ 之间的位置。

每次插入一个数的时候：

* 若这个数 $\ge \frac{k}{2}$，我们可以也只可以插入一个空隙，并会让空隙数增加 $1$。

* 若这个数 $\le\frac{k}{2}$，我们仍然可以也只可以插入一个空隙，但是让空隙数减少 $1$。

我们证明上面两句话：

* 若这个数 $\ge \frac{k}{2}$，显然可以放空隙，而且由于之前放过的 $&lt;\frac{k}{2}$ 的数都太小太小啦（参考我们的排序方式），所以我们放不了非空隙的地方。

* 若这个数 $\le\frac{k}{2}$，显然不可以放非空隙，而且由于之前放过的 $\ge\frac{k}{2}$ 的数都足够大，所以我们可以放所有空隙。

将每次可选的位置数量乘起来就是答案了，这句话有点显然，不过可以去看官方题解。

用一个变量动态维护空隙数量。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-13 18:18:10
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=998244353;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 200010
int n,m,a[N],f[N],ans=1,cnt=1,qwq=1;
map&lt;int,int&gt; mp;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	For(i,1,n) cin&gt;&gt;a[i];
	sort(a+1,a+1+n);
	int L=1,R=n;
	while(L&lt;=R){
		(ans*=cnt)%=mod;
		if(a[L]+a[R]&gt;=m){//add a[R]
			cnt++;
			R--;
		}else{//add a[L]
			cnt--;
			L++;
		}
	}
	f[0]=1; For(i,1,n) f[i]=f[i-1]*i%mod;
	For(i,1,n) mp[a[i]]++;
	for(auto i:mp) (qwq*=f[i.sec])%=mod;
	cout&lt;&lt;ans*pw(qwq,mod-2)%mod&lt;&lt;endl;
return 0;}
```
&lt;/details&gt;

## HEZOJ#348. 20221001-BDFZ-T2-马克思么克斯

EI 高质量题。

&gt; 给定数列 $a_1,\dots,a_n$，设
&gt; $$f_k=\max_{r-l+1=k}\text{mex}_{i=l}^r a_i$$
&gt; 求 $f_1,\dots,f_n$。

对偶命题：求出取到每种 $\text{mex}$ 的子串的最小长度。

我们将 $a_1,\dots,a_n$ 升序插入序列。

当插入了值 $\le x$ 的所有 $a_i$ 后，我们求出取到 $\text{mex}=x+1$ 的子串的最小长度。

对序列上每个位置维护最小的 $r_i$ 满足 $[i,r_i]$ 包含 $0\sim x$ 的所有值。

初始时 $r_i=i$。

每次将 $x-1$ 变为 $x$ 时找到所有值为 $x$ 的位置 $p_1&lt;\dots &lt;p_c$，特别地我们设 $p_0=0$。

那么对于 $p_{i-1}&lt;j\le p_i$，$r_j\leftarrow \max(r_j,p_i)\quad (*)$。

特别地，若 $j&gt;p_c$，$r_j\leftarrow \infty$。

注意到 $\forall i,r_i&lt; r_{i+1}$，所以 $(*)$ 的区间 $\max$ 可以线段树上二分然后转为区间赋值。

每次操作完后求 $\min_{i=1}^n(r_i-i+1)$。

线段树轻松搞定。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-01 16:50:03
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
#define int ll
#define N 100010
const int inf=1e18;
vector&lt;int&gt; p[N];
int n,ans[N],len[N];
struct node{
	int ans,val;
	node(){}
	node(int x,int y){ ans=x,val=y; }
	friend node operator+(const node&amp; x,const node&amp; y){
		return node(min(x.ans,y.ans),x.val);
	}
}t[N&lt;&lt;2];
int lz[N&lt;&lt;2];
#define mid ((l+r)&gt;&gt;1)
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
void tag(int rt,int l,int r,int val){
	t[rt].val=val;
	t[rt].ans=val-r+1;
	lz[rt]=val;
}
void pd(int rt,int l,int r){
	if(lz[rt]&gt;=0){
		tag(ls,l,mid,lz[rt]);
		tag(rs,mid+1,r,lz[rt]);
		lz[rt]=-1;
	}
}
void build(int rt,int l,int r){
	lz[rt]=-1;
	if(l==r){
		t[rt]=node(1,l);
		return ;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	t[rt]=t[ls]+t[rs];
}
void add(int rt,int l,int r,int x,int y,int val){
	if(x&lt;=l &amp;&amp; r&lt;=y){
		tag(rt,l,r,val);
		return ;
	}
	pd(rt,l,r);
	if(x&lt;=mid) add(ls,l,mid,x,y,val);
	if(y&gt;mid) add(rs,mid+1,r,x,y,val);
	t[rt]=t[ls]+t[rs];
}
int fd(int rt,int l,int r,int x){//val&lt;x 的最后位置
	if(l==r) return l;
	pd(rt,l,r);
	if(t[rs].val&lt;x) return fd(rs,mid+1,r,x);
	else return fd(ls,l,mid,x);
}
void work(int l,int r,int val){
	if(l&gt;r) return ;
	int pos;
	if(t[1].val&gt;=val) pos=0;
	else pos=fd(1,1,n,val);
	if(pos&gt;=l) add(1,1,n,l,pos,val);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	int x;
	For(i,1,n){
		cin&gt;&gt;x;
		p[x].pb(i);
	}
	build(1,1,n);
	fill(len,len+1+n,inf);
	For(i,0,n){
		x=0;
		for(int j:p[i]){
			work(x+1,j,j);
			x=j;
		}	
		work(x+1,n,inf);
		len[i]=t[1].ans;
	}
	For(i,0,n) if(len[i]&lt;=n) ckmx(ans[len[i]],i+1);
	For(i,2,n) ckmx(ans[i],ans[i-1]);
	int q;
	cin&gt;&gt;q;
	while(q--){
		cin&gt;&gt;x;
		cout&lt;&lt;ans[x]&lt;&lt;"\n";
	}
return 0;}
```
&lt;/details&gt;

## CF1730E Maximums and Minimums

考场上认为带根号做法过不去……

我们从大到小枚举区间内最小值，再枚举最小值倍数的最大值，计算答案。

设最小值为 $mn$，最大值为 $mx$。

枚举每一个值为 $mx$ 的位置，求出**以这个位置为区间最大值 $^{[1]}$ 且区间内不存在 $\le mn$ 的值的区间个数 $A$**与**不存在 $&lt;mn$ 的值的区间个数$B$**。

$[1]:$ 这里区间最大值位置定义为区间最大值出现的最靠左的位置。

发现这样 $(mn,mx)$ 对答案的贡献即为 $B-A$。

考虑如何快速算出 $A,B$，发现我们用单调栈预处理和序列上并查集即可快速维护。

[link](https://codeforces.com/contest/1730/submission/173563581)

## CF1730D Prefixes and Suffixes

**酰化**

我是傻逼，卡在这道题。

* * *

我们将 $s_2$ reverse，这样好做。

发现操作就变成了：

找 $s_1,s_2$ 长度相同的前缀，分别翻转并 swap。$(*)$

且最终成功的判定成为：

$s_1$ reverse 后为 $s_2$。$(\Delta)$

通过研究 $(*)$ 操作，发现对于 $s_1,s_2$ 初始下标相同的二元组，最后两者的下标仍然相同（**可能**所属的字符串变了），而且若这些二元组 swap 和重排可以使得 $(\Delta)$ 成立，$(*)$ 的操作必然也行。

原因是选取长度为 $1$ 的操作可以将首项的二元组 swap，选取长度为 $k$ 的操作可以将处理好的放在首位的二元组放置在 $k$ 位置。

[link](https://codeforces.com/contest/1730/submission/173479520)

## P4467 [SCOI2007]k短路 &amp; HEZOJ#341. 20220927-CDQZ-T2-悟

&gt; 给定一个 $n$ 点 $m$ 有向边的图，输出从 $1$ 点到 $n$ 点的第 $k$ 短路。
&gt;
&gt; 路的定义是简单路径。
&gt;
&gt; $X$ 路径比 $Y$ 路径短当且仅当 $X$ 比 $Y$ 总长短，或总长相同，且 $X$ 经过的点的序列字典序比 $Y$ 小。
&gt;
&gt; $2\le n\le 50,1\le k\le 500$
&gt;
&gt; 要求确定的多项式复杂度做法（即非 $\text{A*}$）。

洛谷用户 约瑟夫用脑玩 撤下了所有 $\text{A*}$ 的题解，声称都不是正解而是乱搞。

然后模拟赛出了这道题，5ab 和 cxy 学习了 sol 里的方法（cxy：“出题人教大家求 $k$ 短路”），发现 约瑟夫用脑玩 的 $O(n^3k)$ 解法是有问题的，拍了一中午出了 [Hack](https://www.luogu.com.cn/discuss/501064)。

这里可证明的正解为 $O(n^3k\log L)$，其中 $L$ 为 $k$ 短路最大长度。

首先二分答案 $mid$，即最终路径的长度。考虑如何判断长度 $\le lim$ 的路径数和 $k$ 的大小关系。

DFS 一个路径的前缀 $p_1,p_2,\cdots,p_k$。并**从小到大**枚举 $p_{k+1}$ 可能的值。

我们设原图为 $G$，在 $G-\{p_1,\dots,p_k\}$ 图中跑 $n$ 点的**单汇**最短路（因为有向图，所以单源单汇有区别），设 $p_{k+1}$ 最短路长度为 $X$。

当且仅当已有的路径 $p_1\sim p_{k+1}$ 长度加上 $X\le lim$，这个 $p_{k+1}$ 就保证进一步搜索必定能找到至少一个解，我们称这样 $p_{k+1}$ 是合法的。

一直在合法中 DFS 直到 $p_c=n$ 为止，计入答案。

由于 DFS 时我们从小到大枚举 $p_{k+1}$ 可能的值，二分出最终路径的长度后，再跑一次搜索即可得出答案。

* * *

关于时间复杂度。

时间复杂度为 $O(\text{one DFS}\times \log L)$。

DFS 搜索到一个状态（$\{p\}$，一个路径前缀）时，这个状态进一步搜索一定至少能对答案贡献 $1$。

由于我们只搜索 $k$ 条路径，每条路径最多 $n$ 个点，所以一个点最多被搜索到 $O(nk)$ 次（不然每次被搜索解至少 $+1$，这样不止 $k$ 条）而每次搜索到一个点的时候我们都要做一遍 **$O(n^2)$ 的 Dijkstra**，所以 $\text{one DFS}=O(n^3k)$。

总体 $O(n^3k\log L)$，上限非常宽松，可以通过。

要注意在搜索的时候剪枝，即搜出来的合法路径不能超过 $k$ 条，否则复杂度就没有保证。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-29 18:45:48
* Motto: We'll be counting stars.
*/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define ckmn(a,b) a=min(a,b)
const int inf=1e9,N=51;
int n,m,k,S,T,lim,cnt,show,s[N],a[N][N],e[N][N],st=0;
bool kil[N],vis[N];
void dij(int *dis){
	fill(dis+1,dis+1+n,inf);
	copy(kil+1,kil+1+n,vis+1);
	dis[T]=0;
	int x;
	while(true){
		x=0;
		For(i,1,n)
			if(!vis[i] &amp;&amp; (!x || dis[i]&lt;dis[x]))
				x=i;
		if(!x) break;
		vis[x]=true;
		For(i,1,n)
			if(!vis[i])
				ckmn(dis[i],dis[x]+e[i][x]);//!! e[i][x] not e[x][i]
	}
}
void dfs(int x,int len){
	if(cnt==k) return ;
	if(x==T){
		if(show){
			if(len==lim) cnt++;
			if(cnt==show){
				For(i,1,st) cout&lt;&lt;s[i]&lt;&lt;"-";
				cout&lt;&lt;x&lt;&lt;"\n";
				exit(0);
			}
		}else return cnt++,void();
	} 
	dij(a[x]);
	s[++st]=x;
	kil[x]=true;
	int nlen;
	For(i,1,n)
		if(!kil[i] &amp;&amp; (nlen=len+e[x][i])+a[x][i]&lt;=lim)
			dfs(i,nlen);
	kil[x]=false;
	st--;
}
int check(int x,int y=0){
	lim=x,cnt=0,show=y;
	dfs(S,0);
	return cnt;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;S&gt;&gt;T;
	For(i,1,n) fill(e[i]+1,e[i]+1+n,inf);
	int x,y,z;
	For(i,1,m){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
		e[x][y]=z;
	}
	int l=1,r=inf-1,mid,res=inf;
	while(l&lt;=r){
		mid=(l+r)&gt;&gt;1;
		if(check(mid)&lt;k) l=mid+1;
		else res=mid,r=mid-1;
	}
	if(res==inf) return cout&lt;&lt;"No\n",0;
	check(res,k-check(res-1));
return 0;}
```
&lt;/details&gt;

## P3172 [CQOI2015]选数

转化后的题意：

&gt; 给定值域区间 $[L,R]$，从中 $n$ 次选择数（共 $(R-L+1)^n$ 种），问有几种方法使得这 $n$ 个数的 $\gcd=1$。
&gt;
&gt; $1\le n,L,R\le 10^9,0\le R-L\le 10^5$

发现 $n$ 个数里存在两个数不一样，$\gcd$ 就 $\le R-L\le 10^5$。

我们先特判掉 $n$ 个数相同的情况（$[L=1]$）。

我们设 $f(d)$ 表示 $n$ 个数不全相同且 $\gcd$ 是 $d$ 的倍数的方案数。

设 $[L,R]$ 内 $d$ 的倍数有 $cnt$ 个，则 $f(d)=cnt^n-cnt$。

然后我们设 $g(d)$ 表示 $\gcd$ 恰好为 $d$ 的方案数，可得
$$
g(d)=f(d)-\sum_{i=2}^{\lfloor(R-L)/d\rfloor} g(di) 
$$
最后答案即为 $g(1)$。

时间复杂度 $O((R-L)\ln(R-L))$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-29 11:17:25
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define ll long long
#define pi pair&lt;int,int&gt;
template&lt;int P&gt;
class mod_int{
	using Z=mod_int;
private:
	static int mo(int x){return x&lt;0?x+P:x;}
public:
	int x;
	int val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;int&gt;(x_):mo(static_cast&lt;int&gt;(x_%P))){}
	bool operator==(const Z&amp;rhs)const{return x==rhs.x;}
	bool operator!=(const Z&amp;rhs)const{return x!=rhs.x;}
	Z operator-()const{return Z(x?P-x:0);}
	Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&amp;1)res*=t;if(k&gt;&gt;=1)t*=t;}return res;}
	Z&amp;operator++(){x&lt;P-1?++x:x=0;return *this;}
	Z&amp;operator--(){x?--x:x=P-1;return *this;}
	Z operator++(int){Z ret=x;x&lt;P-1?++x:x=0;return ret;}
	Z operator--(int){Z ret=x;x?--x:x=P-1;return ret;}
	Z inv()const{return pow(P-2);}
	Z&amp;operator+=(const Z&amp;rhs){(x+=rhs.x)&gt;=P&amp;&amp;(x-=P);return *this;}
	Z&amp;operator-=(const Z&amp;rhs){(x-=rhs.x)&lt;0&amp;&amp;(x+=P);return *this;}
	Z&amp;operator*=(const Z&amp;rhs){x=1ULL*x*rhs.x%P;return *this;}
	Z&amp;operator/=(const Z&amp;rhs){return *this*=rhs.inv();}
#define setO(T,o) friend T operator o(const Z&amp;lhs,const Z&amp;rhs){Z res=lhs;return res o##=rhs;}
	setO(Z,+)setO(Z,-)setO(Z,*)setO(Z,/)
#undef setO
};
const int P=1e9+7;
using Z=mod_int&lt;P&gt;;
#define N 100010
int n,L,R;
Z f[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int x;
	cin&gt;&gt;n&gt;&gt;x&gt;&gt;L&gt;&gt;R;
	L=(L-1)/x+1;
	R=R/x;
	if(L&gt;R) return cout&lt;&lt;"0\n",0;
	int l,r;
	Z tmp;
	For(i,1,R-L){
		l=(L-1)/i+1,r=R/i;
		if(l&gt;r) continue;
		tmp=r-l+1;
		f[i]=tmp.pow(n)-tmp;
	}
	Rof(i,R-L,1){
		for(int j=2*i;j&lt;=R-L;j+=i){
			f[i]-=f[j];
		}
	}
	if(L==1) f[1]++;
	cout&lt;&lt;f[1].val()&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

## P3515 [POI2011]Lightning Conductor &amp; SP9070 LIGHTIN - Lightning Conductor &amp; P5503 [JSOI2016]灯塔

&gt; 给定一个序列 $a_1,\dots,a_n$，求一个序列 $p_1,\dots,p_n$，每一个 $p_i$ 为满足以下条件的最小自然数：
&gt;
&gt; $\forall j,p_i\ge h_j-h_i+\sqrt{|i-j|}$
&gt;
&gt; $n\le 5\times 10^5$

首先有显然的根号做法，这里不谈。

对于限制 $p_i$ 的所有 $h_j$，分为 $j&lt;i$ 和 $j&gt;i$ 两类，其中后面的我们可以正着做完反着做即可。

所以对于每一个 $i$ 我们需要快速求出
$$
-h_i+\min_{j=1}^{i-1}h_j+\sqrt{i-j}
$$
通过将 $f_j(x)=h_j+\sqrt{x-j}$ 函数画出来，发现任意两个根号函数之间最多只有一个交点（证明可用二阶导数），再通过一些简单的（几何）推导得到**决策单调**。

也就是说存在序列 $d_2,\dots,d_n$ 使得

* $d_i&lt;i$

* $p_i=-h_i+h_{d_i}+\sqrt{i-d_i}$（$p_i$ 指单侧结果）

* $d_i\le d_{i+1}$

然后我们分治即可（类似整体二分弱化版？），复杂度为 $O(n\log n)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-22 15:23:45
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 500005
#define db double
int n,a[N],b[N],ans[N];
db calc(int i,int j){
	return a[j]-a[i]+sqrt(i-j);
}
int get(int id,int L,int R){
	int res=L;
	db qwq=calc(id,L),now;
	For(i,L+1,R){
		now=calc(id,i);
		if(now&gt;qwq){
			qwq=now;
			res=i;
		}
	}
	return res;
}
void work(int l,int r,int L,int R){
	if(l&gt;r) return ;
	int mid=(l+r)&gt;&gt;1;
	b[mid]=get(mid,L,min(mid-1,R));
	work(l,mid-1,L,b[mid]);
	work(mid+1,r,b[mid],R);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	For(i,1,n) cin&gt;&gt;a[i];
	work(1,n,1,n);
	For(i,1,n) ckmx(ans[i],(int)ceil(calc(i,b[i])));
	reverse(a+1,a+1+n);
	work(1,n,1,n);
	For(i,1,n) ckmx(ans[n+1-i],(int)ceil(calc(i,b[i])));
	For(i,1,n) cout&lt;&lt;ans[i]&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

## P7099 [yLOI2020] 灼

设 $f_i$ 表示在坐标 $i$ 时的期望步数，则有：
$$
f_i=(f_{i-1}+f_{i+1})/2+1
$$
边界条件是在虫洞结点上 $f_i = 0$。

考虑把式子整理，可以得到
$$
f_{i+1}-f_{i}=f_{i}-f_{i-1}-2
$$
这就是说，$f$ 的二阶差分是一个非零常数。因此 $f$ 的通项公式一定是一个二次多项式。

由于二阶差分是 $-2$，得到通项 $f_x=ax^2+bx+c$ 中 $a=-1$。

再用虫洞的零点求出通项公式即可。

## T272214 「EPOI R1」排排队

（因为这题是原题所以被爆破了）

&gt; $T$ 组询问，每次给出 $n,p,k$，表示询问以下 $n$ 排列的个数：
&gt;
&gt; 该序列的最长下降子序列（LDS）的长度不超过 $2$ 且 $a_p=k$。
&gt;
&gt; $T\le 10^6,n\le 10^7$，答案取模 $10^9+7$。

称 LDS 长度不超过 $2$ 的 $n$ 排列为好排列。

首先一个非常巧妙的转化：

任意一个好排列存在一个与 $n$排列前缀$\max$序列 的双射。

* * *

证明：

确定了一个好排哪些位置是前缀最大值以及值是多少后能唯一确定这个好排列，因为剩下的数只能递增放置。

而一个好排列能唯一对应一个前缀$\max$（单调栈）。

* * *

接下来是一个非常 nb 的结论：

对于任意好排列中 $a_x\ge x$ 的 $x$，必然出现在前缀$\max$（单调栈）中。

* * *

证明：

若不在，则前面必有 $&gt;a_x$ 的值，则后面 $&gt;a_x$ 的值的个数 $\le n-a_x-2\le n-x-2$，则后面至少有一个 $&lt;a_x$ 的数，构成了长度为 $3$ 的下降子序列，矛盾。

* * *

最后再来一个浅显的结论：

限制 $a_x=y$ 和 $a_y=x$ 的好排列个数是相同的。

证明就算了，像是置换的逆。

* * *

所以我们先 swap 来保证 $p\le k$。

然后我们就求$\max$序列 $b_p=k$ 的$\max$序列的个数。

我们发现 $\{b\}$ 成为$\max$序列的充要条件：

* $b_i\ge i$

* $b_{i-1}\le b_i$

* $b_i\in[1,n]$

发现就是路径计数问题，我们还是用最经典的翻折法。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-19 13:16:35
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
const ll mod=1e9+7;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&amp;1)r=r*x%mod;x=x*x%mod;y&gt;&gt;=1;}return r;}
#define int ll
#define N 10000005
int f[N&lt;&lt;1],ivf[N];
inline int C(int x,int y){
	if(y&lt;0 || y&gt;x) return 0;//necessary
	return f[x]*ivf[y]%mod*ivf[x-y]%mod;
}
void init(){
	f[0]=1; For(i,1,(N&lt;&lt;1)-1) f[i]=f[i-1]*i%mod;
	ivf[N-1]=pw(f[N-1],mod-2); Rof(i,N-1,1) ivf[i-1]=ivf[i]*i%mod;
}
void work(){
	int n,x,y;
	cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;
	if(x&gt;y) swap(x,y);
	cout&lt;&lt;(C(x+y-2,y-1)-C(x+y-2,y)+mod)*(C(2*n-x-y,n-x)-C(2*n-x-y,n-x+1)+mod)%mod&lt;&lt;"\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	init();
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
```
&lt;/details&gt;

## P3645 [APIO2015] 雅加达的摩天楼

我们认为 $n,m$ 同阶。

根本不需要最短路算法，这是一个无权图最短路，所以直接 BFS 就行。

也不需要显式建图，直接 BFS 转移即可。

状态 $(i,j)$ 表示，当前在第 $i$ 个点，当前的 doge 跳跃能力为 $j$。

当 $j \le \sqrt{n}$ 时，只有 $n \sqrt{n}$ 个状态。

当 $j \gt \sqrt{n}$ 时，只有 $m \sqrt{n}$ 个状态。

（最多有 $m$ 只 doge，每只 doge 只有 $\frac{n}{j}\lt \sqrt{n}$ 个可行位置）

$(i,j)$ 可以转移到 $(i-j, j)$ 和 $(i+j,j)$，同时对于第一次访问到的 $i$，把初始在 $i$ 的所有 doge 加入队列。

状态判重时使用 set 会 TLE，可以用 bitset。

时间复杂度 $O(n\sqrt{n})$。

## CF1479D Odd Mineral Resource

给定一棵树，每个点有颜色 $c_i$，多次查询，每次给定 $u,v,l,r$，你需要给出一个颜色 $x$，使得 $x$ 满足：

1. $x\in [l,r]$
2. $x$ 在 $u$ 到 $v$ 的路径上出现了奇数次。

你需要对于每组查询给出 $x$，如果一组查询不存在合法的 $x$，则输出 $-1$。

$n,m\le 3\times 10^5$

* * *

出现奇数次可以用异或来处理。

如果对于每一个元素，进行随机赋值。我们查询树上 $u$ 到 $v$ 上，编号在 $l$ 到 $r$ 的权值异或和，如果是 $0$ 那么我们就认为答案是 $-1$。

然后我们进行二分答案，查询一下 $[l, mid]$，如果异或和不是 $0$ 就在 $[l, mid]$ 往下做，否则 $[mid + 1, r]$ 的异或和一定不是 $0$，在 $[mid + 1, r]$ 往下做。

这个可以主席树维护。我们可以直接在主席树上二分。时间复杂度 $\Theta((n + m) \log n)$。

注：关于这个随机的错误率，可以证明若随机整数为 int 内，单次询问的错误率为 $2^{-28}$ 左右，若换为 long long 内随机，则错误率更小。

[link](https://codeforces.com/contest/1479/submission/172408762)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16703369.html</id>
    <title type="text">Dilworth 定理-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-17T11:11:00Z</published>
    <updated>2022-09-17T11:11:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16703369.html" />
    <content type="text">由于东西比较多就搬出来。

在偏序集中，最小链覆盖等于最长反链。

| 名词 |  解释 |
| ---- | ---- |
| 链 | $D$ 中的一个子集 $C$ 满足 $C$ 是全序集及 $C$ 中所有元素都可以比较大小 |
| 反链 | $D$ 中的一个子集 $B$ 满足 $B$ 中任意非空子集都不是全序集，即所有元素之间都不可以比较大小 |
| 链覆盖 | 若干个链的并集为 $D$，且两两之间交集为 $\varnothing$ |
| 反链覆盖 | 若干个反链的并集为 $D$，且两两之间交集为 $\varnothing$ |
| 最长链 | 所有链中元素个数最多的 (可以有多个) |
| 最长反链 | 所有反链中元素个数最多的 (可以有多个） |
| 偏序集高度 | 最长链的元素个数 |
| 偏序集宽度 | 最长反链中的元素个数 |

$$
最小链覆盖 = 最长反链长度 = 偏序集宽度
$$

$$
最小反链覆盖=最长链长度=偏序集深度
$$

在偏序集形成 DAG 中，任意两个在链中的元素，一定可以从某一个点到达另外一个点。

任意两个在反链中的元素，互相都不能到达。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16707337.html</id>
    <title type="text">二进制与谢尔宾斯基三角-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-19T04:25:00Z</published>
    <updated>2022-09-19T04:25:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16707337.html" />
    <content type="text">## P7970 [KSN2021] Binary Sea</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16715228.html</id>
    <title type="text">类 Dijkstra-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-21T05:00:00Z</published>
    <updated>2022-09-21T05:00:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16715228.html" />
    <content type="text">让我们先重温一下 Dijkstra（以下简称 dij）的最短路算法思路。

虽然叫做单源最短路，但是我理解为单汇最短路。

我们将点动态地分为两类：$S$ 为未确定最短路长度的点集，$T$ 为确定了最短路长度的点集，$S,T$ 是点全集的划分。

初始 $T$ 为那个汇点。

当 $S=\varnothing$ 时，算法终止。

设每个点真实到汇点的最短路为 $D_i$，即我们最终要求得的东西。

我们对于每一个 $S$ 中的点维护一个估价函数 $G_i$，这个函数要满足：

* $\forall i\in S,G_i\ge D_i$

* 对于 $S$ 中 $D_i$ 最小的 $i$，有 $G_i=D_i$。

算法中每次取出 $S$ 中 $G_x$ 最小的 $x$，转而加入 $T$，这个 $x$ 的 $D_x$ 就得出是 $G_i$，并更新 $S$ 中某些点的 $G_i$。

复杂度为 $O(XT+n^2)$ 或 $O(XT+n\log n)$，看是否用堆实现，其中 $X$ 为更新 $G_i$ 的总次数，$T$ 为单点更新 $G_i$ 的复杂度。

dij 最短路算法的 $G_i$ 表示 $i$ 点不经过 $S$ 中任意（当然不包括本身）点到汇点的最短路径长度。

所以说，dij 算法不止适用于最短路。

## CF605E Intergalaxy Trips

[题目链接](https://www.luogu.com.cn/problem/CF605E)

~~很老的题了，但是很新颖。~~

其实就是上面的套路，估价函数为不走 $S$ 中任意（不包括本身）点到汇点的最优策略下的期望天数。

显然 $G_i\ge D_i$。$S$ 中 $D_i$ 最小的点 $x$ 不可能经过 $S-x$ 中的点（因为期望天数更大，不如原题待一天）G_x=D_x_x=D_x$。

所以我们就可以开心地跑类 dij 辣。

若我们能 $O(1)$ 更新一个点的 $G_i$，则我们就能在 $O(XT+n^2)=O(n^2)$ 复杂度内解决问题。

对于一个 $S$ 中的点 $x$，设其能到达的 $T$ 中的点按 $D_i$ 升序排序为
$$c_1,c_2,\dots,c_k$$
路径存在的概率分别是
$$p_1,p_2,\dots,p_k$$
则 $x$ 的估价函数有等式
$$
G_x=1+\sum_{i=1}^k\left(\prod_{j&lt;i} (1-p_j)\right)p_iD_{c_i}+G_x\prod_{i=1}^k(1-p_i)
$$
意义是对于每种每条路径存在的状态，贪心选择到达的地方期望天数最小的（也可能原地待一天），由于 $D_x$ 一定比 $T$ 中的 $D$ 要大，所以只有当这天每条路都不开时才会原地待一天。

由于两边都有 $G_x$，我们式子变形
$$
G_x=\frac{ 1+\sum_{i=1}^k\left(\prod_{j&lt;i} (1-p_j)\right)p_iD_{c_i} }{1-\prod_{i=1}^k(1-p_i)}
$$
当一个 $S$ 中的点 $y$ 确定了 $D_y$ 变到 $T$ 中，有 $D_y$ 是 $T$ 中最大的，所以更新别的点的 $G_x$ 时自动排到了 $c_k$ 的后面成为 $c_{k+1}$。

当一个点新增 $c_{k+1}$ 时 $G_x$ 是可以 $O(1)$ 维护的，方法是分别维护上式的分子分母，不再赘述。

[但是我选择看代码](https://codeforc.es/contest/605/submission/172897382)

## CF1693C Keshi in Search of AmShZ

咕咕咕。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16718985.html</id>
    <title type="text">jsfuck-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-22T05:48:00Z</published>
    <updated>2022-09-22T05:48:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16718985.html" />
    <content type="text">```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-22 13:45:05
* Motto: We'll be counting stars.
*/
//#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define ll long long
string s;
ll ans=0;
vector&lt;int&gt; v;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;s;
	cout&lt;&lt;"(+(";
	reverse(s.begin(),s.end());
	ll x=1;
	for(auto i:s){
		if(i&lt;='9') ans+=x*(i-'0');
		else ans+=x*(i-'a'+10);
		x*=36;
	}
	while(ans){
		v.pb(ans%10);
		ans/=10;
	}
	reverse(v.begin(),v.end());
	bool flag=false;
	for(int i:v){
		if(flag) cout&lt;&lt;"+";
		else flag=true;
		cout&lt;&lt;"[";
		if(i==0) cout&lt;&lt;"+[]";
		else if(i==1) cout&lt;&lt;"+!+[]";
		else{
			cout&lt;&lt;"!+[]";
			For(j,2,i) cout&lt;&lt;"+!+[]";
		}
		cout&lt;&lt;"]";
	}
	cout&lt;&lt;"))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])";
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16732155.html</id>
    <title type="text">Fenwick 树状数组上二分-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-09-26T11:49:00Z</published>
    <updated>2022-09-26T11:49:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16732155.html" />
    <content type="text">~~其实应该叫倍增。~~

由于这篇文章中 $\text{lowbit}$ 估计不少，所以一律用 $low$。

## Acwing244. 谜一样的牛

&gt; 给定一个长度 $n\le 10^5$ 序列，求逆康托。
&gt;
&gt; $0\le a_i&lt;i$

若是 $\log n$ 二分，再 $\log n$ Fenwick，$O(n\log^2 n)$ 要跑 600ms，数据加强一下就过不了。

若是 $\log n$ 在线段树上二分，常数过大。

所以我们就请出了主题——**树状数组上二分**

原理是位置 $x$ 存的是**以 $x$ 为右端点长度为 $low(x)$ 区间信息**。

由于 $low(x)$ 都是 $2$ 的幂，所以就是倍增的料！

不管了，好像代码更能让你懂。

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-26 19:47:51
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
const int N=1e5+5;
int n,a[N],c[N],b[N];
inline int low(int x){ return x&amp;(-x); }
void add(int x,int y){ while(x&lt;=n) c[x]+=y,x+=low(x); }
int jump(int x){//the last pos that presum&lt;=x
	int pos=0,sum=0,np;
	Rof(i,20,0)
		if((np=pos|(1&lt;&lt;i))&lt;=n &amp;&amp; sum+c[np]&lt;=x)
			sum+=c[np],pos=np;
	return pos;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	For(i,2,n) cin&gt;&gt;a[i];
	For(i,1,n) c[i]=low(i);
	Rof(i,n,1) b[i]=jump(a[i])+1,add(b[i],-1);
	For(i,1,n) cout&lt;&lt;b[i]&lt;&lt;"\n";
return 0;}
```

## P6619 [省选联考 2020 A/B 卷] 冰火战士

~~代码和题解都贺。~~

[题解](https://dfsafdsgaksgh.blog.luogu.org/solution-p6619)

[Link](https://www.luogu.com.cn/record/87597982)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16747651.html</id>
    <title type="text">c++ typeid() 搞人实录-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-01T11:40:00Z</published>
    <updated>2022-10-01T11:40:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16747651.html" />
    <content type="text">在不同的编译环境中，`typeid().name()` 的返回值是不一样的。

比如说别人输出 `float`，而我是 `f`。

这里给一个对照表：
```text
b:bool
c:char
d:double
e:long double
f:float
i:int32_t
j:uint32_t
s:int16_t(short)
t:uint16_t(unsigned short)
x:int64_t
y:uint64_t
NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:string
St6vectorI*SaI*EE:类型为 * 的 vector
St4pairI*^E：类型分别为 * ^ 的 pair
(省流：STL 找子串)
A*_-:... 类型的长度为 * 的数组
P-:... 的指针
PK-:const ... 的指针 
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16751485.html</id>
    <title type="text">SPOJ GSS 系列杀青-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-03T14:30:00Z</published>
    <updated>2022-10-03T14:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16751485.html" />
    <content type="text">[算是题单吧](https://www.luogu.com.cn/problem/list?type=SP&amp;page=1&amp;keyword=GSS&amp;orderBy=name&amp;order=asc)

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221003223241852-1641036165.png)

~~太壮观了兄弟们，可是之前 $8$ 题难度评分都高一档的啊。~~

## GSS1

区间最大子段和板子题，用线段树随便过。

## GSS2

相同的数只算一次，我们离线询问，顺序插入数组中的值，设这个值上一次出现在 $pos$（经典套路），每次插入的时候都 $[pos+1,i]$ 区间加当前值，表示这些位置的后缀和加这么多。到了一个询问 $[l,i]$ 时等价于查询 $[l,i]$ 位置后缀和的历史最大值，用维护历史最值的线段树即可。

## GSS3

就是 GSS1 的带单点修版，同样简单。

## GSS4

区间开方区间求和板子。

势能分析一个数 $x$ 开方次数 $O(\log \log x)$，在数组上建并查集，快速跳过值为 $1$ 的位置。

## GSS5

询问左 / 右端点分别在给定范围内的最大区间和。

同 GSS1，维护区间前后缀 $\max$ 和区间内 $\max$ 然后分讨即可。

## GSS6

GSS3 的平衡树版，力挺 fhq treap！

## GSS7

GSS3 的上树 &amp; 链赋值版。

大力树剖即可，有点细节。

## GSS8

GSS6，但是不维护最大子段和，而是某个用二项式定理合并的东西，具体看题目。

力挺 fhq treap！力挺 fhq treap！力挺 fhq treap！</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16754638.html</id>
    <title type="text">hez模拟赛日记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-04T14:16:00Z</published>
    <updated>2022-10-04T14:16:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16754638.html" />
    <content type="text">[TOC]

# 一年过去了，开个hez模拟赛日记2

# 2023年9月26日

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230926211214978-1933681058.png)

## walpurgis &amp; P6344 [CCO2017] Vera 与现代艺术

将所有二进制高低位 reverse 一下，发现就是静态二维矩形加，单点查。

# 2023年9月19日

## string &amp; [ABC240Ex] Sequence of Substrings

将所有 $len\le \sqrt{2n}$ 的子串拉出来排序 DP 即可。

# 2023年9月9日

## study &amp; 「JOISC 2019 Day3」穿越时空 Bitaro 時をかけるビ太郎 (Bitaro, who Leaps through Time)

具象成二维平面上行走纵轴为时间，通过线性变换变成走路径不用时间，每个横坐标长度为 $1$ 的限制为纵坐标在一个区间内。

考虑线段树，每个横轴区间的纵轴区间：

* 有交，则这些纵轴区间等价于她们的交这一个区间。

* 无交，则经过这个横轴区间可以等效于先到一个纵坐标答案加上一个固定的值然后从固定的纵坐标出来。

push up 繁琐但不难。

复杂度单 $\log$。

（赛场上写了双 $\log$ push up 时套了线段树二分）

单 $\log$ 代码咕咕咕。

# 2023年9月7日

## lovely &amp; [AGC003D] Anticube

## road &amp; [ABC108D] All Your Paths are Different Lengths

## shingen &amp; CF1827F Copium Permutation

# 2023年9月5日

## c &amp; CF1860F Evaluate RBS

## d &amp; P5812 [IOI2019] 天桥

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230906084916350-998188787.png)

红蓝柱分别为起终点所在柱。

在最优路径中，一定不会离开再回到红柱，否则这部分路径直接在红柱上走更优，同理于蓝柱。

所以我们可以将原图按上方图片的方式裂开成三部分子地图，子地图之间的边的端点只有菱形点。

我们对每个子地图保留一些边使得菱形点之间的最短路是真实值即可，跑 dijkstra 即可大功告成。

结论是设每个天桥（若天桥分属于多个子地图，需要切分天桥）的两端为关键点，求出每个关键点所在柱下方第一个交点（可以不是关键点），这些点的诱导子图满足上述要求。接下来我们尝试证明（只需要关注于任意一子地图证明即可）。

先列举一些性质：

* A：每个菱形点所在柱不存在从其头顶飞过的天桥。
* B：对任意紫色菱形点，不存在天桥使得其左端点在菱形点的左边且其右端点在菱形点的右边。（性质 A 在紫色菱形点上的加强）
* C：紫色菱形点是其柱的最低交点。
* D：棕色菱形点一定是关键点，虽然粉黄绿三色边均不属于任意子地图。
* E：棕色菱形点所在柱其上方没有非关键点。

不妨设起点菱形横坐标小于终点菱形（等于情况平凡），假设之间的最短路经过了不在诱导子图里的边。

F：最短路径经过的横边（下文边均指极小的边，即边中间没有别的交点）一定是从左往右经过的。

反证法：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230906132041592-1270385535.png)

👆注意此证明的后两种 cases 需要用到性质 A。

后续性质 F 会一直隐性用到。

不在诱导子图里的边等价于上端点为非关键节点的竖边。

我们将这类边按（从起点到终点）经过的方向分为两类：上行边和下行边。

我们证明一定可以调整至不存在上行边（同时不增加下行边），那由对称性可以调整至不存在下行边：

找到从起点开始路过的第一个上行边 $x$，记该上行边上端点（为非关键节点）所在天桥为 $y$。

若之前路径路过了 $y$：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230906093839161-1075299624.png)

红色路径更优得出此路径非最短路，矛盾。

否则之前没路过了 $y$：

由性质 B、E，$y$ 的左端点不可能在起点的左边，所以我们可以有如下调整：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230906132151875-1585825431.png)

满足：

* 长度不长于原路径。
* 不增加下行边。
* 删除 $x$。
* 不改变除了 $x$ 的上行边。
* 增加的上行边的均在 $x$ 的左边。

所以经过有限步，不存在上行边。

证毕，完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

然后就被 cxy 爆了，考虑如下的证明方式：

从高至低遍历所有天桥，如果存在从其下方但不是端点处进出这条天桥，则我们可以调整：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230906132815274-1965520894.png)

唯一的问题是起点/终点在其下方的那些天桥，所以我们切分这些天桥即可。

# 2023年8月29日

## ak &amp; UOJ809.【UNR #7】那些你不要的

将位置 $\equiv 1\pmod k$ 的值拿出来，相当于两人轮流取走一个，最后剩下的即为答案。

即求中位数（较大），排序 or nth_element。

## king &amp; CF436E Cardboard Box

&gt; ![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230829181648332-1826143102.png)

但是我感觉就是这道啊（虽然代价和价值反了）。

以下解答针对 CF436E Cardboard Box。

&gt; 「茴」有四种写法，这道题有五种解法。

以下做法复杂度均为单 $\log$。

* * *

做法一：

将关卡按 $b_i$ 升序排序。如果有一个零星关卡在两星关卡左边，将两星转在零星关卡上必然更优。

所以枚举第一个零星的位置 $x+1$，将 $i\in [1,x]$ 的 $b_i-a_i$ 和 $i\in [x+1,n]$ 的 $a_i$ 取前 $w-x$ 小之和。

改变 $x$ 的时候维护这个集合，然后用线段树上二分查前 $w-x$ 小之和。

代码不写了。

* * *

做法二：

将做法一的线段树二分改为对顶堆，由于 $w-x$ 变化量、集合改变次数都是 $O(n)$ 的，所以复杂度有保证。

[Code](https://codeforces.com/contest/436/submission/220948485)

* * *

做法三：

首先有一个显然的错误解法：初始将所有 $a_i$ 压入优先队列，然后每次弹出优先队列中最小的值，如果它是一星的话就将 $b_i-a_i$ 压入优先队列。

改进：开两个优先队列，每次取【两个关卡各增加一星】和【一个关卡增加两星】的较小代价。（注意仍然只取一个，只是比较的时候用两个比较）

这样是对的，但是不会证明其正确性。

[Code](https://codeforces.com/contest/436/submission/172021095)

* * *

做法四：

反悔贪心。

我们考虑怎么从选 $i$ 颗星的方案拓展得到选 $i+1$ 颗星的方案，有以下四种方式：

* 零星 $\to$ 一星
* 一星 $\to$ 两星
* 一关 一星 $\to$ 零星，另一关 零星 $\to$ 两星
* 一关 两星 $\to$ 一星，另一关 零星 $\to$ 两星

需要五个堆，分别维护 $a_i,-a_i,b_i-a_i,a_i-b_i,b_i$ 的最小值。

谔谔，不写。

* * *

做法五：

考察两个关卡 $i,j$，如果 $2a_i&gt;b_i,2a_j&gt;b_j$，且最终都只拿了一星，不妨设 $a_i\le a_j$，则换成 $j$ 关零星 $i$ 关两星代价不增。

所以对于 $2a_i&gt;b_i$ 的关卡，只拿一星的至多只有一关。

而对于 $2a_i\le b_i$ 的关卡，我们完全可以拆成代价分别为 $a_i$ 和 $b_i-a_i$ 两个关（打完都只能拿一星），因为后者代价更大，我们肯定优先打前者，所以正确性保证。

枚举拆开来的关打了多少，在没拆开的关中找最优的一星即可。

[Code](https://codeforces.com/contest/436/submission/220965001)

# 2023年8月26日

## seal &amp; AT_joisc2015_f 合鍵 「JOISC 2015 Day2」Keys

# 2023年8月25日

## double &amp; CF1140G Double Tree

## permutation &amp; [AGC031D] A Sequence of Permutations

# 2023年8月24日

## journey &amp; CF685E Travelling Through the Snow Queen's Kingdom

## fert &amp; P9544 [湖北省选模拟 2023] 调和 / conduct

luogu（可能是官方？）数据太水了，我点分治没写分治中心是链头的情况直接给我过了，感谢模拟赛中 5ab 的精心数据。

首先由于三个维度之和恒定，将所有向量的第三维直接去掉变为平面，最终药剂能被表示当且仅当其在所有原材料点的凸包内（或边界）。

如果存在这样的凸包，则一定存在三个点使得三角形包含最终药剂，称这些点为关键点。

不妨整体平移将最终药剂移动到原点，将所有原材料极角排序。若三个关键点在树上不在一条链上，则取三者在树上的中心，必然能取代掉三者中的一个。

设最终答案为树上 $(u,v)$ 链，则链上除了 $u,v$ 之外的点和 $u,v$ 都可以形成三个关键点，证明考虑若不可以则可推得 $(u,v)$ 还可以缩短长度。

先判掉存在和原点重合的情况。路径问题考虑点分治，由上一段的结论，直接钦定分治中心是关键点，将分治集合内的点分为分治中心顺逆时针两个集合，同时判断分治中心是链头的情况（这种情况还要分三角形 or 分支中心的对峙点）。最后两个集合 sort 后保留极角远离分治中心深度增加的部分（其他的一定不优），然后双指针统计答案即可。

复杂度双 $\log$，将上一段最后一句话的 sort 改成关于深度的桶排即可做到单 $\log$。

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230825222205147-883672082.png)

👆随机配了点图。

[code](https://www.luogu.com.cn/record/122764932)

# 2023年8月23日

## chessboard &amp; gym103861G. Check Pattern is Bad

将 $i+j$ 为奇数位置的值反转，将问题转化为不能存在同值 $2\times 2$ 小方块。

定义 L 形为：一个 $2\times 2$ 中三个确定的值相同和一个 ?。

现在没有 L 形且没有矛盾，我们证明任意钦定一个 ?（设位置为 $S$）为某值之后不可能矛盾。

* * *

模拟赛下发的 sol 证明是假的，但是挺有启发性的，我自己证了一下，不一定没有疏漏：

原先确定的我们用黑笔写，之后确定的用红笔（包括 $S$ 位置）。

我们不断用红笔写下可以被 L 形确定的位置，当一个位置 $x$ 被一个 L 确定时，从此 L 中所有红色位置向 $x$ 连有向边。

这是一个 DAG（对于同一个初始状态，以不同的顺序确定位置可能形成不同的 DAG，不过无所谓），源点是 $S$。

我们证明除了 $S$ 不存在一个点的出度 $&gt;1$：

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230823203928557-1813200561.png)

上一个图中后两个方案最后的红色 0 的相位正好相反，不妨设不论从斜的四个方向哪个来，向左转 90 度相位 $-0.5$，向右转相位 $+0.5$。

所以从 $S$ 出发的两条链如果汇聚到两个八连通位置，则她们相位相同，得出值不同，所以不矛盾且不产生新的 L。

所以此 DAG 没有入度 $&gt;1$ 的点。

所以一定没有矛盾。

* * *

感觉证明方式与 [Matrix67 经典证明：扫雷是NP完全问题](http://www.matrix67.com/blog/archives/544) 有点类似，都是电路状物。

## paint

非常好构造题，可惜我不会。

结论是连通图必有解，那我们任意找一棵 **DFS** 有根生成树。

将点按生成树黑白染色分为两个集合 $A,B$，不妨设 $|A|\le |B|$。

咕.

# 2023年8月22日

## hard &amp; CF603B Moodular Arithmetic

## extreme &amp; CF1603C Extreme Extension

## fraud &amp; CF1608D Dominoes

## easy &amp; [ARC154E] Reverse and Inversion

# 2023年8月18日

## car &amp; CF581E Kojiro and Furrari

## robot &amp; P9520 [JOISC 2022 Day1] 监狱

（线段树/ST表/倍增）优化建图+判断是否是DAG。

## explorer &amp; CF297E Mystic Carvings

# 2023年8月17日

## milky

出题人被爆标了！！！

设 $B=\text{'milky'}$，这里有 $O((n+q)|B|^2)$ 做法。

首先处理出文本串每个前缀 $B$ 的每个子串作为子序列的出现次数，可以 $O(n|B|^2)$。

$(L,R,x)$ 的询问表示文本串中 $[L,R]$ 子串中 $B$ 的长度为 $x$ 的后缀作为子序列的出现次数，题目要求 $(L,R,|B|)$。

通过预处理的前缀答案两者相减得到初始答案，还需要减掉跨过 $L$ 之前缝隙的不合法方案。枚举 $B$ 中跨越的断点，$L$ 之前的位置我们已经预处理出来了，之后转化为新的 $(L,R,x)$ 子问题，复杂度 $O(q|B|^2)$。

## gaze &amp; P3616 富金森林公园

## path

# 2023年8月16日

# 2023年8月15日

*********************************

# 2023年8月14日

## up &amp; CF889E Mod Mod Mod

## family &amp; CF413E Maze 2D

## ll &amp; P4799 [CEOI2015 Day2] 世界冰球锦标赛

## izumi &amp; CF799F Beautiful fountains rows

# 2023年8月12日

## game

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230821181549032-1098500544.png)

## color &amp; CF297D Color the Carpet

# 2023年8月10日

## diary

打表找规律 $q(n)=2^{\text{popcount(n)}}-1$，然后简单数位 DP。

## brotherhood &amp; CF177G2 Fibonacci Strings

## camera &amp; CF542B Duck Hunt

# 2023年8月9日

## lock &amp; [ABC249G] Xor Cards

$C_i=2^{30}B_i+A_i$，然后将 $C$ 全部插入线性基。

从 $59$ 位到 $30$ 位判断答案 $w$ 这一位能不能是 $1$，判断方法如下：

新建一个空线性基，将原线性基里所在位 $&lt;w$ 的所有值与上 $2^{30}-1$ 后丢入新线性基。最后判断新线性基能否表示出 $\le K$ 的值。

复杂度 $O(n\log V+\log^3V)$。

## magic &amp; P5319 [BJOI2019] 奥术神杖

将权值取对数，变为模式串权值加权平均数。

01分数规划，DP 两维分别是匹配到哪一位，在 ACAM 哪个节点。

复杂度 $O(nm|\Sigma|\log_2\frac{\ln V}{\epsilon})$。

# 2023年8月8日

## temple &amp; gym103957J. Dome and Steles

## duel

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230809100725371-158296766.png)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230809100727108-971859867.png)

# 2023年8月7日

## pr

两组 $n$ 个 $[0,m]\cap\mathbb Z$ 之和相等 $\iff n$ 个 $[0,m]\cap\mathbb Z$ 与 $n$ 个 $[-m,0]\cap\mathbb Z$ 总和为 $0 \iff 2n$ 个 $[0,m]\cap\mathbb Z$ 总和为 $nm$。

然后就是简单容斥状物了，最后是
$$
\sum_{i=0}^{2n}(-1)^i\binom{2n}{i}\binom{2n-1+nm-i(m+1)}{2n-1}
$$
## pali

将三个串顺次拼接，之后 $O(n^2)$ 区间 DP 即可（细节超多 e.g. 跨串）。

i.e. $f_{i,j}$ 表示从外向内左边位置 $i$ 右边位置 $j$ 的回文方案数。

我的做法基于枚举回文中心在哪个串然后散列表+hash，复杂度相同但被卡常。

# 2023年8月5日

## ddickky &amp; P9060 [Ynoi2002] Goedel Machine

## chameleon &amp; P8048 [COCI2015-2016#4] ENDOR

## tree &amp; CF1276D Tree Elimination

## lihua &amp; P7937 [COCI2007-2008#5] BAZA

# 2023年7月20日

## stone &amp; [ABC256G] Black and White Stones

## count &amp; [AGC015C] Nuske vs Phantom Thnook

## merge &amp; P7215 [JOISC2020] 首都

## lcm &amp; P5366 [SNOI2017] 遗失的答案

# 2023年7月19日

## notlong &amp; [ARC104D] Multiset Mean

## statement &amp; CF833C Ever-Hungry Krakozyabra

位数 $K=18$，答案很小 $\le \binom{K+9}{9}$，每个答案暴力判即可，复杂度 $O(K\binom{K+9}{9})$。

## set &amp; P5871 [SEERC2018] Inversion

# 2023年7月18日

## quencese &amp; [ABC243G] Sqrt

枚举两次操作后的值，$O(X^{1/4})$。

## trolcon &amp; QOJ4193. Joined Sessions

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718085615738-818338437.png)

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718085626522-834320086.png)

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718105147475-1435173591.png)

三个合并操作足够：

首先如果支配集能减小，则初始大小 $\ge 2$。找到两个位置相邻的支配集内的区间，一定可以至多三次合并将两个区间合并。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718103737151-1367661637.png)

$j$ 只有和 $cont(j)$ 合并才是有意义的：

设 $j,k$ 合并，不失一般性 $j$ 的右端点不小于 $k$ 的右端点。

如果合并后是支配集中的元素，则 $k$ 必然最优取 $cont(j)$ 使合并后区间最长。

否则，设合并后被区间 $i$ 支配，则改为 $i,j$ 合并一定不劣。

## doog &amp; QOJ6504. Flower's Land 2

题意：维护一个 012 串 $s$，支持区间加 $1$ 模 $3$，或区间询问能否通过删除两个相邻相等元素删成空串。

构造三个随机可逆矩阵（$2\times 2$ 足够）（模大素数）$M_0,M_1,M_2$。

设
$$
A_i=\begin{cases}
M_{s_i}&amp; 2\mid i
\\
M_{s_i}^{-1}&amp;\text{Otherwise.}
\end{cases}
$$
一个区间可以消空 $\implies\prod_{i=l}^r A_i=E$。

用线段树维护区间矩阵乘积。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230712213241772-1599269847.png)

↑官方题解贴的图，不知道讲了啥

[code](https://qoj.ac/submission/123566)

遗留问题：

这样做正确性咋样？

使用更大的矩阵正确性更高吗？

存不存在矩阵构造使得正确率 $100\%$？

可不可以将 012 串加强到 0123 串或者更多？

# 2023年7月18日

## math &amp; nowcoder11254 E Math &amp; 1988 IMO T6

[nowcoder](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=48263952)

别再在 T1 出 IMO 了！

利用韦达跳跃可以发现，如果 $x^2+y^2=k(xy+1)$，其中 $x&lt;y$，则 $(x,kx−y)$ 也是一组解并且字典序更小 $^*$。因此初解一定形如 $(x,x^3)$，然后倒推。

$^*$：$x^2+y^2=kxy+k$，将 $y$ 设为主元用韦达定理得
$$
\begin{cases}
y_1+y_2=kx
\\
y_1y_2=x^2-k
\end{cases}
$$
若 $x&lt;y_1$，则得 $y_2=kx-y_1=\frac{x^2-k}{y_1}&lt;y_1$，所以 $(x,kx−y)$ 是字典序更小的一组解。

* * *

解不多（每个 $k$ 倒推都是指数级别的），将解求出来 sort，每次询问 lower_bound 即可。

## interval &amp; nowcoder11253 G League of Legends

[nowcoder](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=48194539&amp;headNav=acm)

若区间满足两两不包含（即左右端点都单调）是好做的，每组必定选取区间序列的一段子段，这样可以 DP，优化可至 $O(nk)$。

然后考虑包含别的区间的区间（称为大区间，之前的称为小区间），最优方案中若其不单独一组，则必然和其包含的区间在同一组。将大区间按长度排序，DP 后求出小区间形成了 $i$ 组的最大贡献，然后把前 $k-i$ 大的大区间分别单独一组即可。

## tree

设 $f_{x,i}$ 表示子树 $x$，来自外部的加操作的总和是 $i$，子树内部还需要的最小次数。

发现 $f_{x,*}$ 的取值至多只有两种，因为这些都可以通过一步作用在 $x$ 的 2 操作相互转换。

进一步 $f_{x,*}$ 取值不同的段个数是 $O(sz_x)$ 的，启发式合并即可，复杂度双 $\log$。

# 2023年7月15日

## delete

放在 T1 的牛题。

$n\le 20$ 时暴力枚举删除的点集，复杂度 $O(m2^n)$。

否则建出生成树，状压 DP 可做到 $O(m2^{m-n})$。

## slim &amp; CF1098D Eels

对于一个固定的鱼群状态，让危险攻击次数最多的方案一定是不断次小的吃最小的。

所以一条鱼不会危险攻击别人当且仅当其值 $&gt;2\times$ 小于其值的值之和。

发现这玩意是倍增状物，考虑将值域倍增分块 $[2^0,2^1),[2^1,2^2),\dots,[2^{29},2^{30})$。

容易证明只有每个块内的最小值才会有可能不危险攻击。

每个块开 multiset 统计即可，复杂度线性对数。

## marchseventh

根号题一眼秒，但是没过（这整场都咕了）就是不会。

## overwhelmed &amp; CF1672G Cross Xor

这道原题不是那么原，因为改编过了。

首先我们考虑将从某个点的某个方向出发回到这个点的路径必然是一个环，于是整个网格可以被看成若
干个环。

考虑将环看成点，环之间的交点也就是拼图看成边，那么整个网格就是一张无向图。容易发现环上拼图
的坐标和奇偶性相同，且奇偶性相同的环必然存在交点，不相同的环必然不存在交点，于是整张图就可
以被分为两个独立的无向完全图。

于是现在的操作就变为，选择一条边，将所有与这条边的某个端点相连的边反转。

现在我们考虑对某张图合法的条件。首先容易发现对一个环上所有边操作一次可以反转所有环上的边而
其它边不变，然后按照点数的奇偶性讨论：
* 点数为偶数。此时操作 $(x,y)$ 后，将所有 $k$ 满足 $k\ne x$ 且 $k\ne y$ 反转 $x,y,k$ 这个环，即可实现
单独反转 $(x,y)$ 这条边。也就是说点数为偶数时必然合法。
* 点数为奇数。此时考虑只保留开着的边，那么操作不可能改变点的度数的奇偶性，所以点的度数必
然得全是偶数。由于在点的度数均为偶数时必然存在欧拉回路，此时方案必然合法。也就是说点数
为奇数时点的度数必须都为偶数。

那么对于点数为偶数的情况直接处理，现在只需要考虑点数为奇数的情况。

考虑对所有不确定的边跑出一棵生成树。此时生成树外的边随意确定，必然可以用生成树内的边调整至
合法，那么用并查集统计生成树外的边数即可。

# 2023年7月14日

## de &amp; P8421 [THUPC2022 决赛] rsraogps &amp; P9335 [Ynoi2001] 雪に咲く花

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// Problem: Luogu P8421 [THUPC2022 决赛] rsraogps
// Url: https://www.luogu.com.cn/problem/P8421
// T/M Limit: 3000ms 512MB
// Time: 2023-07-14 12:07:05
// Author: ShaoJia

// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
#define int uint
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
const int N=1000010,M=5000010;
int n,m,a[N],b[N],c[N],ans[M],base[N],del[N];
vector&lt;pi&gt; e[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	rep(i,1,n) cin&gt;&gt;a[i];
	rep(i,1,n) cin&gt;&gt;b[i];
	rep(i,1,n) cin&gt;&gt;c[i];
	int x,y,z;
	rep(i,1,m){
		cin&gt;&gt;x&gt;&gt;y;
		e[y].pb(x,i);
	}
	rep(i,1,n){
		z=i-1;
		y=i-1;
		while(y){
			x=a[y]&amp;a[y+1];
			if(x==a[y]) break;
			a[y--]=x;
		}
		ckmn(z,y);
		y=i-1;
		while(y){
			x=b[y]|b[y+1];
			if(x==b[y]) break;
			b[y--]=x;
		}
		ckmn(z,y);
		y=i-1;
		while(y){
			x=__gcd(c[y],c[y+1]);
			if(x==c[y]) break;
			c[y--]=x;
		}
		ckmn(z,y);
		rep(j,z+1,i-1){
			base[j]+=del[j]*(i-1);
			del[j]=a[j]*b[j]*c[j];
			base[j]-=del[j]*(i-1);
		}
		del[i]=a[i]*b[i]*c[i];
		base[i]=(1-i)*a[i]*b[i]*c[i];
		for(auto j:e[i]){
			x=0;
			rep(k,j.fir,i) x+=base[k]+del[k]*i;
			ans[j.sec]=x;
		}
	}
	rep(i,1,m) cout&lt;&lt;ans[i]&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

[vector](https://www.luogu.com.cn/record/115434121)

[桶排](https://www.luogu.com.cn/record/115434522)

# 2023年7月13日

## shopping &amp; P6282 [USACO20OPEN] Cereal S

简单 dfs 题。

## game &amp; [ARC127E] Priority Queue

简单 DP 题。

## draw &amp; P6237 [CEOI2012] Printed Circuit Board

不简单计算几何题。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230716172734583-2123818185.png)

维护旋转扫描线，用类似 CF223D Spider 的 set + 传全局变量的 cmp 做法维护线段与扫描线交点到原点距离的大小关系，依次判断每个点是否在所有线段之下即可。

这里扫描线传给 cmp 可以用相邻两个极角（红色射线）向量的和。因为糖水原理 $\frac{a}{b}&lt;\frac{a+c}{b+d}&lt;\frac{c}{d}$，斜率在两者之间。

当然也可以使用李超线段树，沿用普通李超线段树的分析方法（两条线仍然只有一个交点，每次下传一个儿子），复杂度相同。

# 2023年7月8日

一场四个原题，boring，不写了。

# 2023年7月7日

## permutation &amp; CF313E Ilya and Two Numbers



## survey &amp; [ARC159D] LIS 2

线段树优化 DP，不多说了。

## mime

将树上问题平摊到序列上，问题转化成二维平面（$x$ 轴为区间，$y$ 轴为树的节点）一行的区间加（以下称为行加），矩形求和。

加上 $3$ 操作，考虑遍历时间分支树，变为行加、行减、矩形求和。

按时间 CDQ 分治，问题变为先操作后询问，这样将矩形差分成下边重合于 $x$ 轴的两个矩形，可以用平行于 $x$ 轴的扫描线做。

复杂度双 $\log$，空间线性。

# 2023年7月6日

## NOI-square

$xy$ 为平方数当且仅当 $x,y$ 消除平方因子后相同。

我们称一个数的颜色为其消除平方因子后的数。

接下来均在值域 $[1,m]$ 中考虑。

如果我们处理出 $G(k)$ 表示长度为 $k$ 的颜色相同序列有多少个，则通过卷积优化 DP + 二项式反演可以 $O(n^2\log)$ 得出答案。

接下来求 $G(k)$。

所有属于同一种颜色的数中最小的数就是颜色本身，所以颜色为 $i$ 的数的个数为 $\lfloor \sqrt{m/i}\rfloor$。
$$
G(k)=\sum_{i=1}^m\mu^2(i)\lfloor \sqrt{m/i}\rfloor^k
$$
整除分块 + 求 $\mu^2(i)$ 的前缀和，复杂度 $O(n^2\log + n\sqrt m+m^{3/4})$。

如何求 $\mu^2(i)$ 的前缀和：

由于
$$
\mu^2(n)=\sum_{d^2|n}\mu(d)
$$
将两边同求前缀和：
$$
\sum_{i=1}^n\mu^2(i)=\sum_{i=1}^{\lfloor\sqrt n\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor
$$
当然预处理出 $\mu(\cdot)$ 后这个式子可以整除分块达到 $O(n^{1/3})$ 的复杂度，以至于本题 $O(m^{3/5})$，但是没啥必要。

## NOIP-boring

以下 $n,q,a_i$ 均不区分。

将素数存在性压入 bitset（若可能出现多个，则在 bitset 上占多个位置）。

莫队求出所有区间的 bitset 并记录。

每次询问将涉及的 bitset 或起来，求乘积即可。

这样是 $O(n\sqrt n+\frac{n^2}{\log})$ 的（因为素数个数为 $n/\log$）。

改成手写 bitset，对于每相邻 $16$ 位，对于每种 $2^{16}$ 情况算出这些素数的乘积，这样就是 $O(n\sqrt n+\frac{n^2}{\log^2})$ 的。

# 2023年7月4日

## fib

$$
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^n\gcd(f(i),f(j))\\
=&amp;\sum_{i=1}^n\sum_{j=1}^nf(\gcd(i,j))\\
=&amp;\sum_{d=1}^nf(d)\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor n/d\rfloor}[\gcd(i,j)=1]\\
=&amp;\sum_{d=1}^nf(d)(2\sum_{i=1}^{\lfloor n/d\rfloor}\varphi(i)-1)\\
\end{aligned}
$$

采用杜教筛欧拉函数前缀和，对 $\lfloor n/d\rfloor$ 整除分块，这样复杂度是 $O(n^{2/3})$ 的。[为什么记忆化的整出分块套杜教筛的复杂度是这样的。](https://www.cnblogs.com/CDOI-24374/p/15998234.html)

# 2023年6月24日

## string

[核心部分详见](https://www.cnblogs.com/shaojia/p/17533201.html)

# 2023年5月30日

## disc

$O(2^{n/2})&lt;O(3^{n/3})$ 啊啊啊！因为这个被卡常了。

而且我多一个 log。减少的方法（口胡的）是：meet in middle 两边分别建 trie，然后从高到低每一位求答案（细节自行脑补）。

## galacticparagons

原题 [gym104064B. Boredom Buster](https://codeforces.com/gym/104064/problem/B)

期望不超过 $\frac{11}{12}n+O(1)$ 次询问的做法。

将 $n$ 个位置两两配对，分别询问（$\frac{n}{2}$ 次询问），颜色相同的配对直接做完了。

接下来将不同颜色的配对看作颜色之间的无向边，易得此图 $\max deg\le 2$。

维护这张图的不同类型连通块（孤立点不管）：

* L(oop)：长度 $\ge 3$ 的环。

* P(ath)：长度 $\ge 2$ 的链。

* D(ual)：二元环。

* E(dge)：单条边。

同时我们有如下操作（字母代表形状）：

* V：对于任意三个不同点 $x\leftrightarrow y\leftrightarrow z$，一次询问两条边各一个位置，接下来四种情况发生概率相同：
	* 断 $x\leftrightarrow y$。
	* 断 $y\leftrightarrow z$。
	* 两个都断。
	* 两个都并加上一条 $x\leftrightarrow z$。
* II：对于任意四个不同点 $x\leftrightarrow y,x'\leftrightarrow y'$，一次询问两条边各一个位置，将会发生：两条边都断并加上 $\{x,y\}\times \{x',y'\}$（笛卡尔积）四条边中的一条（等概率）。
* O：对于任意两个不同点 $x\Leftrightarrow y$（两条边），每次询问两条边各一个位置，将会有一半的概率不变，一半的概率两条边全消除，所以消除的期望询问次数 $E=2$。
* I：对于任意两个不同点 $x\leftrightarrow y$，并找到一个确定了值为 $x$ 的位置 $i$，每次询问这条边中一个位置和 $i$，有一半概率消除，一半概率不变，$E=2$。

![](https://img2023.cnblogs.com/blog/2213867/202306/2213867-20230603125701868-311803435.png)
（V 操作的 figure）

先不断用 V 操作将 L 消成【P 或 D】和若干 E，再用 V 操作**从 P 的端点**不断消 P 至若干 E。

这一步期望步数不超过 $\frac{1}{3}n$。（总共 $\frac{1}{2}n$ 条边，每次从一端等概率解决 $1$ 条或 $2$ 条）

将 D 两两配对（每一对有 $4$ 个点），做两次 II 得到两个 E 或一个 D 或一个边数为 $2$ 的 P，不断做直到只剩 E 和至多一个 D。

将仅剩的 D 做 O 操作。

将 E 两两配对做 II，得到一个 E。

若最后还剩一个 E，做 I 操作。

这里期望步数不超过 $cnt+O(1)$，其中 $cnt$ 为期望 $\frac{1}{3}n$ 次询问后留下来的 D 和 E 个数的总和，期望不超过 $\frac{1}{12}n$。

总次数 $\frac{1}{2}n+\frac{1}{3}n+\frac{1}{12}n+O(1)=\frac{11}{12}n+O(1)$。

[代码（蕴含 grader）](https://codeforces.com/gym/104064/submission/208242406) 细节比较多，调了一天整。

CF / qoj 数据都比较水，一个地方写错（虽然单次出错概率 $1/16$ 不知道算不算小） $100$ 组数据都过了。

## poison

原题：[[BalticOI 2020 Day1] 混合调料](https://www.luogu.com.cn/problem/P6683)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530225625717-828981507.png)

wn 拉过来的时候数据都没改。

# 2023年5月17日

## Ron &amp; gym103428K Tiny Stars

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230517154520004-905169464.png)

## Harry

摆。

## Hermione &amp; gym103439D LIS Counting

考虑修改常规的 $O(n\log n)$ 求 LIS 的方法（$h_i$ 表示目前长度为 $i$ 的上升子序列末尾最小值）。

每次加入一个数，找到第一个不小于她的 $h_i$ 后覆盖此位置，改为每个位置开一个自顶向下的栈，覆盖改为栈顶压入此数。

回到原问题。设 $f_i(1\le i\le nm)$ 为原排列 $i$ 位置为结尾的 LIS 长度。由于整个排列的 LDS 长度为 $m$，所以相同值 $f_i$ 的个数 $\le m$（否则，这些位置将组成长度 $&gt;m$ 的下降子序列）。由于 LIS 长度为 $n$，鸽巢原理，得到每种 $f_i$ 的个数均为正好 $m$。

所以我们修改后的求 LIS 方法最后会形成一个 $n$ 列 $m$ 行的矩阵。

考察这个矩阵的性质，以下“过程”指的是从全部空栈到矩阵加入值的过程。

（一）每一列的值从上往下值不增（由于是排列，所以等价于单减）。

（二）过程中任意时刻从左往右每个栈顶的值不降（空栈栈顶算 $\inf$）。

前两条根据最初的 LIS 算法显然。

（三）每一行的值从左往右值不降（由于是排列，所以等价于单增）。

反证法，设有一个位置值为 $x$，其同一行左侧有一个值为 $y(y&gt;x)$。$y$ 加入时，显然此时 $x$ 还没加进来（否则 $y$ 肯定压入 $x$ 右边的某个栈）。所以 $x$ 在 $y$ 之后加入，将 $y$ 这一列 $y$ 到栈底（栈底在上面）的数接上 $x$ 这一列 $x$ 到栈顶（栈顶在从上到下第 $m$ 行）的数，就构成了长度为 $m+1$ 的下降子序列，矛盾。

（四）过程中任意时刻所有栈形成一个左上角的杨表。

和（三）的证明差不多，都是构造一个长度为 $m+1$ 的下降子序列矛盾。

（一）+（三）等价于（五）：若按值从小到大插入矩阵，每个时刻都是个左下角的杨表。

（二）可以由 （四）+（五）得出。

然后发现（四）+（五）就是充要条件了，也就是说每一种位置的杨表过程和数值的杨表过程对应着一种合法的序列。

而位置和值是独立的，所以可以用乘法原理。

设 $F(t,x,y)$ 表示位置的杨表过程中第 $t$ 个加的位置为 $(x,y)$ 的方案数。

设 $G(t,x,y)$ 表示数值的杨表过程中第 $t$ 个加的位置为 $(x,y)$ 的方案数。

则最后的答案（题目所求）
$$
f(a,b)=\sum_{1\le x\le m}\sum_{1\le y\le n}F(a,x,y)G(b,x,y)
$$
$F(t,x,y)=G(t,m+1-x,y),G(\cdot)$ 可以 DP 求出。由于合法的杨表数量
$$
\binom{n+m}{n}\le\binom{20}{10}=184756
$$
所以时间复杂度是有保证的。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// Problem: Codeforces - XXII Open Cup, Grand Prix of Southeastern Europe D. LIS Counting
// Url: https://codeforces.com/gym/103439/problem/D
// T/M Limit: 2000ms 256MB
// Time: 2023-05-17 19:11:04
// Author: ShaoJia

#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
int P;
struct mod_int{
	using Z=mod_int;
	static signed mo(signed x){return x&lt;0?x+P:x;}
	signed x;
	signed val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;signed&gt;(x_):mo(static_cast&lt;signed&gt;(x_%P))){}
	bool operator==(const Z&amp;rhs)const{return x==rhs.x;}
	bool operator!=(const Z&amp;rhs)const{return x!=rhs.x;}
	Z operator-()const{return Z(x?P-x:0);}
	Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&amp;1)res*=t;if(k&gt;&gt;=1)t*=t;}return res;}
	Z&amp;operator++(){x&lt;P-1?++x:x=0;return *this;}
	Z&amp;operator--(){x?--x:x=P-1;return *this;}
	Z operator++(signed){Z ret=x;x&lt;P-1?++x:x=0;return ret;}
	Z operator--(signed){Z ret=x;x?--x:x=P-1;return ret;}
	Z inv()const{assert(x);return pow(P-2);}
	Z&amp;operator+=(const Z&amp;rhs){(x+=rhs.x)&gt;=P&amp;&amp;(x-=P);return *this;}
	Z&amp;operator-=(const Z&amp;rhs){(x-=rhs.x)&lt;0&amp;&amp;(x+=P);return *this;}
	Z&amp;operator*=(const Z&amp;rhs){x=1ULL*x*rhs.x%P;return *this;}
	Z&amp;operator/=(const Z&amp;rhs){return *this*=rhs.inv();}
#define setO(o) friend Z operator o(const Z&amp;lhs,const Z&amp;rhs){Z res=lhs;return res o##=rhs;}
	setO(+)setO(-)setO(*)setO(/)
#undef setO
	friend istream&amp; operator&gt;&gt;(istream&amp;is,Z&amp;x){long long y;is&gt;&gt;y;x=Z(y);return is;}
	friend ostream&amp; operator&lt;&lt;(ostream&amp;os,const Z&amp;x){return os&lt;&lt;x.val();}
};
using Z=mod_int;
const int N=104,M=185000;
typedef bitset&lt;101&gt; bt;// 左下杨表，0 下 1 右，0 m个 1 n个 从左上角走，低位先执行
int n,m,tot=0,lim,sz[M],id[N][N][N];
bt s[M],rv[M],tmp;
Z F[N][N][N];// t:[1,n*m] i:[1,m] j:[1,n]
Z f[M];// 方案数
unordered_map&lt;bt,int&gt; o;
void dfs(int x,int y,int sum){
	if(x==m &amp;&amp; y==n){
		o[tmp]=++tot;
		s[tot]=tmp;
		sz[tot]=sum;
		return ;
	}
	if(x&gt;m || y&gt;n) return ;
	dfs(x+1,y,sum+y);
	tmp.set(x+y);
	dfs(x,y+1,sum);
	tmp.reset(x+y);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;P;
	lim=n+m;
	Z val;
	dfs(0,0,0);
	rep(i,1,tot) rep(j,0,lim-1) rv[i][j]=s[i][lim-1-j];
	f[1]=1;
	rep(i,1,tot-1){
		rep(j,0,lim-2) if(!s[i][j] &amp;&amp; s[i][j+1]){
			tmp=s[i];
			tmp.set(j);
			tmp.reset(j+1);
			f[o[tmp]]+=f[i];
		}
	}
	int x,y,z;
	rep(i,1,tot-1){
		x=y=1;
		rep(j,0,lim-2){
			if(!s[i][j] &amp;&amp; s[i][j+1]){
				tmp=s[i];
				tmp.set(j);
				tmp.reset(j+1);
				z=o[tmp];
				F[sz[z]][x][y]+=f[i]*f[o[rv[z]]];
			}
			if(s[i][j]) y++;
			else x++;
		}
	}
	rep(i,1,n*m) rep(j,1,n*m){
		val=0;
		rep(ii,1,m) rep(jj,1,n) val+=F[i][ii][jj]*F[j][m+1-ii][jj]; 
		cout&lt;&lt;val&lt;&lt;" \n"[j==j_];
	}
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

# 2023年4月19日

## dl &amp; AT_joisc2015_f 合鍵 「JOISC 2015 Day2」Keys

## a

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230826135536095-140069093.png)

我的另一种做法。

每个数 $x$ 随机一个 $2\times 2$ 定义在模素数意义下的矩阵 $M_x$。

判断对于所有的数 $x$ 是否有 $\sum_{a\oplus(b\oplus c)=x}M_aM_bM_c=\sum_{(a\oplus b)\oplus c=x}M_aM_bM_c$。

与官方做法异曲同工，都是通过一种方法规定三者的顺序。

# 2022年11月15日

## kings(duel)

鸡尾酒排序题。

重要性质：01 串的一次鸡尾酒排序等价于找到第一个 1 和最后一个 0，如果 1 在 0 之前则 swap。

证明：考虑 01 串一次冒泡排序等价于删去第一个 1 并加到末尾，反冒泡为删去最后一个 0 并加到开头，两者叠加即可。

将原序列扫值域线，小于的视为 0，大于等于的视为 1，对每种值域线的答案求和就是原问题的答案。

设 $a^{(k)}$ 为原序列鸡尾酒操作 $k$ 次后的序列，即有 $a^{(0)}=a$。

先将询问差分成前缀查询，对于一个询问 $(r,k)$，答案为
$$
\sum_{i=1}^ra^{(k)}_i=\sum_{v=1}^n\sum_{i=1}^r[a^{(k)}_i\ge v]
$$

考虑用提到的性质解决 swap $k$ 次的事情，若 $v&gt;r$，则当 $k$ 足够大的时候前 $r$ 项全是 $0$，反过来若 $v\le r$，则当 $k$ 足够大的时候后 $n-r$ 项全是 $1$，换句话说就是每次操作会让 $r$ 前缀 1 个数少 $1$，直到某一边顶满了。

所以式子变成
$$
\begin{aligned}
&amp;\sum_{v=1}^r\max\left(\sum_{i=1}^r[a_i\ge v]-k,r-v+1\right)
\\+&amp;\sum_{v=r+1}^n\max\left(\sum_{i=1}^r[a_i\ge v]-k,0\right)
\end{aligned}
$$
先把暴力写出来，理一下就可以线段树维护了。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))

const int N=500010;
int n,m,a[N],lz[N&lt;&lt;2],mx[N&lt;&lt;2],mn[N&lt;&lt;2];
ll sum[N&lt;&lt;2],ans[N];
vector&lt;tuple&lt;int,int,int&gt;&gt; v[N];// k,id,coe
#define mid ((l+r)&gt;&gt;1)
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
void pup(int rt){
	sum[rt]=sum[ls]+sum[rs];
	mx[rt]=max(mx[ls],mx[rs]);
	mn[rt]=min(mn[ls],mn[rs]);
}
void tag(int rt,int l,int r,int val){
	sum[rt]+=1ll*val*(r-l+1);
	mn[rt]+=val;
	mx[rt]+=val;
	lz[rt]+=val;
}
void pd(int rt,int l,int r){
	if(lz[rt]){
		tag(ls,l,mid,lz[rt]);
		tag(rs,mid+1,r,lz[rt]);
		lz[rt]=0;
	}
}
void build(int rt,int l,int r){
	lz[rt]=0;
	if(l==r){
		sum[rt]=mn[rt]=mx[rt]=0;
		return ;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	pup(rt);
}
void add(int rt,int l,int r,int x,int y,int val){
	if(x&lt;=l &amp;&amp; r&lt;=y){
		tag(rt,l,r,val);
		return ;
	}
	pd(rt,l,r);
	if(x&lt;=mid) add(ls,l,mid,x,y,val);
	if(y&gt;mid) add(rs,mid+1,r,x,y,val);
	pup(rt);
}
ll que(int rt,int l,int r,int x,int y){
	if(x&lt;=l &amp;&amp; r&lt;=y) return sum[rt];
	pd(rt,l,r);
	ll res=0;
	if(x&lt;=mid) res+=que(ls,l,mid,x,y);
	if(y&gt;mid) res+=que(rs,mid+1,r,x,y);
	return res;
}
ll queA(int rt,int l,int r,int x,int y,int val){// 单调不升，求 &gt;val 的(值-val)的和
	if(mx[rt]&lt;=val) return 0;
	if(x&lt;=l &amp;&amp; r&lt;=y &amp;&amp; mn[rt]&gt;val) return sum[rt]-1ll*(r-l+1)*val;
	pd(rt,l,r);
	ll res=0;
	if(x&lt;=mid) res+=queA(ls,l,mid,x,y,val);
	if(y&gt;mid) res+=queA(rs,mid+1,r,x,y,val);
	return res;
}
ll queB(int rt,int l,int r,int x,int y,int val){// 单调不降，求 &lt;val 的(val-值)的和
	if(mn[rt]&gt;=val) return 0;
	if(x&lt;=l &amp;&amp; r&lt;=y &amp;&amp; mx[rt]&lt;val) return 1ll*(r-l+1)*val-sum[rt];
	pd(rt,l,r);
	ll res=0;
	if(x&lt;=mid) res+=queB(ls,l,mid,x,y,val);
	if(y&gt;mid) res+=queB(rs,mid+1,r,x,y,val);
	return res;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	rep(i,1,n) cin&gt;&gt;a[i];
	rep(i,1,m){
		int k,l,r;
		cin&gt;&gt;k&gt;&gt;l&gt;&gt;r;
		v[r].eb(k,i,1);
		if(l-1) v[l-1].eb(k,i,-1);
	}
	build(1,1,n);
	rep(i,1,n){
		add(1,1,n,1,a[i],1);
		for(auto[k,id,coe]:v[i]){
			ans[id]+=coe*que(1,1,n,1,i);
		}
	}
	build(1,1,n);
	rep(i,1,n){
		add(1,1,n,1,a[i],1);
		for(auto[k,id,coe]:v[i]){
			ans[id]+=coe*((i&lt;n?queA(1,1,n,i+1,n,k):0)-1ll*i*k);
		}
	}
	build(1,1,n);
	per(i,n,1){
		for(auto[k,id,coe]:v[i]){
			ans[id]+=coe*queB(1,1,n,1,i,k);
		}
		if(a[i]&lt;n) add(1,1,n,a[i]+1,n,1);
	}
	rep(i,1,m) cout&lt;&lt;ans[i]&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

# 2022年11月14日

~~别问我为啥这么长时间没记了。~~

## tree

原题 [AGC014D] Black and White Tree

## bracket

原题 CF508E Arthur and Brackets

## plague

原题 P2389 电脑班的裁员 其实应该是这个 U19030 信息组的裁员（这个是加强版）

# 2022年10月18日

## crazy

&gt; 我是汉谟拉比，我要在这立法典。

$n=10^3,m=5\times 10^3,O(nm\sqrt m)$ 我艹过去了，0.8s/1s，数据脚造的？还是说评测机 $3\times 10^8$ 1s 能过？

OJ 上也能过，0.8s。

shz &amp; 正解是 $O(nm\log m)$，用了调和计数。

代码不难，但是我不想补。

## path

考场上以为卡倍增的空间，写了树剖心态很炸，总归是过了。

结果正解是倍增，cxy 倍增空间 200+MB/256MB 很卡啊。

其实可以用长剖做到时空不带 $\log$。

# 2022年10月17日

## cookie &amp; gym103808C Comiendo

不说了，自己想出来了。

[Code](https://codeforces.com/gym/103808/submission/176696801)

## dnspring &amp; arc111_f Do you like query problems?

注意和原题模数不一样。

设 $all=\frac{n(n+1)}{2}$，表示总区间数。

我们将原问题转化为：有一个 $b_{1\sim n,1\sim m-1}$ 的二维 $01$ 矩阵，$b_{i,j}=[a_i\ge j]$，初始全为 $0$。

每次操作：

1. 将每一个 $i\in$ 某个区间的 $b_{i,*}$ 某个长度的前缀赋值为 $1$。

2. 将每一个 $i\in$ 某个区间的 $b_{i,*}$ 某个长度的后缀赋值为 $0$。

3. 查询 $i\in$ 某个区间的 $b_{i,*}$ 的和，加入最终答案中。

↑上面总共 $(2m+1)all$ 种操作都是等概率的。

由于 $E(\sum X_i)=\sum E(X_i)$，所以我们对于每个位置 $b_{i,j}$，去统计 $q$ 次操作后对答案的贡献，加起来即为答案。

位置 $b_{i,j}$ 在 $q$ 次操作后对答案的贡献为：
$$
\sum_{p=0}^{q-1}\frac{ca}{a+b}(1-(1-a-b)^p)\quad(*)
$$
表示枚举第 $p$ 次操作为 3 操作时这个位置 $b_{i,j}$ 为 $1$ 的概率，求和。

其中 $a$ 为单次操作 $b_{i,j}$ 赋值为 $1$ 的概率（1 操作前缀盖过此位置），即
$$
a=\frac{i(n+1-i)}{all}\frac{m-j}{2m+1}
$$
对偶地，$b$ 为 $b_{i,j}$ 赋值为 $0$ 的概率（2 操作后缀盖过此位置），即
$$
b=\frac{i(n+1-i)}{all}\frac{j}{2m+1}
$$
$c$ 表示当前操作查询到了 $b_{i,j}$ 的概率，即
$$
c=\frac{i(n+1-i)}{all}\frac{1}{2m+1}
$$
所以 $(*)$ 式子的意思是：

* 首先这次要查询到 $b_{i,j}$，乘上 $c$。

* 在这次询问前至少要有一次 1/2 操作，乘上 $(1-(1-a-b)^p)$。

* 上一次 1 or 2 操作中有 $\frac{a}{a+b}$ 的概率是赋值为 $1$，$\frac{b}{a+b}$ 的概率是赋值为 $0$。

我们最终的答案即为
$$
\sum_{i=1}^n\sum_{j=1}^{m-1}\sum_{p=0}^{q-1}\frac{ca}{a+b}(1-(1-a-b)^p)
$$
接下来就是 dirty work 了，先设
$$
t=a+b=\frac{i(n+1-i)}{all}\frac{m}{2m+1}
$$
这样就与 $j$ 无关了。
$$
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^{m-1}\sum_{p=0}^{q-1}\frac{ca}{a+b}(1-(1-a-b)^p)
\\=&amp;
\sum_{i=1}^n\frac{c}{t}\sum_{j=1}^{m-1}a\sum_{p=0}^{q-1}(1-(1-t)^p)
\\=&amp;
\sum_{i=1}^n\frac{c}{t}\left(q-\frac{1-(1-t)^q}{t}\right)\sum_{j=1}^{m-1}a
\\=&amp;
\sum_{i=1}^n\frac{c}{t}\left(q-\frac{1-(1-t)^q}{t}\right)\frac{i(n+1-i)}{all(2m+1)}\sum_{j=1}^{m-1}j
\\=&amp;
\sum_{i=1}^n\left(q-\frac{1-(1-t)^q}{t}\right)\frac{cm(m-1)i(n+1-i)}{2t(2m+1)all}
\end{aligned}
$$
就可以愉快地线性 $\log$ 复杂度过了。

[代码有点丑](https://atcoder.jp/contests/arc111/submissions/35746896)

## relic &amp; CF756E Byteland coins

[题解自己看吧](https://www.luogu.com.cn/blog/sysblogs/solution-cf756e)

注意他的代码写得很丑啊，0.9s/1s 高精写的有点太封装了。

[还是看我的代码吧](https://codeforces.com/contest/756/submission/176968683)

# 2022年10月10日

## travel

### Upd 2023年10月10日

补了一个单 $\log$（甚至是树状数组）的做法。
$$
\begin{aligned}
f_i&amp;=h_i+\max_{j=i}^{i+t_i}(f_j-d\cdot \lfloor\frac{j-i}{k}\rfloor)
\\
f_i&amp;=h_i+\max_{j=i}^{i+t_i}(f_j-d(\lfloor\frac{j}{k}\rfloor-\lfloor\frac{i}{k}\rfloor-[j\% k&lt;i\% k]))
\\
f_i-d\lfloor\frac{i}{k}\rfloor
&amp;=h_i+\max_{j=i}^{i+t_i}(f_j-d\lfloor\frac{j}{k}\rfloor+d[j\% k&lt;i\% k])
\\
g_i&amp;:=f_i-d\lfloor\frac{i}{k}\rfloor
\\
g_i&amp;=h_i+\max_{j=i}^{i+t_i}(g_j+d[j\% k&lt;i\% k])
\\
g_i&amp;=h_i+\max\left\{\max_{j=i}^{i+t_i}g_j\ ,\ \max_{j=m\lfloor\frac{i}{m}\rfloor+m}^{i+t_i}[j\% k&lt;i\% k](g_j+d)\right\}
\end{aligned}
$$
前者 $\max$ 可以用树状数组求得。

后者对于每个 $\lfloor\frac{i}{k}\rfloor$ 相等的块，其所有 $g_i$ 求得后，每个前缀 $\max$ 分别存到 $k$ 个树状数组中（下标均为 $\lfloor\frac{i}{k}\rfloor$），查询时分为整块和由于 $i+t_i$ 限制的散块，分别都是一次树状数组查询。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
struct Qis{
	FILE *I;char B[65536],*p1=B,*p2=B;
	char gc(){return p1==p2&amp;&amp;(p2=(p1=B)+fread(B,1,65536,I),p1==p2)?EOF:*p1++;}
	Qis(FILE *I_):I(I_){}
	template&lt;typename T&gt;void read(T &amp;x){x=0;T f=1;char ch=' ';for(;!isdigit(ch);f=ch=='-'?-1:1,ch=gc());for(;isdigit(ch);x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=gc());x*=f;}
	template&lt;typename T&gt;Qis&amp; operator&gt;&gt;(T&amp; x){read(x);return *this;}
	Qis&amp;operator&gt;&gt;(char&amp; x){x=' ';for(;x&lt;=' ';)x=gc();return *this;}
	Qis&amp;operator&gt;&gt;(char *x){char c=' ';for(;c&lt;=' ';c=gc());for(;c&gt;' ';*(x++)=c,c=gc());*x=0;return *this;}
	Qis&amp;operator&gt;&gt;(string &amp;x){x="";char c=' ';for(;c&lt;=' ';c=gc());for(;c&gt;' ';x+=c,c=gc());return *this;}
}qin(stdin);
struct Qos{
	FILE *O;char B[65536],*p=B;
	void pc(char x){p-B&lt;65536?*p++=x:(fwrite(B,p-B,1,O),p=B,*p++=x);}
	void flush(){fwrite(B,p-B,1,O);}
	Qos(FILE *O_):O(O_){} ~Qos(){flush();}
	template&lt;typename T&gt;void write(T x){if(x&lt;0){pc('-');if(x&lt;-9)write(-(x/10));pc(48-x%10);}else{if(x&gt;9)write(x/10);pc(48+x%10);}}
	template&lt;typename T&gt;Qos&amp; operator&lt;&lt;(T x){write(x);return *this;}
	Qos&amp;operator&lt;&lt;(const char x){pc(x);return *this;}
	Qos&amp;operator&lt;&lt;(const char *x){for(int i=0;x[i];++i)pc(x[i]);return *this;}
	Qos&amp;operator&lt;&lt;(const string x){for(char c:x)pc(c);return *this;}
}qout(stdout);

const int N=2000010;
const ll inf=1e18;
struct fen{
	int n;
	vector&lt;ll&gt; c;
	void init(int nn){
		n=nn;
		c.resize(n+1);
		fill(all(c),-inf);
	}
	void add(int x,ll y){
		while(x&lt;=n){
			ckmx(c[x],y);
			x+=x&amp;(-x);
		}
	}
	ll que(int x){
		ll y=-inf;
		while(x){
			ckmx(y,c[x]);
			x&amp;=x-1;
		}
		return y;
	}
}c,b[N];
int n,m,t[N];
ll d,h[N],f[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
#define cin qin
#define cout qout
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;
	rep(i,1,n) cin&gt;&gt;h[i];
	rep(i,1,n-1) cin&gt;&gt;t[i],t[i]+=i;
	f[n]=h[n]-n/m*d;
	c.init(n);
	int id=n/m;
	rep(i,0,m-1) b[i].init(id);
	per(i,n,1){
		if(i!=n){
			ll tmp=c.que(t[i]);
			if(i%m){
				id=t[i]/m;
				if(id) ckmx(tmp,b[i%m-1].que(id-1));
				ckmx(tmp,b[min(i%m-1,t[i]%m)].que(id));
				// rep(j,1,i) if(j%m&lt;i%m) ckmx(tmp,-inf+d);
				// rep(j,i+1,t[i]) if(j%m&lt;i%m) ckmx(tmp,f[j]+d);
			}
			f[i]=tmp+h[i];
		}
		c.add(i,f[i]);
		if(i%m==0){
			ll x=-inf;
			id=i/m;
			rep(j,i,min(n,i+m-1)){
				ckmx(x,f[j]);
				b[j-i].add(id,x+d);
			}
		}
	}
	ll out=0;
	rep(i,1,n){
		ll ans=f[i]+i/m*d;
		out^=ans+i;
	}
	cout&lt;&lt;out&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

### 以前

继官方题解中不被卡常数的树套树和被卡的线段树，这里提供一种好想好写但是时间不优的 CDQ 解法。

（欢迎爆踩这种做法）

发现下取整不好做，我们转化
$$
\left\lfloor\frac{j-i}{k}\right\rfloor=\frac{j-i}{k}-\frac{(j-i)\bmod k}{k}=-\frac{i}{k}+\frac{j}{k}-\frac{j\bmod k-i\bmod k}{k}+[j\bmod k&lt;i\bmod k]
$$
然后设 $f_i$ 表示开始时在 $i$ 点跳跃直至 $n$ 点的最小代价，则有
$$
\begin{cases}
f_i=h_i&amp; i=n
\\
f_i=h_i+\max_{j=i+1}^{i+T_i}\left(f_j+d\lfloor\frac{j-i}{k}\rfloor\right)&amp;i&lt;n
\end{cases}
$$
然后应用上面的转化
$$
f_i=h_i+\frac{1}{k}\left\{d\cdot i+\max_{j=i+1}^{i+T_i}(w_j+d(-i\bmod k+[j\bmod k&lt;i\bmod k]k)\right\}
$$

其中
$$
w_j=k\cdot f_j-d\cdot j+d(j\bmod k)
$$
发现我们把 $\frac{1}{k}$ 提到前面来了：

* 好消息：不用小数运算考虑精度问题了。

* 坏消息：毒瘤出题人强迫我们开 `__int128`（但是好像数据太水了 `long long` 能过）。

然后我们就可以愉快地 CDQ 分治了。

具体地，我们求完了 $(mid,r]$ 范围的 $f$ 值，计算此范围对 $[l,mid]$ 内 $f$ 值的贡献（$\text{checkmax}$）。

将 $[l,mid]$ 的 $i+T_i\in(mid,r]\cap\mathbb Z$ 询问挂在 $(mid,r]$ 对应节点上（相当于离线），这样每一个询问都是 $(mid,r]$ 的一个前缀，扫描并按时处理询问即可。

扫描的时候将 $w_j$ 存入（$\text{checkmax}$）下标 $j\bmod k$，开一个线段树或两个树状数组，然后查询时按 $[j\bmod k&lt;i\bmod k]$ 分类一下查询前 / 后缀最大值。

复杂度小常数 $O(n\log^2n)$。

&lt;details&gt;
&lt;summary&gt;代码太丑了还是别看了吧&lt;/summary&gt;

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-10-10 14:06:46
* Motto: We'll be counting stars.
*/
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define debug(...) cerr&lt;&lt;"#"&lt;&lt;__LINE__&lt;&lt;": "&lt;&lt;__VA_ARGS__&lt;&lt;endl
#define For(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
#define lob lower_bound
#define upb upper_bound
#define fir first
#define sec second
#define mkp make_pair
#define mkt make_tuple
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ll long long
#define pi pair&lt;int,int&gt;
#define Fi(s) freopen(s,"r",stdin)
#define Fo(s) freopen(s,"w",stdout)
#define Fre(s) Fi(s".in"),Fo(s".out")
#define int ll
#define lll ll
const int N=2000005;
char buf[1&lt;&lt;21],*p1,*p2;
#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=gc();}
	while(c&gt;='0'&amp;&amp;c&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);c=gc();}
	return x*f;
}
//why int128__ !!! 出题人值域这么大干啥
lll inf;
inline void ckmx(lll&amp; x,const lll&amp; y){ if(x&lt;y) x=y; }
inline int low(int x){ return x&amp;(-x); }
lll f[N],h[N],w[N],p[N],s[N];
int ran[N],n,k,d,tot,out[N];
pi q[N];
int used[N],ut=0;
#define ls (rt&lt;&lt;1)
#define rs (rt&lt;&lt;1|1)
inline void insert(int j,lll val){
	used[++ut]=j;
	for(int i=j+1;i&lt;=k;i+=low(i)){
		ckmx(p[i],val);
	}
	for(int i=k-j;i&lt;=k;i+=low(i)){
		ckmx(s[i],val);
	}
}
inline lll qpre(int x){
	x++;
	lll res=-inf;
	while(x){
		ckmx(res,p[x]);
		x^=low(x);
	}
	return res;
}
inline lll qsuf(int x){
	x=k-x;
	lll res=-inf;
	while(x){
		ckmx(res,s[x]);
		x^=low(x);
	}
	return res;
}
inline lll query(int i){//max(w[j]+(j-i)%k*d) j'=j%k , i'=i%k
	//j'&gt;=i' : max(w[j]+j'*d)        {-i'*d}
	//j'&lt; i' : max(w[j]+j'*d)+k*d    {-i'*d}
	lll ans=qsuf(i);
	if(i&gt;0) ckmx(ans,qpre(i-1)+k*d);
	return ans;
}
inline void clear(){
	int x;
	while(ut){
		x=used[ut--];
		for(int i=x+1;i&lt;=k;i+=low(i)){
			p[i]=-inf;
		}
		for(int i=k-x;i&lt;=k;i+=low(i)){
			s[i]=-inf;
		}
	}
}
void work(int l,int r){
	if(l==r){
		if(l==n) out[l]=h[l];
		else out[l]=(f[l]+l*d)/k+h[l];
		w[l]=k*out[l]-l*d;
		return ;
	}
	int mid=(l+r)&gt;&gt;1;
	work(mid+1,r);
	tot=0;
	For(i,l,mid) q[++tot]=mkp(min(r,ran[i]),i);
	sort(q+1,q+1+tot);
	int pos=mid;
	For(i,1,tot){
		while(pos&lt;q[i].fir){
			pos++;
			insert(pos%k,w[pos]+pos%k*d);
		}
		ckmx(f[q[i].sec],query(q[i].sec%k)-(q[i].sec%k)*d);
	}
	clear();
	work(l,mid);
}
signed main(){
	// Fre("travel");
	inf=((lll)1)&lt;&lt;62;
	n=read(),k=read(),d=read();
	For(i,1,k) p[i]=s[i]=-inf;
	For(i,1,n) h[i]=read();
	For(i,1,n-1) ran[i]=read()+i;
	For(i,1,n) f[i]=-inf;
	work(1,n);
	int ans=0;
	For(i,1,n) ans^=out[i]+i;
	cout&lt;&lt;ans&lt;&lt;"\n";
	// For(i,1,n) cout&lt;&lt;f[i]&lt;&lt;" "; cout&lt;&lt;"\n";
return 0;}
```
&lt;/details&gt;

# 2022年10月4日

生日快乐！今天我这个大 shaber 15 周岁了，从这个时间节点开始记录模拟赛吧！

焯我是鸽子，已经鸽了一周了。

模拟赛原题的话一般会标上原题。

场切的一般不记。

口胡的一般只放代码，也可能不放。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16810966.html</id>
    <title type="text">stream-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-20T11:14:00Z</published>
    <updated>2022-10-20T11:14:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16810966.html" />
    <content type="text">```cpp
template&lt;int P&gt;
struct mod_int{
	using Z=mod_int;
	static int mo(int x){return x&lt;0?x+P:x;}
	int x;
	int val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;int&gt;(x_):mo(static_cast&lt;int&gt;(x_%P))){}
	//...
	friend istream&amp; operator&gt;&gt;(istream&amp;is,Z&amp;x){long long y;is&gt;&gt;y;x=Z(y);return is;}
	friend ostream&amp; operator&lt;&lt;(ostream&amp;os,const Z&amp;x){return os&lt;&lt;x.val();}
};
const int P=119&lt;&lt;23|1;
using Z=mod_int&lt;P&gt;;
```

```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
signed main(){
	ios::sync_with_stdio(false);
	ifstream fin("in.txt");
	ofstream fout("out.txt");
	fstream fio("io.txt");
	fin.tie(&amp;fout);
	int x;
	fin&gt;&gt;x;	fout&lt;&lt;x;
	fio&gt;&gt;x;	fio&lt;&lt;x;
return 0;}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16814984.html</id>
    <title type="text">Beta 和 Gamma 函数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-21T14:27:00Z</published>
    <updated>2022-10-21T14:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16814984.html" />
    <content type="text"># Gamma 函数

其中一个定义差不多长这样：
$$
\Gamma(x)=\int_{0}^{+\infty}t^{x-1}e^{-t}dt
$$
不过有更重要的东西（**阶乘函数的延拓**）：
$$
\Gamma(n)=(n-1)!\quad(n\in\mathbb{N}^+)
$$

# Beta 函数

当你做概率题时看到这样的积分
$$
\int_0^1x^n(1-x)^mdx
$$
不要慌，大半是 Beta 函数。
$$
B(n+1,m+1)=\int_0^1x^n(1-x)^mdx
$$
她咋求呢？我们有如下优美的公式
$$
B(x,y)=\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
$$
这是为什么呢？~~小编也很疑惑。~~

接下来给出一个 $x,y\in\mathbb{N}^+$ 的证明。

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221021223731803-156471806.png)

假设向长度为 $1$ 的桌子上扔一个红球（如上图），设位置为 $x(\in[0,1])$

再向桌上扔 $n$ 个白球，那么每个白球落在红球左边的概率为 $x$，假设落在红球左边的白球数量为 $k$。

我们设 $K$ 为 $k$ 的离散随机变量，那么有
$$
P(K=k|x)=\binom{n}{k}x^k(1−x)^(n−k)
$$
设 $X$ 为红球位置 $x$ 的连续随机变量，服从 $[0,1]$ 上的均匀分布。

$K$ 对于每个 $x$ 都有上式的分布，所以
$$
\begin{aligned}
P(K=k)&amp;=\int_0^1\binom{n}{k}x^k(1−x)^{n−k}dx
\\&amp;=\binom{n}{k}\int_0^1x^k(1−x)^{n−k}dx
\end{aligned}
$$
现在换种与上述等价的方式来丢球：

&gt; 先将这 $n+1$ 个球都丢出来，再选择一个球作为红球。

任何一个球被选中的概率均为 $\frac{1}{n+1}$，此时红球左边有 $0,1,\dots,n$ 个球的概率均为 $\frac{1}{n+1}$，有
$$
P(K=k)=\frac{1}{n+1}
$$
得
$$
\binom{n}{k}\int_0^1x^k(1−x)^{n−k}dx=\frac{1}{n+1}
$$
稍加变形得到了最终证明的式子
$$
B(k+1,n-k+1)=\frac{\Gamma(k+1)\Gamma(n-k+1)}{\Gamma(n+2)}
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16817141.html</id>
    <title type="text">2022 贺题解记录（下下）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-22T11:42:00Z</published>
    <updated>2022-10-22T11:42:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16817141.html" />
    <content type="text">[TOC]

# CF1772F Copy of a Copy of a Copy

考虑其单调性（可以看作是熵？）每次操作后这个位置就不可能再次被操作了，我们按能操作的位置个数排序就得到了顺序，然后由于保证了可行，我们直接暴力做就行。

# [ABC246Ex] 01? Queries

矩阵优化 DP 不难，主要是统计本质不同的子序列个数的 DP 难搞。

具体见题解区。

# [ABC280G] Do Use Hexagon Grid 2

![](https://img2023.cnblogs.com/blog/2213867/202212/2213867-20221210130517994-629727109.png)

六边形格子之间两坐标的差设为 $X,Y$，则两个格子之间最短距离为 $\max(|X|,|Y|,|X-Y|)$。

然后原问题就转化为每个点 $(X,Y)\to (X,Y,X-Y)$，三维空间中计数非空点集使得任意两点切比雪夫距离 $\le D$。

切比雪夫的条件等价于这个点集能被 $D\times D\times D$ 的立方体框住。

两重循环枚举 $X,Y$ 坐标的最小值，最大值上限为最小值 $+D$，排序，用双指针扫描 $Z$ 轴，再套一个 $X,Y$ 两维的容斥即可。

复杂度 $O(n^3\log n)$。

[Code](https://atcoder.jp/contests/abc280/submissions/37123408)

# CF1773H Hot and Cold

我们先问 $(0,0)\to (1,1)\to (0,0)$，两次如果回答相同则必然是 same dis，然后判 $(0,1),(1,0)$ 即可。

否则，我们就知道了哪个句子是 far 哪个是 close，就不存在语言的问题了。

每一轮我们问现在未确定的区域的中心 $(x,y)\to (x+1,y)\to (x+1,y+1)$，这样范围就缩小到了原来的 $1/4$。

总次数 $3+3\log_210^6$。

# P6772 [NOI2020] 美食家

拆边的话点数太多了，矩阵乘法寄了，我们可以拆点。

$k$ 可以不用乘在 $n^3\log$ 上面，通过合理的预处理可以乘在 $n^2\log$ 上。

# P1117 [NOI2016] 优秀的拆分

经典技巧：多次循环的子串统计可用循环节长度为间隔的撒点后求 LCS / LCP 来解决，这样撒点个数是调和线性的。

# P8860 动态图连通性

贺 from wsyear。

考虑将询问离线，给每个询问的边按照询问的顺序从小到大赋值上边权。原问题等价于找到一条从 $1$ 到 $n$ 的路径，满足字典序最小。此处字典序的定义为：

* 将经过的边表示为一个 01 串，若一条边被经过，则她的边权的位置为 $1$，否则为 $0$。例如共 $6$ 条边，经过了 $5,1,4$ 三条边，则该 01 串表示为 $100110$。

那么若一条询问的边在该路径上被经过，那么就不会被删除，否则会被删除。这样的路径得出的答案正确性显然，因为一条边被经过，那么删除她后图一定不存在 $1$ 到 $n$ 的路径（若存在，字典序最小的要求必然使她为 $0$）。

发现这条路径类似于最短路，考虑用 dijkstra 算法求出这条路径。由于经过一条边后只会有 $1$ 条边的经过情况会发生改变，故考虑用可持久化线段树维护到达一个点的字典序最小的路径上所经过的点。更新答案只要主席树上单点修改即可。

问题在于如何比较两条路径的字典序大小。考虑主席树维护区间 01 串的哈希值，然后在线段树上二分找出第一个值不一样的位置，这一位小的则字典序更小。

剩下的部分就是普通的 dijkstra。

复杂度应该是双 $\log$ 的。

[record](https://www.luogu.com.cn/record/95225993)

# CF547D Mike and Fish

非常启发性的题！

## 题意

给定 $n$ 个整点，你要给每个点染成红色或蓝色，要求同一水平线或垂直线上两种颜色的数量最多相差 $1$。

$1\le n,x_i,y_i\le 2\times 10^5$

这道题好在：找到转换要求的方式不简单。

## 欧拉回路解法

发现同一行的点在 $y$ 轴上投影重合，同一列的点在 $x$ 轴上投影重合。

所以考虑将点看成连接其横坐标和纵坐标的边，我们为每一条边定向, 使得每一个点的入度与出度的差的绝对值不超过 $1$。

绝妙的转化！然后将 deg 为奇数的点再与一个新的点连边，这样图必然有欧拉回路，求出来即可。

[Code](https://codeforces.com/contest/547/submission/181206412)

## 二分图染色解法

两种颜色的数量尽量相等？考虑两个两个匹配，匹配的两点颜色不同。

实现的话记录一下这个坐标上未匹配点（$0/1$ 个）的标号，连一下。

绝妙的转化！这样必然是二分图！然后二分图黑白染色一下即可。

为啥是二分图？因为不存在奇环。（由于一个环经过的边在平面上必然是横竖交替）

[Code](https://codeforces.com/contest/547/submission/181207066)

# [AGC014D] Black and White Tree

我来简化一下题意。

&gt; 一棵无根树，Alice Bob 轮流操作。
&gt;
&gt; 每次可以将一个没有被标记过的点标记自己名字首字母，直到不能操作。
&gt;
&gt; 如果一个 A 相邻的点均为 A，则 Alice 胜，否则 Bob 胜。
&gt;
&gt; 谁会赢？

如果接下来 Alice 操作，且存在三个相邻的点 $x,y,z$（$y$ 在中间），$x,z$ 相邻的点除了 $y$ 已经都是 A，$x,y,z$ 都没标记，则 Alice 必胜。

因为她可以标记 $y$，然后 Bob 一步不可能同时标记 $x,z$。

接下来我们推论：

&gt; Alice 胜当且仅当树上存在一个点 $y$ 使得 $y$ 至少有两个子树大小为奇数。

充分性：

假装定根 $y$，设这两个子树的根为 $x,z$。

以 $x$ 为例，$z$ 同理。若 $x$ 子树内有叶子与 $x$ 深度差 $2$，则 Alice 选择这个叶子的父亲，Bob 不得不选择这个叶子。

这样我们相当于每次删掉了两个点，子树大小仍然为奇数。

最终若 $x$ 子树内有别的点，必然是 $x$ 的儿子，且儿子数 $\ge 2$（奇偶性）。这样 Alice 选 $x$，Bob 一步不可能同时标记 $x$ 的所有儿子。

这样 $x,z$ 的子树大小都为 $1$ 了，Alice 标记 $y$，然后 Bob 就陷入了相同的困境，得证。

必要性：

不存在一个点至少有两个子树大小为奇数 等价于 这个树存在完美匹配。

读者自证。

然后 Alice 每选择一个点，Bob 就选匹配的点，Alice 赢不了。

[Code](https://atcoder.jp/contests/agc014/submissions/36487279)

# P8850 [JRKSJ R5] Jalapeno and Garlic

月赛题。

首先简单转化一下题意，每个位置有 $a_i$ 个棋子，每次操作选择一个棋子，将其随机向相邻位置移动。然后要选择一个目标点，使得期望操作次数最少。

设一个棋子在目标的顺时针 $i$ 格（也就是逆时针 $n-i$ 格）的位置，移到目标的期望次数为 $f_i$，则：
$$f_i=1+\frac 12 (f_{i-1}+f_{i+1}) \  \ (i\in[1,n-1])$$
这个线性方程组可以用常系数线性递推的方法来解：
$$F(x)=2xF(x)-x^2F(x)-\frac{2x}{1-x}+(f_1+2)x$$
$$f_i=i(f_1-i+1)$$
由于 $f_n=0$，解得 $f_i=i(n-i)$。

题目要我们求出期望最小的目标点，不妨直接把所有目标的情况，全都求出答案来。
$$s_d=\sum_{i=1}^n a_i |i-d|(n-|i-d|)$$
这里有个绝对值很烦，考虑拆为：
$$b_d=\sum_{i=1}^{d-1}a_i(d-i)(n-d+i) \ , \ c_d=\sum_{i=d+1}^na_i(i-d)(n-i+d)$$
再把和式中的乘积展开，可以得到（这里以 $b$ 为例，对 $c$ 也是类似的）：
$$b_d=-\left(\sum_{i=1}^{d-1}i^2a_i \right)+(2d-n)\left(\sum_{i=1}^{d-1}ia_i \right)+d(n-d)\left(\sum_{i=1}^{d-1}a_i\right)$$
这样维护三个前缀和即可，对于 $c$ 也就是三个后缀和，做法是一致的。时间复杂度 $\Theta(n)$。

注意值域较大，需要 int128。

# P3426 [POI2005]SZA-Template

以下 $B(S)$ 均指 $S$ 字符串的 $Border$ 集合再**加入本身长度**。

我们发现任意串 $S$ 的任意合法印章都属于 $B(S)$（对应的前缀）。

$A$ 为原串，设 $dp_i$ 表示 $A[1,i]$ 的最短印章长度。

先将 $A$ 做一遍 KMP，得到 fail 数组 $f_i$。

考察一个 $dp_i$ 如何被转移。

* 若 $\exists j\text{ s.t. }dp_{j}=dp_{f_i},j\ge i-f_i$，则 $dp_i=dp_{f_i}$。

* 否则，$dp_i=i$，直接本身为印章。

解释一下第一类，也是主要的亮点。

若 $A[1,i]$ 的最小印章不为本身，则 $A[1,i]$ 的印章长度 $\in B(A[1,f_i])$。因为得到所有 Border 可不断跳 fail。

$A[1,i]$ 的最小印章必然为 $A[1,f_i]$ 的印章（反证法，若 $A[1,f_i]$ 中有一个位置刷不到……）。

若最终答案用到了一个 $j$ 使得 $dp_{j}&lt;dp_{f_i}$ 然后并没有用最小的印章，我们证明这样必然有更优解。

$X,Y$ 是 $Z$ 的 Border，$|X|&lt;|Y|$，则 $X$ 是 $Y$ 的 Border。

所以我们有更优的解，就是 $dp_j$。

那有没有可能 $dp_{f_i}$ 长度不行而更大的长度可行呢？

若有，则我们将这个印章每次印的时候用多次 $dp_{f_i}$ 来印，这样必然可全印完。

↑ $X,Y$ 是 $Z$ 的印章，$|X|&lt;|Y|$，则 $X$ 是 $Y$ 的印章。

所以没有可能。

[代码](https://www.luogu.com.cn/record/93528136)

# CF1672E notepad.exe

orz wdssean

这道题一开始真没思路，洛谷还恶评绿。

关键思路就是二分得到一个很优的解后再 $n$ 次分别询问更优的，保证最优的在里面。

二分出所有单词能放在同一行内的最小宽度，即可得到我们当前的答案 $Ans$ 和所有单词的总长度 $L$。

然后我们枚举最终高度，记为 $x\in[1,n]$。

由于这样最多能省下 $x-1$ 个空格，所以我们这个高度的最小宽度不小于
$$
\lceil\frac{L+n-x}{x}\rceil=\lceil\frac{L+n}{x}\rceil-1
$$
而若我们将这个宽度 $+1$，则我们最终的面积为
$$
x\times\lceil\frac{L+n}{x}\rceil\ge L+n&gt;L+n-1 =Ans
$$
一定不优，所以对于每一个高度只需要 $1$ 次询问。

总询问 $\log 2000^2+n&lt;30+n$，可行。

# CF1672F1 Array Shuffling &amp; CF1672F2 Checker for Array Shuffling

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221104190933381-1384952090.png)

# CF1093G Multidimensional Queries &amp; P1648 看守

虽然不是同一道题但是是同一个思路。

$d$ 维（$d$ 不能太大）曼哈顿距离的最大值，我们有
$$|x|=\max(x,-x)$$
$$|x|+|y|=\max(+x+y,+x-y,-x+y,-x-y)$$
$$\dots$$
所以 $2^d$ 枚举哪些维度取负，另外的取正，这么多种情况取 $\max$ 即可。

[wxw 的题解](https://www.luogu.com.cn/blog/wxw/solution-cf1093g)

可惜的是，曼哈顿距离的最小值好像就不能这样做了……

[CF1093G 代码](https://codeforces.com/contest/1093/submission/177773998)

[P1648 代码](https://www.luogu.com.cn/record/91400380)

# CF1515H Phoenix and Bits

3500，ds。

tags：线段树合并、线段树分裂，但是线段树是 01trie。

题解是半贺 5ab 的~~要不要脸~~。

## 做法

对集合建立 01Trie，在每次操作前，都把值域 $[x,y]$ 的数从原 Trie 中分裂出来。这样区间操作就转化成了全局操作，每次操作完再合并进去就可以了。

对于 $\text{and}$ 操作，可以用如下步骤等效代换：

1. 对整个集合 $\text{xor}$ 上 $U=2^{20}-1$。

2. 对区间 $[x,y]\text{ or}$ 上 $U \text{ xor } z$。

3. 对整个集合 $\text{xor}$ 上 ${U}$。

所以只需要考虑 $\text{or}$ 和 $\text{xor}$ 即可。

对于后者，直接在根节点上打上一个 tag，每次下传的时候判断是否要交换左右儿子即可。

对于一个深度为 $dep$ 节点，如果 $\text{or}$ 上了一个 $2^{dep}$，则会有如下情况：

* 只有 $1$ 的儿子，啥都不用干。

* 只有 $0$ 的儿子，等价于 $\text{xor}$ 上一个 $1$。

* 既有 $0$ 也有 $1$ 的儿子，需要把左右子树合并。

如果直接暴力对于每个节点判断肯定喜提 TLE，考虑维护当前子树对应集合 $A$ 的两个指标：
$$
orz=\text{OR}_{x\in A} x
$$
（叫 orz 原因是 or 是 operator）
$$
nor=\text{OR}_{x\in A} (U\text{ xor }x)
$$
并对于每一个二进制位，根据情况分类讨论：

* 若两者这一位均为 $1$，则将这一位下传儿子递归搞。

* 只有 $orz$ 为 $1$，即子树内所有该深度的边都指向 $1$ 儿子，啥都不用干。

* 只有 $nor$ 是 $1$，即子树内所有该深度的边都指向 $0$ 儿子，$\text{xor}$ 上这一位。

注意每次给节点打标记时，要更新 $orz,nor$，具体是交换对应位（见代码）。

## 复杂度证明

势能函数定义为：

trie 节点数 $+$ 每个节点的 $\text{popcount}(orz\text{ and }nor)$ 之和

每次 $\log$ 复杂度都会让势能至少减少 $1$（~~读者自证~~）。

所以复杂度双 $\log$。

## 代码

[Code](https://codeforces.com/contest/1515/submission/177663327)

# CF1153F Serval and Bonus Problem

细微简化过的题意：

&gt; 我们称 $[0,1)$ 区间内均匀随机独立取两个点之间构成的区间为在 $[0,1)$ 范围中随机一段区间。
&gt;
&gt; 我们随机取 $n$ 段区间，求期望被至少 $k$ 段区间覆盖的长度，对 $998244353$ 取模。

## 解法 1

普通 DP $O(n^2)$ 做法。

最后答案等于再在 $[0,1)$ 中选一个点 $x$ 使得这个点被至少 $k$ 段区间覆盖的概率。

这玩意怎么求？这时，我们会发现一个显然却非常神仙的事实：我们随机出的 $(2n+1)$ 个点本身的位置并不重要，我们只要知道它们的相对位置就行了！！

所以问题就变成了这样：求有多少种点的排列方式，使得点 $x$ 在至少被 $k$ 个线段覆盖。

这玩意可以 DP，具体看代码，三个转移分别加一个左端点，加一个右端点，还有加入点 $x$。

最后再乘上排列状物即可。

[Code](https://codeforces.com/contest/1153/submission/177440450)

## 解法 2

高妙 $O(n)$ 做法。

我们直接上式子（积分选点，枚举被覆盖了几次）
$$
\begin{aligned}
&amp;\int_0^1\sum_{i=k}^n\binom{n}{i}(2x(1-x))^i(1-2x(1-x))^{n-i}dx
\\=&amp;
\sum_{i=k}^n\binom{n}{i}\int_0^1(2x(1-x))^i\sum_{j=0}^{n-i}\binom{n-i}{j}(-1)^{j}(2x(1-x))^jdx
\\=&amp;
\sum_{i=k}^n\binom{n}{i}\sum_{j=0}^{n-i}\binom{n-i}{j}(-1)^{j}2^{i+j}\int_0^1(x(1-x))^{i+j}dx
\end{aligned}
$$
后面积分换种形式
$$
\int_0^1x^{i+j}(1-x)^{i+j}dx
$$
发现是一个 [Beta 卷积](https://www.cnblogs.com/shaojia/p/16814984.html) 的形式，我们直接套公式
$$
\begin{aligned}
&amp;=\sum_{i=k}^n\binom{n}{i}\sum_{j=0}^{n-i}\binom{n-i}{j}(-1)^{j}2^{i+j}\frac{((i+j)!)^2}{(2i+2j+1)!}
\\
&amp;=\sum_{i=k}^n\sum_{j=0}^{n-i}\binom{n}{i+j}\binom{i+j}{j}(-1)^{j}2^{i+j}\frac{((i+j)!)^2}{(2i+2j+1)!}
\\
&amp;=\sum_{t=k}^n\sum_{j=0}^{t-k}\binom{n}{t}\binom{t}{j}(-1)^{j}2^t\frac{(t!)^2}{(2t+1)!}
\\
&amp;=\sum_{t=k}^n\binom{n}{t}2^t\frac{(t!)^2}{(2t+1)!}\sum_{j=0}^{t-k}\binom{t}{j}(-1)^{j}
\\
&amp;=\sum_{t=k}^n\binom{n}{t}2^t\frac{(t!)^2}{(2t+1)!}(-1)^{t-k}\binom{t-1}{k-1}
\end{aligned}
$$

所以这道题 $n$ 可以开到 $10^6$ 级别的。

[Code](https://codeforces.com/contest/1153/submission/177328523)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16836873.html</id>
    <title type="text">国内外爬视频（音频、图像、歌词、弹幕）！-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-28T09:35:00Z</published>
    <updated>2022-10-28T09:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16836873.html" />
    <content type="text">首先你得下载 python（最好是最新版的）。

至于梯子，我们有迷雾通，限流模式是免费的。

[点击即下载](https://f001.backblazeb2.com/file/geph4-dl/Geph4Releases/4.4.20/geph-windows-4.4.20-setup.exe)

然后下载的话在线的有 [fodownloader](https://fodownloader.com/) 支持哔哩哔哩、抖音、微博、微视、好看视频、全民小视频、皮皮虾、最右、梨视频、Youtube、Facebook、Twitter etc. 挺强的。

不过……清晰度真的有点逊，好像是标清 / 高清啥的（至少 bilibili 罗小黑下下来是这样的）。

在 micro store 里的 Open Video Downloader 不错，但是好像只能下载 youtube 的视频，它能设置代理端口，不错。

迷雾通的代理端口是这样的：

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221028215345820-689960969.png)

（好像上面的有点寄）

当然最后请出最万能的 you-get，用 python 的 pip3 install（cmd 中输入，要求 python 在 PATH 中）：

```text
pip3 install you-get
```

you-get 在 github 上的 [包](https://github.com/soimort/you-get/) 和 [官方中文教程](https://github.com/soimort/you-get/wiki)。

然后就可以下载很多东西了，具体见官方中文教程。

简便的下载可以在 cmd 中输入（请保证当前选在将要下载的文件夹下）：

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221028220256449-26662144.png)

要代理（如 youtube）的话类似这样写：

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221028221523919-1291270804.png)

（当然迷雾通要保持开着）

当然如果你用的 bilibili，他会把弹幕及时间也给下下来，并存入 .xml 文件中（音乐的歌词是 .lrc 同理）。

如果像罗小黑那样是一整套下载的话，可以用

![](https://img2022.cnblogs.com/blog/2213867/202210/2213867-20221028221429811-309709025.png)

（当然会员的无法下载）

很多都在官方那里说了，我就不赘述了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16843591.html</id>
    <title type="text">csp2022 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-10-31T02:56:00Z</published>
    <updated>2022-10-31T02:56:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16843591.html" />
    <content type="text">~~你被骗了，这里没有东西。~~

快开场了我才到，别人都看两题了/kk。

然后解压，密码一遍写对/jie（公示的是首字母大写，然后说其实是小写~~还好我到得晚~~）。

别人都看题了，我以为只能看 pdf 第一页的注意事项。

开场先把头文件写了，包括 freopen 和 mt19937。

然后看 T1，发现我不会做，心态小寄。

看 T2，发现比 T1 简单，写两棵线段树。

发现样例过不去，又读了题发现是 $A_i\times B_j$，我看成 $+$ 了。

心态又小只因，不过做法本质相同，稍微改一下过了。

看 T1，想了 30min 左右，发现好像求一下每个点的前 3 强路径就能保证有不重叠的，就做完了。

结果 bfs 脑抽写成 dfs，搞了好久/ll。

T3 看题面看了好久，发现就是判每个点出度是否均为 $1$。

然后想了一万年 sqrt 做法，发现 hard。

然后就去拼 T4 的 $k=1,2$ 暴力，写了一个 DDP，样例过了。

然后发现我头文件里有一个 mt19937，没有用到，怎么回事。

好 T3 就是随机化。

先把 T4 的 $k=3,n\le 200$ 写了。

然后就 18:05 了，极限把 T3 的随机写完。

也许是 368？难说。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16858681.html</id>
    <title type="text">所以人生的意义到底是啥啊？呜呜呜-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-04T10:04:00Z</published>
    <updated>2022-11-04T10:04:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16858681.html" />
    <content type="text">由于本人不太会说话，所以采用意识流 + 叙利亚风格来诉说。大家看个乐呵。

科普地球生物生活熵增我们都是有意义的若最终目的是宇宙的熵增可是宇宙的意义又是啥呢然后一切谜团都是了

三体刘慈欣写过中给岁月以文明非给文明以岁月经典台词让我想到我们是否都在给流逝的时间意义或者说时间被赋予意义直至文明无存

那就又是一团谜时间的意义又是啥为啥需要文明而不是更多的恒星时间的终点是最终宇宙的坍缩还是丁仪说的蓝移起点也不好确定就是大爆炸

时间意义是流逝看着无停息转动的挂钟这样就更玄乎宇宙似乎意义是啥最终也是一个套娃的无解

感觉养鸡场的只因不知道被拖走后的世界是啥样的它们没有见过外面的世界原因是它们站在通向烤炉的传送带中隐形的

或许人类最终命运也不过如此但是我不想被蒙在鼓里如果最终都会到达更坏的局面倒想珍惜现在或者说在我出生前的地方更加幸福

可能无知人更加幸福和快乐吧就像黑客帝国中主角要是不去锡安就可以安详地过一生但是快乐难道就是意义吗难道多巴胺和内啡肽等化学物能承载人类意义吗我不敢苟同

那无知的人感觉是傻乐呵所以我感觉生活要多探索但是带来的不只有磨难和责任还有无力回击的痛苦可笑的是我生活中一直充斥着要努力拼搏好在以后有技能有考好大学有好工作的机会有好家庭能善终

但是这样只会让现在更痛苦如果没拼搏到那连延迟满足的快乐也没了而且如果拼搏的时候喜欢看窗外风景那成功概率减小看风景也不过是喜怒哀乐体验生活八卦吃个瓜上面说了这个无解

难道是痛苦或者就是无意义意义这个词又是啥意思或者茫茫宇宙就没有这个东西就像人类供奉的用霓虹灯制造的神像伪造出来让无知的虫子有点希望的火苗但是怎样燎原我不好说

你会发现痛苦有何意义本质上不就残害压迫一些转瞬即逝的虫子然后不知道去向何方群山在神的面前流动当然我没说有神我说上帝视角

那宇宙真的没意义我也不敢相信不过也可以接受因为存在即合理但不用有意义但是合什么理外面的世界有啥我不晓得那是不是我现在奋斗和从高楼跳下去对最终结果没有区别不对我们都没有定义最终结果本质不同指啥这个又要扯到意义了

突然想到三体人智子不能窥察人类的思想北海要多想会不会意义在想法中那就玄学了因为爱情恨愤怒都是神经元的作祟贴吧有的人说活着为了爱的人和爱的事那究竟是爱人有意义还是和爱的人之间的事有意义

但是似乎事有意义似乎也没有意义了失控玩家电影里台词说即使你我是虚假的但是此时此刻这个地点谈话室你和我在一起就是真的但是这样最终这个记忆和感情就像RAM一样死了就没了

或者说有鬼魂这个东西但是它们又有啥意义呢在这个世界观下似乎是套娃一个世界进入下一个这样都失去了意义

现在我脑中的想法和一切思想都是爬虫脑和大脑的产物我们祖先都是觅食生存繁衍直到人类拥有了智慧自称是技术爆炸智慧爆炸在我看来说不定是几亿年间一个突然的偷袭一个违背祖宗的决定

要是真的没有意义那我在这里写的也没有意义了要是没有一个答案的话我余生可能就像bot一样遵循祖宗的决定了

可是现在茫茫宇宙没有找到其他生物我说会不会从冰冷的岩石炽热的氢气放射的铀中演变出生物在宇宙的长河中也是一瞬也是一个违背祖宗非生物物质的决定呢更或者这个宇宙也是大爆炸之前的东西弄出来的异类呢

难说如果我说的是错的那我就是末影龙的罪恶龙息否则我就是一个光明使者虽然没有光明我也称不上使者</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16859342.html</id>
    <title type="text">Kruskal 重构树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-04T14:39:00Z</published>
    <updated>2022-11-04T14:39:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16859342.html" />
    <content type="text"># LOJ137. 最小瓶颈路（加强版）

# [AGC002D] Stamp Rally

# [NOI2018] 归程

# [CERC2016]机棚障碍 Hangar Hurdles

# P1967 [NOIP2013 提高组] 货车运输

# P4899 [IOI2018] werewolf 狼人

# [ARC098F] Donation

# [CF1578L] Labyrinth

# P4197 Peaks

# [CF1706E] Qpwoeirut and Vertices

# [CF1628E] Groceries in Meteor Town</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16859360.html</id>
    <title type="text">我连 LCA 都不会了呜呜呜-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-04T14:47:00Z</published>
    <updated>2022-11-04T14:47:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16859360.html" />
    <content type="text">树上 lca 二元运算具有结合律和交换律，可以说很像 $\gcd$。

多个点（同一棵树上）的 lca 为 dfs 序最小和最大的两点 lca。

点集 $a_1,\dots,a_n$ 的 lca 为
$$
\min_{i=1}^{n-1}\text{lca}(a_i,a_{i+1})
$$
这里的 $\min$ 指的是我们取 dep 最小的作为最终答案。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16870590.html</id>
    <title type="text">Border 理论杂谈-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-08T09:46:00Z</published>
    <updated>2022-11-08T09:46:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16870590.html" />
    <content type="text">
# 周期与 Border 的结构


我们定义正整数 $p$ 是串 $S$ 的周期，当且仅当 $p\le |S|$ 且 $\forall i\in [1,|S|-p],S_i=S_{i+p}$。


我们定义串 $T$ 是串 $S$ 的 border，当且仅当 $T$ 是 $S$ 的前缀且 $T$ 是 $S$ 的后缀，且 $T\neq S$。


## 周期与 border 的关系



&gt; 
&gt; 正整数 $p$ 是串 $S$ 的周期，当且仅当 $p\le |S|$ 且 $S_{1\dots (|S|-p)}$ 是 $S$ 的 border。
&gt; 
&gt; 
&gt; 


## 弱周期引理



&gt; 
&gt; 若 $p,q$ 是串 $S$ 的周期，且 $p+q\le |S|$，那么 $\gcd(p,q)$ 也是 $S$ 的周期。
&gt; 
&gt; 
&gt; 


不妨设 $p&lt;q$。


对于任意 $q&lt;i\le |S|$，有 $S_i=S_{i-q}=S_{i-q+p}$。对于任意 $q-p&lt;i\le q$，有 $S_i=S_{i+p}=S_{i-q+p}$。所以 $q-p$ 也是 $S$ 的周期，而 $(q-p)+p\le |S|$，归纳可知 $\gcd(p,q)$ 是 $S$ 的周期。


## 周期引理



&gt; 
&gt; 若 $p,q$ 是串 $S$ 的周期，且 $p+q-\gcd(p,q)\le |S|$，那么 $\gcd(p,q)$ 也是 $S$ 的周期。
&gt; 
&gt; 
&gt; 


证明略。


## 短周期结构



&gt; 
&gt; 串 $S$ 的所有长度不超过 $\frac{|S|}{2}$ 的周期，都是其最短周期的倍数。
&gt; 
&gt; 
&gt; 


这是弱周期引理的直接推论。


## Border 的等差数列结构



&gt; 
&gt; 串 $S$ 的所有 border（或周期）的长度形成了 $O(\log |S|)$ 个值域不交的等差数列。
&gt; 
&gt; 
&gt; 


首先有一个引理：若 $S_{1\dots q}$ 是 $S$ 的 border，$S_{1\dots p}$ 是 $S_{1\dots q}$ 的 border，则 $S_{1\dots p}$ 也是 $S$ 的 border。


考虑 $S$ 的所有长度 $\ge \frac{|S|}{2}$ 的 border，根据“短周期结构”，它们形成一个等差数列。设长度 $&lt;\frac{|S|}{2}$ 的 border 中，最长的一个的长度为 $l$，那么长度在 $[\frac{l}{2},l]$ 中的所有 border 构成一个等差数列。以此类推，总共会形成 $O(\log |S|)$ 个等差数列。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16872893.html</id>
    <title type="text">Manacher 马拉车回文子串算法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-09T02:54:00Z</published>
    <updated>2022-11-09T02:54:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16872893.html" />
    <content type="text">线性时空。

偶回文可以中间插入没出现过的字符来转成奇长度的。

令 $d_i$ 表示对称中心在 $i$ 位置的最大回文半径。在处理 $d_i$ 时，我们已经处理了所有 $j&lt;i$ 的值 $d_j$。

我们设现在右端点最靠右的回文串位置为 $[l,r]$，初始时 $l=0,r=−1$。在计算 $d_i$ 时，我们尽可能利用已知信息去推到新的信息。进行如下的分类讨论：

* 若 $i&gt;r$，那么就直接暴力扩展。
* 若 $i\le r$，继续分类，我们找出 $i$ 关于 $[l,r]$ 的对称位置为 $j=l+r−i$。
  * 若 $i+d_j−1&lt;r$，那么必然无法继续向两侧扩展，则 $d_i=d_j$。
  * 否则，那么先令 $d_i=r−i+1$，在暴力向右扩展。

每一次迭代计算 $r$ 只会向右移动，不会向左，因此复杂度是 $O(n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16878030.html</id>
    <title type="text">开普勒一、二定律的（非常不严谨）证明-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-10T10:35:00Z</published>
    <updated>2022-11-10T10:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16878030.html" />
    <content type="text">[3b1b](https://www.bilibili.com/video/BV1Zs411A7KJ/)

首先是一个几何题，我们最后会回收这个作为伏笔的题目：

给定一个圆（圆心为 $O$）和一个圆内的点 $P$，任取圆周上一点 $Q$，则 $P,Q$ 的中垂线必切以 $O,P$ 为两焦点的椭圆。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110184122315-971689249.png)

证明用到了将军饮马和椭圆上点到两焦点距离和不变。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110184216394-1628197058.png)

* * *

角动量守恒定律、作用在行星上的引力直接指向太阳 作为前置知识。

* * *

我们先证明开二定律。

&gt; 行星和太阳的连线在相等的时间间隔内扫过的面积相等。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110184802312-119888081.png)

在极短的时间 $\Delta t$ 中，行星的轨迹看作直线，扫过的面积看作三角形（微积分状物）。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110185120256-1520696746.png)

然后底乘高 $/2$ 算三角形面积。
$$
S_{\Delta}=\frac{1}{2} R\times |\vec{v}_{\perp}|\Delta t
=R|\vec{v}_{\perp}|\times \frac{1}{2} \Delta t
$$

由于太阳施加的引力总是指向太阳，行星质量不变，所以 $R|\vec{v}_{\perp}|$ 为不变的常数。

然后我们就证完了，因为面积和时间成正比了。

（然而历史中开二才是推出角动量守恒的经验基础）

接着看开一：

&gt; 所有行星绕太阳的轨道都是椭圆，太阳在椭圆的一个焦点上。

* * *

万有引力定律、牛顿第二定律 作为前置知识。

* * *

接下来讲的多数是我自创的 qwq。

我们将以太阳为中心，共 $2\pi$ 角度平均分为 $k$ 个扇区（其实不是扇形），每份所属角度均为 $\frac{2\pi}{k}$。

注意这里 $k\to \infty$。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110191904789-975405887.png)

用我们刚刚证明的开二，得到经过一个扇区的时间正比于这个扇区的面积，而面积又正比于 $R^2$（这里取哪个 $R$ 是无关紧要的）。

行星每走完一个扇区我们就记录一下当前的速度向量，得到的是一个序列
$$
\{\vec{v}_0,\vec{v}_1,\dots,\vec{v}_{k-1}\}
$$
循环差分一下得到新的一个序列
$$
\{\vec{w}_0,\vec{w}_1,\dots,\vec{w}_{k-1}\}
$$

由于 $\vec F=m\vec a$，我们 $\{\vec w\}$ 每一个元素在极限下必然指向太阳。

而 $|\vec w_i|=\Delta t\times |\vec a|=\Delta t\times \frac{|\vec F|}{m}$，由于 $\Delta t$ 正比于 $R^2$，而 $|\vec F|$ 由于万有引力定律正比于 $R^{-2}$，所以 $|\vec w_i|$ 均相同。

然后做一遍前缀和状物，得到速度向量：

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110192918654-1543747831.png)

（自行脑部最后一根）

（黄色是 $\{\vec w\}$，红蓝是 $\{\vec v\}$）

刚刚其实已经透露了，$\{\vec w\}$ 的角度等差，所以我们最后做出来一个正多边形，极限看作是圆。

然后我们就得到了：在轨迹中角度为 $\theta$ 的地方，速度向量为这个圆心角为 $\theta$ 对应的偏心向量，这告诉了我们这个轨道上的点的切线方向。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110193205414-499871234.png)

那么现在的问题就是：什么样的轨道满足这样的性质：

&gt; 曲线与水平方向成 $\theta$ 角的点上切线的方向，是由一个从圆内的一个特殊离心点到圆上垂直偏转 $\theta$ 度的点连成的这个矢量所给定的。

（statement 很长，好好想想）

我们将左图顺时针旋转 $\frac{\pi}{2}$。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110194508511-1277330050.png)

然后将这些速度向量逆时针旋转（中心旋转） $\frac{\pi}{2}$ 转回原来的角度。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110194529096-941857835.png)

我们证明由无数直线切成的椭圆形相似于我们轨道。

回收伏笔了属实是。

重点在于，这条中垂线切于椭圆的点正好是交于半径的那个点（因为将军饮马，两点间线段最短）。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221110200728239-740229191.png)

其实证明好像是有点问题的，因为如果非中心旋转在这些已知条件中好像也是合理的，所以不能判断一定为椭圆。

比如按 $1/4$ 或 $1/3$ 旋转，就明显不是椭圆。

因为我们没用到每个位置瞬时速度的大小这个条件。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221113111508394-241966296.png)

问出去了。

好像不是这个渠道，算了摆。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16901360.html</id>
    <title type="text">点分治 &amp; 点分树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-17T14:53:00Z</published>
    <updated>2022-11-17T14:53:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16901360.html" />
    <content type="text">[cxy 神犇 Blog](https://www.luogu.com.cn/blog/chenxinyang2006/dian-fen-shu-xue-xi-bi-ji)

## P6329 【模板】点分树 | 震波

[双 log 空间动态开点线段树](https://www.luogu.com.cn/record/94401532)

[单 log 空间（存疑（指的是这种写法））动态开点线段树](https://www.luogu.com.cn/record/94402483)

[单 log 空间树状数组（写错 WA 了，之后改，咕咕咕）](https://www.luogu.com.cn/record/94403436)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16907898.html</id>
    <title type="text">NOI WC 2023 游寄-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-20T01:37:00Z</published>
    <updated>2022-11-20T01:37:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16907898.html" />
    <content type="text"># 1668908390

开坑。今年只剩线上的了/kk。

~~（要不以后游记都用 [Unix 时间戳](https://ol.woobx.cn/tool/timestamp)吧）~~

&lt;details&gt;
&lt;summary&gt;日程表&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230112223842728-1056924461.png)
&lt;/details&gt;

# 1673512200

lj 和 wxw 都去成都了。

开幕式。

说好一个小时弄了一个半，不让我吃晚饭。

&lt;details&gt;
&lt;summary&gt;NOI 蛋糕&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230112223455956-763137231.png)
&lt;/details&gt;

领导讲话 + 打成都七中的广告 + 才艺表演

&lt;details&gt;
&lt;summary&gt;问了一下明天早上第一 / 第二课堂的情况&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230112223553909-519343036.png)

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230112223656378-1122897474.png)
&lt;/details&gt;

# 1673569800

开始上课。

第一课堂：介绍和教程 Coq 证明辅助工具。

真的不知道有啥用（不过听起来好 nb），我甚至连 github 上源码都下载不下来，听了一半直接劝退去第二课堂。

第二课堂：矩乘 &amp; 动态 DP

第二课堂好像都偏简单，不过有题可以做了。

~~但是都放进集锦里吃灰了。~~

没上多久就开始各种颓，今天一整天都这样。

中午稍微吃了一顿然后继续颓，打皇室战争。

# 1673589600

第一课堂听 hehezhou 好题选讲。

这下有用的来了啊，但是我还是颓，记录题号直接摆。

第二课堂好像是 DP，据说简单。

# 1673607600

继续颓~~甚至开始看起了涩图（bushi~~

集训队选手交流，我直接录屏（还好录了，结束后连讲义都不发）。

可以直接去文件夹看录播，感觉造数据、超立方体和 SAM 拓展比较 amazing。

[晚安喵](https://music.163.com/#/song?id=28875230)。（今天好颓）

# 1673656200

早安喵。

后面真的没啥好写的。

一直上课摸鱼态，wc 坐牢作弊讨论（bushi），喜提 Ag，wsyear &amp; zhouyishan Au（都是暴力，为啥相差这么多），wxw 答辩 6-&gt;4 wasted，悲痛。

闭幕式在歌舞声中结束，赶紧回家过年吧。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16907954.html</id>
    <title type="text">NOIP 2022-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-20T02:09:00Z</published>
    <updated>2022-11-20T02:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16907954.html" />
    <content type="text">游不了，因为今年初中生寄了。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221120100836860-1512042690.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16913593.html</id>
    <title type="text">CF1761 上红记（其实是题解）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-21T14:20:00Z</published>
    <updated>2022-11-21T14:20:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16913593.html" />
    <content type="text">EZEC 的场，学车他们出的，可能这场对国人友好一点。

![](https://img2022.cnblogs.com/blog/2213867/202211/2213867-20221121222159039-1465046294.png)

UnAC 提交次数分别是 00004。

这场质量高啊，打算单独拎出来写题解。

[DX 带 anime pictures 的题解](https://www.luogu.com.cn/blog/111055/ezec-r13-chinese-editorial)

# A

略。

# B

我是真没想出来，先写 C 去了。题意自己看。

结论题：

* 若只有两种元素 $\{a,b,a,b,\dots,a,b\}$，答案为 $n/2+1$。

* 否则，答案为 $n$。

我们证明后者。

如果我们存在一种元素的个数 $=1$，则我们不断删掉这个元素一侧的点即可。

否则，由于必然存在一个点使得两侧的点值不一样，我们删掉这个点，元素种类数不变。

# C

脑中建有向图 $x\to y$ 当且仅当 $[b_{y,x}]$（$y$ 是 $x$ 的真子集）。

所以这是一个 DAG。

本来拓扑序一下每个集合是儿子们的并即可，但是题目要真子集。

值域充足 $1,\dots,n$，我们每个 $A_i$ 为并后再加入元素 $i$ 即可，保证她的儿子们没有。

然后我就 $O(n^3)$ 过了，其实也可以 $O(n^3/w)$。

后来发现原 $b$ 矩阵已经传递闭包了，我们只需要转置输入的矩阵并输出即可，$O(n^2)$。

# D

本来第一眼：woc 大水题！纯纯组合嘛，这不上大分！

结果 Little09 一眼会，薄纱我/dk。

发现只有每一位有多少个 $1$ 有用，具体分配给 $a$ 还是 $b$ 无所谓。

设 $b_0,\dots,b_{n-1}$ 表示每一位有多少 $1$（$b_0$ 是最低位）。

则 $i$ 位置能进位当且仅当存在 $j\le i$ 使得 $b_j=2$ 且 $b[i,j]$ 中不存在 $0$（$0$ 终止，$1$ 传递，$2$ 能源）。

设 $b_n=b_{-1}=0$，合理吧。

极长的能进位的连续段等价于前头是个 $0$，尾端是 $2$，尾巴后面有 $2$ 之前先有 $0$。

设极长的能进位的连续段个数为 $d$。

$b_{n-1}=0$：

$$
cnt=3^{n-2d}\binom{k-1}{d-1}\binom{n-k}{d}
$$

$b_{n-1}&gt;0$：

$$
cnt=3^{n-2d+1}\binom{k-1}{d-1}\binom{n-k}{d-1}
$$

枚举一下 $d$ 即可，$O(n),O(n\log n)$ 均可。

# E

毒瘤细节分讨题（其实是我菜）。

若已经是连通块，$0$。

若存在孤立点，$1$。

若存在一个连通块 $S$ 不是团，$1$。$(\Delta)$

接下来连通块就都是团了。

若团数 $=2$，必然是将较小的团内的点都选一遍。

否则团数 $\ge 3$，$2$，选两个不在同一个团里的点即可。

$(\Delta)$ 咋做呢？

我的解法：我们 dfs 的时候记录 dfs 序，查找不满度的 dfs 序最大的点即可。

正确性可用 dfs 树只有返祖边。

DX 解法：找到连通块内度最小的点即可。

证明：

最小度点设为 $x$，删掉 $x$ 后形成的连通块为 $L_1,\dots,L_k$。

如果 $k=1$，必然可行。

$k&gt;1$，假设存在一个 $c$ 使得操作后 $L_c$ 与 $x$ 没有连边了，那为了保证 $x$ 的最小度，$L_c$ 必须是团，最小度最大也只能是 $|L_c|$，所以 $x$ 不能再连边了，$k=1$，矛盾。

# F1

咕咕咕，去看 dx 的题解。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16935228.html</id>
    <title type="text">回文自动机 PAM-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-11-29T05:58:00Z</published>
    <updated>2022-11-29T05:58:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16935228.html" />
    <content type="text">[OI-wiki](https://oi-wiki.org/string/pam/)

# P3649 [APIO2014] 回文串

（贺的.jpg）

## 简述

回文树和回文自动机指的是同一个东西

是由某西伯利亚人于2014夏发明的

这东西主要是用于计数，计算回文串的个数以及种类啥的

## 建树

首先，回文树里有两棵树，分别记录长度为奇数和偶数的回文串

每个节点代表一个回文串，记录转移$x$，表示如果在这个回文串前后都加上字符$x$形成的回文串是子节点的子串

然后每一个节点记录一个fail指针，指向这个回文串的最长后缀回文串

然后我们考虑建树，假设已经建好了串$s[1...i-1]$，要把字符$s[i]$插入这棵树

那么每一次只会把$s[1...i]$的最长后缀回文串加进树里。

我们设后缀回文$i$是最长后缀回文$k$的子串，那么$i$肯定关于$k$的回文中心有一个对称串$j$，由于$k$本身是对称的，所以$j$和$i$是相同的，那么$j$已经被加入到回文树中，所以$i$不必再加入

然后就没问题了。我们设最长回文后缀为$k$，加入字符$c$，那么如果可以，最长回文后缀会变成$ckc$

然而如果$k$之前的字母不是$c$怎么办？这个时候$fail$指针就派上用场了。我们用$fail$维护每一个节点的最长后缀回文，如果$k$不行，我们看看$k$的最长后缀回文是否可行（就是看$k$的最长后缀回文的前一个字母是否等于$c$），然后就这样一直跳$fail$指针直到找到为止（如果一直没有找到会跳到根节点，下面再说）

然后如何维护$fail$呢？我们只要找到了当前节点的最长回文后缀然后记录一下就就好了

然后字符要接在之前的串的后面，记录一下$last$表示上一个串的节点

然后注意特殊处理两个根节点，$0$代表长度为偶数的后缀的根，$1$代表长度为$1$的后缀的根，我们令$fail[0]$指向$1$，$len[1]=-1$，然后令$s[0]=-1$（或任何一个不在原串中出现的字符）（$len$代表这个节点的串长）

就比如说如果跳的时候一直找不到回文怎么办？这个时候这个节点就单独形成一个回文串，那么我们在判断$s[i-len[x]-1]==s[i]$的时候，因为$len[1]=-1$，所以必定会停止，那么就不用担心会无限跳下去了

[Code](https://www.luogu.com.cn/record/96037116)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16974235.html</id>
    <title type="text">CF1764 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-11T11:23:00Z</published>
    <updated>2022-12-11T11:23:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16974235.html" />
    <content type="text"># D

一个数学题。

据说有线性做法。

[Code](https://codeforces.com/contest/1764/submission/184662764)

具体去看 luogu 题解吧。

# E

好题，没细想。

我们任意时刻能点亮的位置必然是 $\le$ 某个值的所有位置。

发现操作 $1$ 是特殊的（必然是最后一个操作的），我们将剩下的操作按 $a_i$ 升序排序。

枚举第一个操作 $s$，接下来我们可以将 $a_i\le a_s$ 的所有操作进行，这样能点亮的上界就是 $\max\limits_{i}(a_s,a_i+b_i)$。

接着按 $a_i$ 非降序操作，设操作前的上限为 $c$，则操作后上界为 $\min(a,c)+b$。

然后每个操作作为第一个其实是可以压在一起的（DP 状物？）详见 [Code](https://codeforces.com/contest/1764/submission/184664567)。

# F

算是自己想出来了。

发现树上任意一条路径的答案严格小于这条路径的真子路径（点集为真子集），所以树的形态就是这个完全图 $(i,j,f_{i,j})$ 的最大生成树。

至于 $(i,j)$ 的边权：$(f_{i,i}+f_{j,j}-2f_{i,j})/n$，证明可以算每条边的贡献。

Prim 做到 $O(n^2)$。

[Code](https://codeforces.com/contest/1764/submission/184677343)

# G

首先我们将值 $2k$ 和值 $2k+1$ 配对（$1$ 不配对，$n$ 可能不配对）。

$2\text{que}(1,x,2)-x$ 就是 $[1,x]$ 内没有内部配对的点数。

$[\text{que}(l,r,n)=2]$（必须保证 $l&lt;r$）就是 $[l,r]$ 是否存在值 $n$。

## 30 次询问

$10$ 次二分出 $n$ 的位置，然后 $20$ 次通过没配对多少的比较二分出 $1$ 的位置。

## 21 次询问

发现前面 $10$ 次有点浪费，我们只要在后面 $1,n$ 分道扬镳的时候多一次询问即可。

## 20 次询问

如果我们保存之前询问的结果，发现最后 $l+1=r$ 的时候是可以 $2$ 次询问变 $1$ 次的（具体看代码），这样正好 $20$，通过本题。

[代码](https://codeforces.com/contest/1764/submission/184683572)

# H

不太会，luogu 唯一的题解代码超级长，LJC00118 写了一个双 $\log$（好像是）的代码，所以看+贺了好久 [zky 的代码](https://codeforces.com/contest/1764/submission/183074182)。

具体咋做我好像也说不太清楚，不妨看 [我的代码](https://codeforces.com/contest/1764/submission/184694972)。

据我的理解是先作差分 $[a_i\ne a_{i+1}]$ 用珂朵莉树维护每个位置从现在往时间反方向走的极长这个位置为 $1$ 的时间，然后就可以扫描线 + 差分了。

这题先咕着。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16981925.html</id>
    <title type="text">STL 传入元素比较 cmp 方法之一-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-14T06:12:00Z</published>
    <updated>2022-12-14T06:12:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16981925.html" />
    <content type="text">```cpp
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

bool cmp(int x, int y) { return x &gt; y; }
priority_queue&lt;int, vector&lt;int&gt;, bool(*)(int, int)&gt; pq(cmp);

signed main()
{
 ios_base::sync_with_stdio(false);
 cin.tie(nullptr);

 pq.push(2);
 pq.push(3);
 cout &lt;&lt; pq.top() &lt;&lt; endl;

 return 0;
}
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16990120.html</id>
    <title type="text">CF1774 部分题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-18T03:14:00Z</published>
    <updated>2022-12-18T03:14:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16990120.html" />
    <content type="text">虽然这场是 Little09 等人出的，但是还是要喷一下弱 samples、pretest、final test。

# C

考察后缀极长相同 0/1，若是连续 $x$ 个，则只有最小/大的 $x-1$ 个不可能成为冠军，输出总数 $-(x-1)$ 即可。

# D

首先如果 $sum$ 是 $n$ 的倍数必然有解，因为每两列 1 个数 $x\ge y$，总可以变成 $\lceil(x+y)/2\rceil,\lfloor(x+y)/2\rfloor$（设两个 1 位置集合位置为 $X,Y$，$|X-Y|\ge x-y$）。

由刚刚的证明，我们遍历每一列，每一列贪心得多让大于平均数的补给到小于平均数的即可。

# E

进行一个结论的猜：A 必须要走过的是包含{根、A 必经点，B 必经点的 $d$ 级祖先}最小子树，B 同理，而且这种方案能取到。

然后一个小树形 DP 即可。

# F

shz 好题，以下是我的解法~~因为我英文差官方题解没看懂~~。

## F1

$lim=2\times 10^5$ 为血量上限。

若没有 3 操作，我们考虑倒着做，用一个 $[1,lim]$ 的数组 $\{d\}$ 维护每个血量的权值。

一开始权值全为 $1$，倒着扫操作，碰到 2 $x$ 操作就将权值数组右移 $x$ 位（$d_1,\dots,d_x$ 补零，溢出的扔掉）。

碰到 1 $x$ 操作将答案加上 $d_x$。

发现右移是多余的，因为我们可以将之后（序列之前）的 1 操作 $x$ 减掉相应的值，若 $x\le 0$ 直接取 $0$。

加入 3 操作。当遇到 3 操作时，相当于前面变成了两个分支，一个是正常的，一个是经过了这么多 2 操作（可前缀和预处理）后将 $d$ 右移后的。

发现可以同时做，只要将 $d$ 右移后加回自己即可。

注意到这个前缀和每次遇到 3 操作时都会乘 $2$，所以从前往后每个 3 操作右移量是至少倍增的。

所以有用的 3 操作只有 $\log lim$ 个。

**注意用乘系数的方式计算前面右移量为 $0$ 的 3 操作。**

**注意用 inf 标记倍增超过 $lim$ 的 3 操作。**

然后就做完了 F1，代码中 $\{c\}$ 是 $\{d\}$ 的差分，为了铺垫至 F2。

复杂度 $O(n+lim\log lim)$。

[Code](https://codeforces.com/contest/1774/submission/185688859)

## F2

这下 $lim=10^9$ 了。

还是由于从后往前 3 操作位移是至少半衰的，结合二进制的相关内容，可知每个 3 操作位移大于其序列前面 3 操作位移之和，也就是说**$\{c\}$ 是一个 01 序列。**

我们从后往前记录每一个 3 操作的位移，查询时直接相当于在满二叉搜索树（只有叶子存值）查询 $\le$ 这个数的叶子有多少个。

轻松优化到 $O(n\log lim)$。

[Code](https://codeforces.com/contest/1774/submission/185695278)

# G

先咕。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16994294.html</id>
    <title type="text">CF1763 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-20T07:29:00Z</published>
    <updated>2022-12-20T07:29:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16994294.html" />
    <content type="text"># C

&gt; 这场唯一有趣一点的题。——gyh

这一类的题目一般都存在一个构造使得答案能取到一个很明显的上界。

比如这道题在大部分时候我们能使答案取到 $mx\times n$（$mx$ 为序列最大值）。

构造如下：

如果最大值位置是 $pos$。

先对 $[1,pos-1]$ 进行两次操作，这些位置变为全 $0$，对 $[1,pos]$ 执行一次操作，对 $[2,n]$ 进行两次操作，再对 $[1,n]$ 执行一次操作。

若 $pos=1$ 或 $2$ 则需要把序列翻转。

这样除了 $n=2,3$ 我们都取到了这个明显的上界，剩下的情况讨论一下。

[Code](https://codeforces.com/contest/1763/submission/186016119)

# E

先考虑双向可达，立刻想到强连通分量。

问题就变为构造一个正整数序列 $c_1,\dots,c_k$ 使得 $\sum_{i=1}^k\binom{c_i}{2}=p$，且 $\sum_{i=1}^{k}c_i$ 最小。

发现有用的 $c$ 值只有 $O(\sqrt p)$ 个，可以 $O(p\sqrt p)$ 做完全背包。

**注意贪心取大的 $c_i$ 是错误的，Hack：$p=25$，最优是 $\{c\}=\{6,5\}$，而贪心结果为 $\{7,3,2\}$。**

至于让单向点对最多，显然上界是
$$
\frac{(\sum_{i=1}^k c_i)^2-\sum_{i=1}^k c_i^2}{2}
$$
所以在 DP 的时候第二关键字为 $c_i$ 的平方和，我们尽量让其小。

[Code](https://codeforces.com/contest/1763/submission/186016214)

# F

&gt; 没看懂这题，直接建圆方树输出路径上非割边条数，好像并不需要任何图的性质？——gyh

确实啊，我捣鼓这个性质好久……

至于圆方树，我真不熟，所以先半贺了一个，后面学起来。

[Code](https://codeforces.com/contest/1763/submission/186073304)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16994359.html</id>
    <title type="text">圆方树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-20T07:48:00Z</published>
    <updated>2022-12-20T07:48:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16994359.html" />
    <content type="text">[OI wiki](https://oi-wiki.org/graph/block-forest/) 应该和这个差不多 [小粉兔blog](https://www.cnblogs.com/PinkRabbit/p/Introduction-to-Block-Forest.html)

# 例题

## CF1763F Edge Queries

[题解](https://www.cnblogs.com/shaojia/p/cf_1763.html#f)

## P5236 【模板】静态仙人掌

↓这些题还没写，先留坑

## P4630 [APIO2018] 铁人两项

## CF487E Tourists

## P4606 [SDOI2018]战略游戏

## P4320 道路相遇</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/16994369.html</id>
    <title type="text">[USACO22DEC] 全部（12 题）题解及代码-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-20T07:51:00Z</published>
    <updated>2022-12-20T07:51:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/16994369.html" />
    <content type="text">[为啥会有我 AK Pt 快照啊](http://usaco.org/current/data/dec22_platinum_results.html)：

![](https://img2023.cnblogs.com/blog/2213867/202212/2213867-20221226225349919-1801713089.png)

![](https://img2023.cnblogs.com/blog/2213867/202212/2213867-20221225110429365-2000347348.png)

# 题解

## Cu

我甚至卡 Cu T3 /qd。

### T1

略。

### T2

随便蒙了一个贪心，过了。

### T3

每个变量只会出现 $1$ 次，因为下一次恒为真或假。

每次找到一个可以划分的条件并使用。

为方便，我们直接每次取出一个可以划分的条件，看看是否能让 $2n$ 个条件均用上。

## Ag

![](https://img2023.cnblogs.com/blog/2213867/202212/2213867-20221220155130990-914569255.png)

### T1

算出每条边的流量。

非零必然流，零必然不流。这样一定有解，考虑向儿子边的从上往下流，再向父亲边的从下往上流。

### T2

考虑单个游戏，双方必然让自己赢得快或输得慢。

由于 $\{1,2,3\}\subseteq$ 可选数集，而且不存在 $4$ 的倍数，所以胜负等价于每个人取 $\{1,2,3\}$，取不了的人输。

这是经典问题，奇异局面是总个数为 $4$ 倍数的那些局面。

对于先手必败的局面，先手为了晚点输必然选择 $2$，因为这样后手为了保持必胜只能选 $2$（唯一的偶素数），这样总共操作 $n/2$ 次。

而先手必胜的，必然会选择一个最大的素数使得剩下的局面必败，lower_bound 一下即可。

最后将每个游戏取 $\min$ 即可。

### T3

确定了一个序列的所有子串的极差就确定了这个序列的差分序列（或者其相反数）。

所以直接贪心构造即可，每下一个尝试若满足前面的极差就确定了。

## Au

据说这场 Au 比历年简单。

### T1

将朋友按冰淇淋的价值（能换一块钱的个数的倒数）降序，若确定了最后带的朋友，则冰淇凌必然堆在前面的朋友用。

然后就可以 DP 了，这样我们可以将冰淇淋和钱压在同一维里了。

### T2

每个位置维护其之后与她的斜率序列，我们维护所有序列的前缀最值个数。

用 set 都能过，$O(n^2\log n)$，有点卡常，记得少一点 lower_bound。

### T3

每次将度最小的点删除，维护删除序列，从空图上倒序加点，维护并查集计算当前度乘并查集大小即可。

## Pt

全场被 Little09 带飞，感觉就不是我在打……

### T1

时光倒流，删边 $\to$ 加边。

特殊点指 $1$ 号点和 $n$ 号点。

维护点对之间一阶（经过一条边的最小距离，后面同理）距离。

每次修改 $O(n)$ 改，维护点对之间二阶距离。

通过维护的一阶距离和二阶距离，每次 $O(n)$ 维护特殊点到任意点的三阶距离。

若新增一条边两端点均非特殊点，可每次 $O(n)$ 维护特殊点到任意点的四阶距离。

否则，这样的边数是 $O(n)$ 的，可每次 $O(n^2)$ 维护特殊点到任意点的四阶距离。

查询时 $O(n)$ 每个点作为中转点，将其到两个特殊点的距离（$\lfloor k/2\rfloor$ 阶和 $\lceil k/2\rceil$ 阶）加起来。

总复杂度 $O(n^3)$。

### T2

动态维护这个图的每个团。

初始时每条边看作一个团，给两端打颜色标记。

每个颜色维护所有存在这个颜色的点的标号集合（set）。

每次删掉一个点，将这个点的所有颜色合并（set 启发式合并，去重），并将这个颜色中删除这个当前删除的点，则这个删除的点死前连接的边数就是这个颜色集合的大小。

复杂度线性双 $\log$。

### T3

按最后回文串中 1 的个数奇偶分类。

若是奇数，我们枚举中心 1，每次向两边同时扩展一个 1。

若是偶数，我们枚举中心两个 1，和奇数同理。

考虑一个串的操作次数。

长度为偶数且 1 个数为奇数则为 $-1$。

若 1 偶数个，最小次数则为两两配对（头尾配对）左边的到左边界的距离 和 右边的到右边界的距离 的差的绝对值（就是两者形成对称的最小操作次数）。

若 1 奇数个，最小次数则要再加上中心 1 到序列中心的距离。

所以问题转化为：

数轴上（值域 $O(n)$ 且只考虑整数）每次加入一个点，查询所有点到某个点的距离和。

两个树状数组搞定。

复杂度 $O(n^2\log n)$，树状数组常数极小。

# 代码

## Cu

&lt;details&gt;
&lt;summary&gt;T1&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 100010
#define int ll
int n,a[N],ans=-1,id=-1;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,n) cin&gt;&gt;a[i];
	sort(a+1,a+1+n);
	int now;
	rep(i,1,n){
		now=(n-i+1)*a[i];
		if(now&gt;ans){
			ans=now;
			id=a[i];
		}
	}
	assert(~id);
	cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;id&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T2&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 100010
int n,m;
char s[N],t[N];
void work(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;(s+1);
	fill(t+1,t+1+n,'.');
	t[n+1]=0;
	int G=-N-4,H=-N-4;
	rep(i,1,n){
		if(s[i]=='G'){
			if(G+m&lt;i){
				G=min(i+m,n);
				while(t[G]!='.') G--;
				t[G]='G';
			}
		}else if(s[i]=='H'){
			if(H+m&lt;i){
				H=min(i+m,n);
				while(t[H]!='.') H--;
				t[H]='H';
			}
		}
	}
	int cnt=0;
	rep(i,1,n) if(t[i]!='.') cnt++;
	cout&lt;&lt;cnt&lt;&lt;"\n"&lt;&lt;(t+1)&lt;&lt;"\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T3&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 103
bool a[N];
int n,m;
char s[N][N];
bool vis[N][2],kil[N];
bool check(int x,int y){
	int tar=-1;
	rep(i,1,m) if(!kil[i] &amp;&amp; s[i][x]-'0'==y){
		if(tar==-1) tar=a[i];
		else if(tar!=a[i]){
			return false;
		}
	}
	return true;
}
void work(){
	cin&gt;&gt;n&gt;&gt;m;
	DD(n,m);
	rep(i,1,m){
		cin&gt;&gt;(s[i]+1)&gt;&gt;a[i];
		DD(s[i]+1,a[i]);
	}
	fill(kil+1,kil+1+m,false);
	rep(i,1,n) vis[i][0]=vis[i][1]=false;
	rep(_,1,2*n){
		int x=0,y=0;
		rep(i,1,n){
			rep(j,0,1) if(!vis[i][j]){
				if(check(i,j)){
					x=i,y=j;
					vis[i][j]=true;
					break;
				}
			}
			if(x) break;
		}
		if(!x){
			cout&lt;&lt;"LIE\n";
			return ;
		}
		rep(i,1,m) if(s[i][x]-'0'==y) kil[i]=true;
		DD(x,y,vector&lt;int&gt;(kil+1,kil+1+m));
	}
	cout&lt;&lt;"OK\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

## Ag

&lt;details&gt;
&lt;summary&gt;T1&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 200010
#define int ll
int n,a[N],sum=0,id[N],f[N],tim=0;
vector&lt;int&gt; e[N];
void dfs(int rt,int fa){
	f[rt]=fa;
	id[++tim]=rt;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
		a[rt]+=a[i];
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,n) cin&gt;&gt;a[i],sum+=a[i];
	sum/=n;
	rep(i,1,n) a[i]-=sum;
	int x,y;
	rep(i,1,n-1){
		cin&gt;&gt;x&gt;&gt;y;
		e[x].pb(y);
		e[y].pb(x);
	}
	dfs(1,0);
	int cnt=0;
	rep(i,1,n) if(a[i]) cnt++;
	cout&lt;&lt;cnt&lt;&lt;"\n";
	per(i,n,2){
		x=id[i];
		if(a[x]&gt;0){
			cout&lt;&lt;x&lt;&lt;" "&lt;&lt;f[x]&lt;&lt;" "&lt;&lt;a[x]&lt;&lt;"\n";
		}
	}
	rep(i,2,n){
		x=id[i];
		if(a[x]&lt;0){
			cout&lt;&lt;f[x]&lt;&lt;" "&lt;&lt;x&lt;&lt;" "&lt;&lt;-a[x]&lt;&lt;"\n";
		}
	}
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T2&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 200100
#define V 5000000
int n,a[N],f[V+1];
bool vis[V+1];
vector&lt;int&gt; pr,p[4];
void work(){
	cin&gt;&gt;n;
	rep(i,1,n) cin&gt;&gt;a[i];
	int mn=f[a[1]]/2,id=1,now;
	rep(i,2,n) if((now=f[a[i]]/2)&lt;mn) mn=now,id=i;
	if(a[id]%4==0) cout&lt;&lt;"Farmer Nhoj\n";
	else cout&lt;&lt;"Farmer John\n";
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	p[1].pb(1);
	rep(i,2,V){
		if(!vis[i]){
			pr.pb(i);
			p[i%4].pb(i);
		}
		for(int j:pr){
			if(i*j&gt;V) break;
			vis[i*j]=true;
			if(i%j==0) break;
		}
	}
	int x,w;
	rep(i,0,V){
		w=i%4;
		if(w==0){
			f[i]=i/2;//2 2 2 2 2...
		}else{
			x=upper_bound(p[w].begin(),p[w].end(),i)-p[w].begin()-1;
			f[i]=f[i-p[w][x]]+1;
		}
	}
	int T;cin&gt;&gt;T;
	while(T--)work();
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T3&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 310
int n,a[N][N],b[N];
bool ban(int x){
	int L=b[x],R=b[x];
	per(i,x-1,1){
		ckmn(L,b[i]);
		ckmx(R,b[i]);
		if(R-L!=a[i][x]) return true;
	}
	return false;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,n) rep(j,i,n) cin&gt;&gt;a[i][j];
	b[1]=0;
	rep(i,2,n){
		b[i]=b[i-1]+a[i-1][i];
		if(ban(i)){
			b[i]=b[i-1]-a[i-1][i];
		}
	}
	//USACO 不讲武德，行末不能有空格
	rep(i,1,n) cout&lt;&lt;b[i]&lt;&lt;" \n"[i==n];
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

## Au

&lt;details&gt;
&lt;summary&gt;T1&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 2022
struct node{
	int p,c,x;
	friend bool operator&lt;(const node&amp;x,const node&amp;y){
		return x.x&lt;y.x;
	}
}a[N];
const int inf=1e9;
int f[N][N&lt;&lt;1],A,B,n;
int calc(int now,int tot,int di){
	if(now&gt;=B){
		return now+tot;
	}else if(now+di*tot&lt;=B){
		return now+di*tot;
	}else{
		return B+tot-(B-now)/di;
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;
	rep(i,1,n) cin&gt;&gt;a[i].p&gt;&gt;a[i].c&gt;&gt;a[i].x;
	sort(a+1,a+1+n);
	rep(i,0,N-1) rep(j,0,(N&lt;&lt;1)-1) f[i][j]=-inf;
	rep(i,0,A+B) f[0][i]=0;
	int w;
	rep(i,0,n-1){
		rep(j,0,A+B){
			DD(i,j,f[i][j]);
			w=calc(j,a[i+1].c,a[i+1].x);
			ckmx(f[i+1][j],f[i][j]);
			if(w&lt;=A+B) ckmx(f[i+1][w],f[i][j]+a[i+1].p);
		}
	}
	cout&lt;&lt;f[n][A+B]&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T2&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
struct frac{
	int p,q;//p/q
	frac():p(0),q(1){}
	frac(int x,int y):p(x),q(y){}
	inline friend bool operator&lt;(const frac&amp;x,const frac&amp;y){
		return 1ll*x.p*y.q&lt;1ll*y.p*x.q;
	}
};
#define N 2010
const int inf=2e9;
int n;
struct node{
	frac a[N];
	set&lt;int&gt; s;
	inline void build(int x){
		s.clear();
		fill(a+2+x,a+1+n,frac(-inf,1));
		rep(i,x+1,n) s.insert(i);
	}
	inline void ins(int x,frac val){
		a[x]=val;
		auto L=s.upper_bound(x);
		if(*prev(L)!=x){
			if(a[x]&lt;a[*prev(L)]) return ;
			s.insert(x);
		}
		auto R=L;
		while(R!=s.end() &amp;&amp; a[*R]&lt;a[x]){
			R++;
		}
		s.erase(L,R);
	}
}t[N];
int a[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,n) cin&gt;&gt;a[i];
	rep(i,1,n-1){
		t[i].build(i);
		rep(j,i+1,n){
			t[i].ins(j,frac(a[j]-a[i],j-i));
		}
	}
	int x,y,q,res;
	cin&gt;&gt;q;
	while(q--){
		cin&gt;&gt;x&gt;&gt;y;
		a[x]+=y;
		rep(i,1,x-1){
			t[i].ins(x,frac(a[x]-a[i],x-i));
		}
		if(x&lt;n){
			t[x].build(x);
			rep(i,x+1,n){
				t[x].ins(i,frac(a[i]-a[x],i-x));
			}
		}
		res=0;
		rep(i,1,n) res+=siz(t[i].s);
		cout&lt;&lt;res&lt;&lt;"\n";
	}
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T3&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 100010
int deg[N],n,b[N],bt=0,val[N],sz[N],f[N];
bool kil[N];
vector&lt;int&gt; e[N];
struct node{
	int x,deg;
	friend bool operator&lt;(const node&amp;x,const node&amp;y){
		return x.deg&gt;y.deg;
	}
};
priority_queue&lt;node&gt; q;
inline int gf(int x){ return x==f[x]?x:f[x]=gf(f[x]); }
void merge(int x,int y){
	x=gf(x),y=gf(y);
	if(x==y) return ;
	f[y]=x;
	sz[x]+=sz[y];
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int x,y,m;
	cin&gt;&gt;n&gt;&gt;m;
	rep(i,1,m){
		cin&gt;&gt;x&gt;&gt;y;
		deg[x]++;
		deg[y]++;
		e[x].pb(y);
		e[y].pb(x);
	}
	rep(i,1,n) q.push({i,deg[i]});
	rep(i,1,n-1){
		while(!q.empty() &amp;&amp; q.top().deg&lt;i){
			x=q.top().x;
			y=q.top().deg;
			q.pop();
			if(deg[x]!=y) continue;
			val[x]=i-1;
			b[++bt]=x;
			kil[x]=true;
			for(int i:e[x]){
				deg[i]--;
				deg[x]--;
				if(!kil[i]) q.push({i,deg[i]});	
			}
		}
	}
	iota(f+1,f+1+n,1);
	fill(sz+1,sz+1+n,1);
	int ans=0;
	while(bt){
		x=b[bt--];
		for(int i:e[x]) if(val[i]&gt;=val[x]){
			merge(i,x);
			ckmx(ans,val[x]*sz[gf(x)]);
		}
	}
	cout&lt;&lt;ans&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

## Pt

&lt;details&gt;
&lt;summary&gt;T1&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define N 302
const int inf=1e9;
int n,k;
uint out[N*N],w[N][N],f[N][5],g[N][5],b[N][N],a[N][N];
pi E[N*N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;k;
	rep(i,1,n) rep(j,1,n) cin&gt;&gt;w[i][j];
	rep(i,1,n*n) cin&gt;&gt;E[i].fir&gt;&gt;E[i].sec;
	rep(i,1,n) rep(j,1,4) f[i][j]=g[i][j]=inf;
	rep(i,1,n) rep(j,1,n) b[i][j]=a[i][j]=inf;
	int x,y;
	uint z;
	per(_,n*n,1){
		z=inf;
		rep(i,1,n) ckmn(z,f[i][k&gt;&gt;1]+g[i][(k+1)&gt;&gt;1]);
		out[_]=z;
		x=E[_].fir,y=E[_].sec,z=w[x][y];
		//--- 1
		a[x][y]=z;
		if(x==1) f[y][1]=z;
		if(y==n) g[x][1]=z;
		//--- 2
		rep(i,1,n){
			ckmn(b[x][i],z+a[y][i]);
			ckmn(b[i][y],a[i][x]+z);
		}
		rep(i,1,n){
			f[i][2]=b[1][i];
			g[i][2]=b[i][n];
		}
		//--- 3
		rep(i,1,n){
			ckmn(f[i][3],a[1][x]+z+a[y][i]);
			ckmn(g[i][3],a[i][x]+z+a[y][n]);
		}
		ckmn(f[y][3],b[1][x]+z);
		ckmn(g[x][3],b[y][n]+z);
		if(x==1) rep(i,1,n) ckmn(f[i][3],z+b[y][i]);
		if(y==n) rep(i,1,n) ckmn(g[i][3],b[i][x]+z);
		//--- 4
		rep(i,1,n){
			ckmn(f[i][4],z+min(a[1][x]+b[y][i],b[1][x]+a[y][i]));
			ckmn(g[i][4],z+min(a[i][x]+b[y][n],b[i][x]+a[y][n]));
		}
		ckmn(f[y][4],f[x][3]+z);
		ckmn(g[x][4],g[y][3]+z);
		if(x==1) rep(i,1,n) rep(j,1,n) ckmn(f[i][4],z+b[y][j]+a[j][i]);
		if(y==n) rep(i,1,n) rep(j,1,n) ckmn(g[i][4],z+b[j][x]+a[i][j]);
	}
	rep(i,1,n*n) cout&lt;&lt;(out[i]==inf?-1:(int)out[i])&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T2&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define int ll
#define N 200010
int n,m,f[N],ans=0;
inline int gf(int x){ return f[x]==x?x:f[x]=gf(f[x]); }
set&lt;int&gt; p[N];
vector&lt;int&gt; e[N];
void merge(int x,int y){
	if(x==y) return ;
	if(p[x].size()&lt;p[y].size()) swap(x,y);
	f[y]=x;
	for(int i:p[y]) p[x].insert(i);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;m;
	iota(f+1,f+1+m,1);
	int x,y;
	rep(i,1,m){
		cin&gt;&gt;x&gt;&gt;y;
		e[x].pb(i);
		e[y].pb(i);
		p[i].insert(x);
		p[i].insert(y);
	}
	int now;
	rep(i,1,n) if(!e[i].empty()){
		now=e[i].front();
		for(int j:e[i]) merge(gf(now),gf(j));
		p[gf(now)].erase(i);
		ans+=p[gf(now)].size();
	}
	cout&lt;&lt;ans-m&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt;T3&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n")
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef pair&lt;int,int&gt; pi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
#define int ll
#define N 7505
int n,c[N],ct,f[2][N&lt;&lt;1],lim,tot,sum;
void add(bool T,int x,int y){
	while(x&lt;=lim){
		f[T][x]+=y;
		x+=x&amp;(-x);
	}
}
int que(bool T,int x){
	int res=0;
	while(x){
		res+=f[T][x];
		x&amp;=(x-1);
	}
	return res;
}
void Add(int x){//[1,2n]
	tot++;
	sum+=x;
	add(0,x,1);
	add(1,x,x);
}
void Cle(){
	tot=sum=0;
	fill(f[0]+1,f[0]+1+lim,0);
	fill(f[1]+1,f[1]+1+lim,0);
}
int Que(int x){
	return x*(2*que(0,x)-tot)+sum-2*que(1,x);
}
char s[N];
int ans=0;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;(s+1);
	n=strlen(s+1);
	lim=n&lt;&lt;1;
	Cle();
	rep(_,1,n) if(s[_]=='H'){
		DD("odd",_);
		int cen=_,l=_,r=_,nl,nr;
		while(true){
			nl=l-1,nr=r+1;
			while(1&lt;=nl &amp;&amp; s[nl]=='G') nl--;
			while(nr&lt;=n &amp;&amp; s[nr]=='G') nr++;
			DD(nl,l,r,nr);
			rep(i,nl+1,l) rep(j,r,nr-1){
				if((i+j)&amp;1) ans--;
				else ans+=abs(cen-((i+j)&gt;&gt;1))+Que(i+j);
			}
			DD(ans);
			if(nl&lt;1 || n&lt;nr) break;
			Add(nl+nr);
			l=nl,r=nr;
		}
		Cle();
	}
	rep(_,1,n) if(s[_]=='H'){
		int l=_,r=_+1,nl,nr;
		while(r&lt;=n &amp;&amp; s[r]=='G') r++;
		if(r&gt;n) continue;
		DD("even",l,r);
		Add(l+r);
		while(true){
			nl=l-1,nr=r+1;
			while(1&lt;=nl &amp;&amp; s[nl]=='G') nl--;
			while(nr&lt;=n &amp;&amp; s[nr]=='G') nr++;
			DD(nl,l,r,nr);
			rep(i,nl+1,l) rep(j,r,nr-1){
				ans+=Que(i+j);
			}
			DD(ans);
			if(nl&lt;1 || n&lt;nr) break;
			Add(nl+nr);
			l=nl,r=nr;
		}
		Cle();
	}
	cout&lt;&lt;ans&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17014436.html</id>
    <title type="text">猫树（分治）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2022-12-30T03:16:00Z</published>
    <updated>2022-12-30T03:16:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17014436.html" />
    <content type="text">P6240 好吃的题目
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17030044.html</id>
    <title type="text">2023 贺的和不贺的那些题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-06T03:50:00Z</published>
    <updated>2023-01-06T03:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17030044.html" />
    <content type="text"># CF1439B Graph Subset Problem

发现 $deg&lt;k-1$ 的点无用，所以不断删除这样的点。

如果 $k&gt;O(\sqrt m)$ 直接不用判团删除 $deg=k-1$ 的点。

否则对于每一个 $deg=k-1$ 的点，我们直接 $O(k^2\log )$ 判断是否是团。如果不是，则删除这个点。

注意每次删除 $deg=k-1$ 的点后要继续删除新变成 $deg&lt;k-1$ 的点。

这样复杂度是对的，考虑 $deg=k-1$ 的点不超过 $O(m/k)$，所以总复杂度是 $O(m\sqrt m\log)$。

# CF1847F The Boss's Identity

场上做出来了，但是当时写的双 $\log$。

首先将 $\{a\}$ 序列 $n$ 个换行，观察每个下标对应的是哪些下标的按位或，发现一定是循环的区间：

```text
[1,1] [2,2] [3,3] [4,4] [5,5]
[1,2] [2,3] [3,4] [4,5] [5,2]
[1,3] [2,4] [3,5] [4,2] [5,3]
[1,4] [2,5] [3,2] [4,3] [5,4]
[1,5] [2,1] [3,2] [4,3] [5,4]
```

发现像滚筒一样，$a_{kn+r}(1\le r\le n)$ 的区间左端点一定是 $a_r$，隔 $n$ 个长度 $+1$，当区间右端点超过 $n$ 循环回 $1$ 时长度 $+2$。

考虑以每个 $a_1,\dots,a_n$ 为左端点的区间或，发现值不同的只有位长（即 $30$）个，所以预处理出每个位置向后某一位第一次变为 $1$ 的位置，排序后离线处理询问即可。

复杂度 $O(n\log n\log\log n)$。

# CF1470C Strange Shuffle

此题强烈建议打表找规律。

设一个时刻上每个人手上的牌数为 $\{a_1,\dots,a_n\}$，这里不妨设伪装者是 $n$ 号人。

可以用归纳法证明如下结论：

* 任意时刻任意 $i$ 有 $a_{i}+a_{n-i}=2k$，特殊地，任意时刻 $a_n=k$。
* 任意时刻任意 $1\le i\le n-2$ 有 $a_i&gt;a_{i+1}$。

先放空 $\sqrt n$ 左右轮，这样从 $a_1$ 开始往右 $\sqrt n\pm O(1)$ 个数都 $&gt;k$，$a_{n-1}$ 往左 $\sqrt n\pm O(1)$ 个数都 $&lt;k$。

为什么会 $\pm O(1)$ 呢？首先，当 $n$ 比较小的时候正负扩张碰头了。其次，当 $n=5,k=2$ 时：

```text
time0:2 2 2 2 2
time1:2 3 2 2 1
time2:2 3 3 1 1
time3:2 3 2 2 1
time4:2 3 3 1 1
...
```

会震荡。

设这时候正负长度最小值不低于 $len$，则将 $n$ 个位置隔 $len$ 个问一个，必然会分别找到一个 $&lt;k$ 和 $&gt;k$ 的位置，分别设为 $ne,po$。

然后在 $[ne,po]$ 环上的一段区间内二分，找到值 $=m$ 的位置就是伪装者。

询问次数 $2\sqrt n+\log n$，细节很多。

# CF1470D Strange Housing

很简单，但没想到。

这里染白色被视作原问题的不染色。

不连通则 NO，否则 YES。

构造：维护染完色的点集 $S$，要保证没有黑色点相邻且 $S$ 通过黑白边连通。

每次找到一个和 $S$ 中某点连边且不在 $S$ 中的点 $x$，若$S$ 中与其连边的点中有黑色点，则 $x$ 为白色，否则 $x$ 为黑色，这样保证了连通性。

可通过 dfs 树简单实现。

# P8923 『MdOI R5』Many Minimizations &amp; [ARC163F] Many Increasing Problems

题意：求定长定值域序列保序回归（或 slope trick）板题答案之和。

atcoder 题解里的公式是错的！/fn/fn/fn

首先考虑朴素的单个序列 slope trick 做法：

初始答案设为 $0$，顺序遍历序列，当前遍历到 $a_i$。

1. 将两个 $a_i$ 加入大顶堆。
2. 设堆顶为 $t$，将答案加上 $t-a_i$。
3. 弹出堆顶。

但是这样不好推广到所有序列。考虑将 $t-a_i$ 看作数轴上 $a_i$ 到 $t$ 的距离。

我们换一种方式计算答案：对于每一个数轴上长度为 $1$ 的线段 $[x,x+1]$（$x$ 为整数）统计有多少距离覆盖她，求和之后就是答案。

也就是说，对于每一个整数 $1\le s\le M-1$，新建序列 $b_i=[a_i&gt;s]$ 求得 $\{b\}$ 答案后求和就是 $\{a\}$ 的答案。

现在转成值域为 $\{0,1\}$ 的问题了，对于遍历到的 $b_i$ 的值分类讨论。而且堆可以退化成 $c_0,c_1$ 表示两个值的个数。

$b_i=0$：

```cpp
c0+=2;
if(c1) ans++,c1--;
else c0--;
```

$b_i=1$：

```cpp
c1++;
```

由于堆不可能被删空，所以 $c_0$ 无用，$b_i=0$ 的伪代码退化成：

```cpp
if(c1) ans++,c1--;
```

也就是将问题转化成：

一个点初始在数轴原点，$n$ 次操作：每次将坐标 $\pm1$，负半轴是墙不可逾越，每次没撞墙的 $-1$ 操作会让答案加一。

若第 $i$ 次操作让答案加一，设其坐标 $z\to z-1$，则找到最近一次坐标 $z-1\to z$ 的操作 $j$，$[i,j]$ 操作之间坐标不能低于 $z$。

这样每种序列的答案就好统计了：
$$
\sum_{s=1}^{M-1}\sum_{k=0}^{\lfloor N/2\rfloor-1}(N-2k-1)Ca(k)s^{k+1}(M-s)^{k+1}M^{N-2k-2}
$$

其中 $Ca(k)=\binom{2k}{k}/(k+1)$ 为卡特兰数，因为 $i,j$ 间操作坐标不能低于 $z$，

$k$ 枚举 $(i-j-1)/2$，

$N-2k-1$ 枚举 $i$ 的位置，

$s^{k+1}(M-s)^{k+1}$ 为 $[i,j]$ 内共 $2k+2$ 个操作 $a_i$ 方案数，

$M^{N-2k-2}$ 为其他操作方案数。

对于 P8923 『MdOI R5』Many Minimizations，二项式直接拆：
$$
\sum_{k=0}^{\lfloor N/2\rfloor-1}\sum_{k'=0}^{k+1}(N-2k-1)Ca(k)M^{N-k-1-k'}\binom{k+1}{k'}\sum_{s=1}^{M-1}s^{k+k'+1}
$$
最右边的求和对于 $[1,N]$ 内所有 $k+k'+1$，可以 $N$ 次拉格朗日插值共 $O(N^2)$ 求出，做完了。

[code](https://www.luogu.com.cn/record/114042578)

而对于 [ARC163F] Many Increasing Problems，我们将 $s(M-s)$ 这个整体看作元，则答案为：
$$
\sum_{k=0}^{\lfloor N/2\rfloor-1}F(k+1)(N-2k-1)Ca(k)M^{N-2k-2}
$$

其中
$$
F(k)=\sum_{s=1}^{M-1}s^k(M-s)^k=[x^k]\sum_{s=1}^{M-1}\frac{1}{1-xs(M-s)}
$$
可以分治+FFT $O(M\log^2 M)$ 求出 $F(1),\dots,F(\lfloor N/2\rfloor)$，具体是归并维护区间之和的分子分母（都是多项式），做完了。

[code](https://atcoder.jp/contests/arc163/submissions/43267670)

# CF1840G2 In Search of Truth (Hard Version)

easy version 可以 $2\sqrt n$ 过，做法类似 BSGS。

Hard Version 增加随机算法，设 $B=300$，先随 $1000-2B$ 个位置查值的 $\max=n_0$，这样真实的 $n$ 就有约 $1-10^{-17}$ 的概率在 $[n0,n0+B^2]$ 中，然后用 easy version 的方法 BSGS 即可。

# [ABC308Ex] Make Q

枚举 Q 的尾巴和圈的交界点 $x$，其在环上两侧的点是 $y,z$。

当圈确定时，找到 $x$ 连出去的不指向 $y,z$ 的边权最小的边，设其指向 $u$。若 $u$ 在圈上时，将圈变成从 $x$ 开始到 $u$ 的弧加上 $(x,u)$，这样圈覆盖的点变成原来的真子集。所以接下来可以假定 $u$ 不在圈上，这样每个 $x$ 只要枚举其前三小的边作为 Q 的尾巴即可。

固定尾巴后，经过 $x$ 但不经过 $u$ 的最小圈可以用最短路树+枚举非树边求得（注意细节）。

复杂度 $O(n^3)$。

# [ABC308G] Minimum Xor Pair Query

vp 时写了双 log 稳过。

双 log：离线 + 线段树分治 + trie。

单 log：有结论每个局面的全局 xor min 一定是相邻的两个数，维护数的 set 即可。

# qoj 6641. XOR Dice (ucup)

[题目链接](https://qoj.ac/problem/6641)

因为 $d\le 60$，所以将每个骰子六个面的值设为 $64$ 进制表示中每一位只能是 $0$ 或 $d$ 的最小的 $6$ 个值即可。

[代码](https://qoj.ac/submission/116828)

# P1186 玛丽卡 &amp; P2685 [TJOI2012] 桥

~~各交了一发暴力，$(10^3)^3$ 和 $(10^5)^2$ 时间都过了。~~

题意：给你一个带边权的边双，问你删掉一条边后从 $1$ 到 $n$ 最短路的最大值（以及多少条边删去能达到这个最大值）。

这里设玛丽卡的 $m=O(n^2)$。

先求出任意一条 $1\to n$ 的最短路以 $R$ 及从 $1,n$ 分别开始的最短路树。

特判最终答案为当前最短路，这样删去的边一定在 $R$ 上。

枚举不在 $R$ 上的边，求出经过这条边的从 $1$ 到 $n$ 的最短路，一定存在一条使得其与 $R$ 的交是一段前缀和一段后缀，则 $R$ 不在前后缀的部分被删去的答案 ckmn 这条新路的长度。ckmn 可以用线段树。

复杂度 $O(m\log n)$。

玛丽卡这道题由于 $m&gt;&gt;n$，dij 不采用堆优化（劣化），最后的线段树采用 ST 表并在最后下传，可以 $O(1)$ ckmn $O(n\log n)$ 建立和求最终答案，可将时间优化到 $O(n^2)$。

further：2023sol3 CF1163F Indecisive Taxi Fee

# P3943 星空 &amp; CF79D Password

你有 $n$ 个灯泡，一开始都未点亮。

同时你有 $l$ 个长度，分别为 $a_1 \sim a_l$。

每次你可以选择一段连续的子序列，且长度为某个 $a_i$，并将这些灯泡的明灭状态取反。

求最少的操作次数，使得最后有且仅有 $k$ 个位置是亮的，这些位置已经给定，为 $x_1 \sim x_k$。

要求复杂度 $O(nkl+k2^{2k})$。

首先差分+倒序，转化为长度为 $n+1$ 的 01 序列 $A$ 中至多有 $2k$ 个为 $1$，每次可以选择两个位置差为某个 $a_i$ 的两个位置同时取反。

由于取反操作满足关于时间的交换律，而且终态全 0。考虑一种合法的操作集合 $S$，每次找到任意一个 $A_x=1$，这时 $S$ 中必然有一边操作 $x$ 位置的操作，操作此操作并从 $S$ 中删除。不断重复上述操作直到不存在 $A_x=1$，这样我们就可以规定每次操作时两边至少要有一个 1。

这样就等价于一排 $n+1$ 个格子，其中有 $2k$ 个棋子，两个棋子在同一位置就会湮灭。每次棋子移动的距离只能为某个 $a_i$，问全部湮灭的最少步数。

$O(nkl)$ 预处理出棋子两两湮灭的最少步数。

考虑最后湮灭的配对，我们只要做一个 $2^{2k}$ 的状压即可。

# gym103119B Boring Problem

题意：

给定 $n$ 个长度均为 $m$ 的小写字符串 $T=\{T_1,\dots,T_n\}$ 和一个字符串 $R$。对于 $R$ 的每个非空前缀 $R'$，求出 $R'$ 不断 append 小写字母（加入 $c$ 字符的概率恒为 $p_c$，$\sum p=1$）直到出现 $T$ 中某一个串作为子串时的 $R'$ 期望长度。

$|R|\le 10^4,n\le 100,n\times m\le 10^4$，答案模 $10^9+7$。

题解：

WLOG 不妨设 $T$ 内字符串互不相同。

将 $T$ 中所有字符串建 Trie $T'$ 及 ACAM $G$，设 $to(i,c)$ 表示 $G$ 中 $i$ 节点追加 $c$ 字符到达的点。

设 $E(x)$ 表示 $x$ 节点通过上述随机追加字符在 $G$ 中跑到达 $T'$ 叶子的期望步数。
$$\begin{cases}
E(x)=0&amp; x\text{ is leaf}
\\
E(x)=1+\sum_{c}E(to(x,c))p_c&amp; \text{otherwise}
\end{cases}$$
如果我们算出来了所有的 $E(x)$，那接下来我们就可以 $O(|R|)$ 解决问题了。

但是朴素的高斯消元复杂度为 $O(n^3m^3)$ 超时。

考虑将未知数的数量减少。将 $T'$ 上每个非叶节点 $x$ 取一个儿子作为代表。

将**不作为代表**的所有节点（必然包括根）设元，显然这样未知数数量为 $n$。

我们按 $dep_x$ 从小到大枚举未设元的节点，依次用未知数线性表示。考虑 $x$ 在 $T'$ 上的父亲 $y$，$to(y,d)=x$，则
$$
E(x)=\frac{E(y)-1-\sum_{c,c\ne d}E(to(y,c))p_c}{p_d}
$$
将 $to(y,c)$ 分成两类：一类是 $T'$ 上 $y$ 的非代表儿子，另外的 $dep\le dep_y&lt;dep_x$，已经被表示了。

然后用 $n$ 个 $T'$ 叶子的 $E$ 均为 $0$ 高斯消元 $O(n^3)$ 即可。

总复杂度 $O(n^3+n^2mk+|R|)$。

[代码](https://codeforces.com/gym/103119/submission/205971074)

# P7349 「MCOI-04」Dream and the Multiverse

记二维 bool 数组 $a_{i,j}(1\le i,j\le n)$ 表示 DAG 中 $i$ 是否能到 $j$，则询问为查矩形和，转化为四个前缀矩形和的差分形式。

考虑以 $B=64$ 位长两维分块，我们分别可以用 $O(nm/w)$ 复杂度求出纵/横压位后的 $a$ 数组的每一行/列。

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230511200212271-217499631.png)

绿色部分的和用纵向压缩求 popcount 后二维前缀和求。

蓝色用横向压缩求 popcount 后横向前缀和求。

红色用横向压缩按位与上低若干位 mask 后求 popcount 和即可。

总复杂度 $O(nm/w+qw)$。

# CF1142C U2

诈骗题。

**任何 $y=x^2+bx+c$ 型二次函数加上 $y'=-x^2$ 都是一次函数。**

将所有点 $(x,y)\to(x,y-x^2)$，问题转化成上凸包（严格）边数。

# CF1808E3 Minibuses on Venus (hard version)

本题可以在 $O(\log(n+k))$ 解决，答案为（`Z` 为 modint 类）：

```cpp
k&amp;1?Z(k).pow(n)-Z(k-1).pow(n)+Z(-1).pow(n)-Z(-1).pow(n)*__gcd((int)((n-2+k)%k),k):(Z(k).pow(n)+Z(-2).pow(n)-Z(k-2).pow(n))/2+Z(-2).pow(n-1)*__gcd((int)((n-2+k)%k),k&gt;&gt;1)
``` 

可以一行写完。/jie

* * *

我们枚举序列的和模 $k$ 的值，设为 $sum$（为什么枚举 $sum$ 而不是 Lucky 数呢？因为可以做到不重不漏）。

题意就是要求序列中存在值 $a$ 使得 $2a\equiv sum\pmod k$ 的序列数。

考虑反面，统计不存在的情况。

注意到满足条件的 $a$：
* 若 $k$ 为奇数，则 $a$ 有一种取值。
* 若 $k$ 为偶数，则 $a$ 有两种取值，两者差为 $k/2$。

显然后者比前者要难，所以我们先考虑后者，设两种取值为 $a$ 与 $a+k/2$。

答案为
$$
\sum_{sum=0}^{k-1}k^{n-1}-(x^0+x^1+\dots+x^{k-1}-x^a-x^{a+k/2})^n[x^{\equiv sum\pmod k}]
$$
后面这一坨是指数 $\bmod k$ 的循环卷积，单独拎出来求值。

用二项式定理
$$
\left\{\sum_{i=0}^{n}\binom{n}{i}(x^0+\dots+x^{k-1})^{n-i}(-x^a-x^{a+k/2})^i\right\}[x^{\equiv sum\pmod k}]
$$
考察 $x^0+\dots+x^{k-1}$ 的正整数次幂
$$
\left\{(-x^a-x^{a+k/2})^n+\sum_{i=0}^{n-1}\binom{n}{i}(x^0+\dots+x^{k-1})k^{n-i-1}(-x^a-x^{a+k/2})^i\right\}[x^{\equiv sum\pmod k}]
$$
连加变一下
$$
\left\{(-x^a-x^{a+k/2})^n+\sum_{j=0}^{k-1}x^{j-1}\sum_{i=0}^{n-1}\binom{n}{i}k^{n-i-1}(-x^a-x^{a+k/2})^i\right\}[x^{\equiv sum\pmod k}]
$$
发现后面二重求和 $x$ 的幂轮换对称了
$$
(-x^a-x^{a+k/2})^n[x^{\equiv sum\pmod k}]+\sum_{i=0}^{n-1}\binom{n}{i}k^{n-i-1}(-2)^i
$$
然后再二项式定理套回去啥的，细节就不放了，本题公式有点多。最后是这个
$$
-(-2)^{n-1}x^{an}(1+x^{k/2})[x^{\equiv sum\pmod k}]+\frac{1}{k}((k-2)^n-(-2)^n)
$$
同理求出 $k$ 为奇数的情况
$$
(-1)^nx^{an}[x^{\equiv sum\pmod k}]+\frac{1}{k}((k-1)^n-(-1)^n)
$$
这样我们就得到了 $O(k\log n)$ 的[代码](https://codeforces.com/contest/1808/submission/199708312)。

然后将循环内部的幂移出来就可以 $O(k+\log n)$，再用 $\gcd$ 快速统计代码中的 `cnt` 即可 $O(\log(n+k))$，[代码](https://codeforces.com/contest/1808/submission/199713159)。

# P8163 [JOI 2022 Final] 铁路旅行 2 (Railway Trip 2) &amp; AT_joi2022ho_d 鉄道旅行 2 (Railway Trip 2)

$O((n+q)\log n)$ 做法。

[代码](https://atcoder.jp/contests/joi2022ho/submissions/39984040) 里注释很详细了，快去看看吧。

~~那我写题解干啥~~这个倍增的思想挺套路的，记一下。

# CF1806E Tree Master

## 题意

给定一棵树，点有点权，每次查询时给出两个同深度的点，要你求出这两个点到根的路径上深度相同的点对应点权之积的和。

$n,q\le 10^5$，答案不爆 longlong。

## 记忆化

直接记忆化搜索复杂度就是对的！用 hash table 存 $f_{x,y}$ 表示 $x,y$ 两点向上的答案，这样复杂度是 $O(n\sqrt q)$ 的，证明：

考察每一层（深度）会有多少不同的状态被用到，上界有 $\min(q,x^2)$，其中 $x$ 为该层点数。由于我们要最劣，$x\le \sqrt q$，而 $\sum x_i=n,x_i\le \sqrt q$ 时 $\sum x_i^2$ 的上界是 $O(n\sqrt q)$ 的。

而哈希表常数巨大，尝试换一种方法。

当一层点数 $\le\sqrt n$，我们可以直接开数组记录下来每个点对的答案（若搜索到）。否则，我们记忆化搜索时可以暴力跳——这样的层只有 $\sqrt n$ 层，复杂度加上 $O(q\sqrt n)$。

[Code](https://codeforces.com/contest/1806/submission/198034449)

## 莫队

这种做法就很板。

将树摊平成欧拉序（每个点加入一次回溯删除一次，相当于维护搜索栈），然后序列莫队即可。

[Code](https://codeforces.com/contest/1806/submission/198374567)

## 树上撒点

树上撒点，查询前可以预处理出关键点与同深度节点之间的答案。

查询时可以暴力向上跳到关键点。

代码咕咕咕了。

# [AGC043E] Topology

WC2023 zjk 讲的。

[可能有用的链接](http://www.matrix67.com/blog/archives/3930)

更好听的题意：

墙上有 $1\le n\le 8$ 个并排的钉子，你要用绳子挂画（如图），给定 $A_0,\dots,A_{2^n-1}$ 01 序列表示保留每种子集的钉子时画会（1）不会（0）掉。判无解并构造。保证 $A_0=1$（没有钉子挂个屁）。

有绳长限制，但是用处不大。

![](https://img2023.cnblogs.com/blog/2213867/202303/2213867-20230320142852377-1455028731.png)

↑ $A=\{1,0,0,0\}$

![](https://img2023.cnblogs.com/blog/2213867/202303/2213867-20230320142921556-1199194560.png)

↑ $A=\{1,1,1,0\}$

* * *

若 $\exists T\subset S,A_T=0\cap A_S=1$ 则无解（钉子多了反而会掉？）。

否则一定有解，我们构造。

我们先判定一种挂画方式是否会掉，先从描述绳子的绕法开始。

我们从画框左边的绳头沿绳子跑到右边，考虑每个钉子竖直向上的射线，当我们从左往右（顺时针）跨过射线时记为 $X_0$，从右往左记为 $X_1$，$X$ 为钉子编号。

若上面两图左右钉子分别标为 $A,B$，则绳子分别记为 $A_0B_0$ 和 $A_0B_1A_1B_0$。

当 $X$ 钉子被移除后绳子中所有 $X_0$ 和 $X_1$ 被移除。

显然，画框掉落当且仅当在若干次操作后绳的序列变为空串，操作：将序列中相邻的 $X_0X_1$ 或 $X_1X_0$ 删除（在钉子上空左右横跳显然可以被收缩）。

比如 $A_0B_1A_1B_0$ 移除 $B$ 钉后变为 $A_0A_1$ 可以被删空，会掉落。

我们考虑子问题：如何构造 $A=\{1,1,\dots,1,0\}$，即任拿一颗钉子均会掉落，但不拿不会。

我们递归构造，若已经构造出少一颗钉子的序列 $S$，新增一颗钉子 $X$，则 $SX_1S'X_0$ 即可，$S'$ 为 $S$ reverse + flip（01 角标反转）。
$$\begin{aligned}
n=1&amp;:A_0
\\
n=2&amp;:A_0B_1A_1B_0
\\
n=3&amp;:A_0B_1A_1B_0C_1B_1A_0B_0A_1C_0
\\
...
\end{aligned}$$
正确性证明不难，同时满足了序列两头的角标均为 $0$，一会儿会用到$(*)$。

我们设 $W(S)$ 表示用 $S$ 集合里的钉子通过上述方法诱导出来的绳序列。

回到原问题，我们找到所有 $i$ 满足 $A_i=0$，将所有 $W(i)$ 字符串拼接起来即可。

为什么呢？首先由 $(*)$，拼接的序列不会收缩，其次，当且仅当钉子集合为某些 $i$ 的真子集且与另外的 $i$ 不交时画才会掉，符合题意。

当然也可以找所有极小（这里指 $A_i=0$ 且存在一种 $i$ 中少掉一颗钉子的方案 $j$ 使得 $A_j=1$）的 $i$ 拼接。

最后用绳序列还原绳的形态即可。代码不长，写得比较丑，但是思路很清晰。

# [ARC145E] Adjacent XOR

非常好工作，爱来自 ShaoJia。

设位数 $w=60$，操作次数为 $n(w+1)$。

首先转化题意，将 $B$ 变成 $A$，操作为将 $B$ 的一个前缀做异或前缀和，设 $Opt(i)$ 表示将长度为 $i$ 的前缀做异或前缀和。

判定是容易的：任意一个 $(A_i\text{xor}B_i)$ 需要可以被 $B_1,\dots,B_{i-1}$ 的线性组合表示出来（线性基）。

由于操作是前缀，所以我们 $n\to 1$ 的顺序遍历，每次只要用不超过 $(w+1)$ 次操作将该位置 $B_i$ 变成 $A_i$ 即可。

若 $B_i=A_i$ 就结束了，我们考虑 $B_i\ne A_i$ 的情况。

最后一次操作必然是 $Opt(i)$，这样需要满足 $\text{xor}_{j=1}^i B_j=A_i$。

我们构建出 $B_1,\dots,B_{i-1}$ 的线性基，然后作基变换（必然是等价的），使得存在一个下标序列 $1\le p_0&lt;p_1&lt;\dots&lt;p_{k-1}&lt;i$，且 $p_j$ 是 $B$ 序列上从左往右第一个含有第 $j$ 二进制位的数且 $\max_{j=1}^{i-1} p_j&lt;2^k$。

由于我们已经判定答案为 Yes，所以 $(A_i\text{xor}B_i)&lt;2^k$ 我们只要从高往低像线性基一样删除每一位 $1$ 即可。

每次要删掉第 $y$ 位时，我们操作 $Opt(p_y+1)$。

由于删除时 $Opt(x)$ 的 $x$ 是单调减的，所以对更高的位无影响。

最后将操作序列 reverse 输出即可。

# P7880 [Ynoi2006] rldcot

考虑询问离线，右端点扫描线，维护每个左端点的虚树不同深度个数。

维护每个点的颜色 $col_i$，初始均为 $0$。

维护一个 LCT，右端点 $r$ 加入时：

* 左端点 $\in [1,r]$ 均有点 $r$。
* 将 $r$ access，记录每次跳虚边后到达的点 $x$，若 $col_x\ne 0$，则左端点 $\in[1,col_x]$ 都会有点 $x$。最后到根的路径染色 $r$。

如何维护每次将一个左端点前缀加入一个深度？离散化深度后记录每种深度在多长的前缀里，加入时把增长的那一段 $+1$ 即可，树状数组维护。

复杂度 $O(n\log^2 n+m\log n)$，两边均有一个 $\log$ 来自树状数组，所以非常快，拿了最优解，之后被人抢走了。

# P5066 [Ynoi2014] 人人本着正义之名

写五天了，比较绝望。不过抢到了非匿名最优解（前两个匿名的说不定是 lxl 本人）2.22s。

做法就不细说了，大概就是 fhq treap 维护颜色连续段，操作大概是区间 0 段长度均 $+1$，1 段长度均 $-1$ 或反过来。

每个时刻要删除长度为 $0$ 的段。

这里说一些毒瘤题的卡常思路。

* 不要一开始就急着卡常，先看复杂度是否正确。
* 多写一些通用的调试函数，比如说输出整棵平衡树的函数（但是要注意输出对程序的影响，比如说 pushdown）。
* 先保证正确性写总体的，卡常时再改成更细节优秀的做法。
* 含随机算法（比如 treap 随机权值）调试时最好固定种子。
* 一定不要懒于写对拍和数据生成。
* 通过 `clock()` 和计数来看程序复杂度的“大头”在哪里，精准治疗。

最后：任何邪恶终将绳之以法！和蔼！

# P9089 「SvR-2」Work

每个串预处理字符串哈希，将每个串每个后缀哈希值存入散列表。

对于一个串的一个位置，以其为右端点为合法子串当且仅当左端点下标不小于某个阈值。

二分这个阈值复杂度线性对数。

对于一个串从左往右求阈值，当前位置为右端点最长合法子串一定与之前的所有合法子串呈“包含或不交”的关系否则一定可以接上更长。

所以用栈维护没被覆盖过的点，这样均摊 $O(1)$，复杂度线性。

# P9090 「SvR-2」G64

贺的官方题解。

首先特殊处理 $G_1$ 。

然后考虑从 $G_x$ 到 $G_{x+1}$ 只关心两个点选不选：$G_x$ 的根和最右那个点选不选。

![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230224182303083-1325450794.png)

设 $f_{i,st}$ ，其中 $st=(0/1,0/1)$ 表示这两个点选不选，$G_i$ 的答案。

然后考虑枚举 $G_{x+1}$ 中根节点（包括下方那个），最右边节点的状态即可列出转移式，暴力 dp 发现结果很大，无法在模意义下取 $\max$。

如果把每层 $f$ 的取值分成如下几类（记为状态 $1$ 到 $5$）：

* $f_{1,1}$ 严格最大
* $f_{0,0}$ 为最大值之一
* $f_{1,0}$ 严格最大（$f_{1,1}$可以等于 $f_{1,0}$）
* $f_{0,1}$ 严格最大（$f_{1,1}$可以等于 $f_{0,1}$）
* $f_{1,0} $ 和 $f_{0,1}$ 并列最大（$f_{1,1}$可以等于 $f_{0,1}$），

那么从第 $i$ 层到第 $i+1$ 层，发生如下变化： 

* 第 $i$ 层若为状态 $1$ ，下一层为状态 $4$。
* 第 $i$ 层若为状态 $2$ ，下一层为状态 $3$。
* 第 $i$ 层若为状态 $3$ ，下一层为状态 $2$。
* 第 $i$ 层若为状态 $4$ ，下一层为状态 $1$。
* 第 $i$ 层若为状态 $5$ ，下一层为状态 $5$。

证明不难，但是繁琐，可以跑暴力程序来尝试各种情况验证正确性。

容易发现最后一定是 $4$ ，$1$ 间循环或者 $2$ ，$3$ 间或者 $5$ 一直循环，而五种变化是均可以写出一个不带 $\max$ 的递推式的。即可矩乘。

同时根据上表也得到了了每个状态的递推式（设上一层答案为 $x$）：

* $1$ 到 $4$：$x=4x$
* $2$ 到 $3$：$x=4x+2$
* $3$ 到 $2$：$x=4x$
* $4$ 到 $1$：$x=4x+1$
* $5$ 到 $5$：$x=4x+1$ 

# CF1795G Removal Sequences

题意转化：点边均 1e5 的 DAG 无单向路径点对计数。

典难题，好像甚至没有根号做法。

转为有单向路径点对计数，考虑给每个点维护一个 bitset 表示这个点能到达的点集，这样时空均 $O(n^2/w)$。

但是这样空间爆炸，我们考虑“离线”：对每 $w$ 个点，$O(n)$ 跑出每个点能到达其中的哪些（即 $w=64$ 时用 unsigned long long 状压）这样进行 $n/w$ 轮，时间 $O(n^2/w)$，空间可看作 $O(n)$。

# P5926 [JSOI2009] 面试的考验 &amp; CF765F Souvenirs &amp; CF1793F Rebrending

区间最小差值。

我们有结论：会被任何询问当作最小差值的点对只有 $O(n\log V)$ 对。

我们现在只考虑 $i&lt;j,a_i&lt;a_j$ 的点对，将值域反过来再做一遍即可。

固定 $j$，有用的 $i$ 只有 $O(\log V)$ 个：

* 找到 $j$ 左边第一个不比 $a_j$ 小的位置 $a_i$，这对点对备选。
* 下一个备选的 $i'$ 为 $j$ 左边第一个 $a_{i'}\in [a_j,(a_i+a_j)/2]\cap \mathbb Z$。
* 一直找直到找不到满足的或者 $a_i=a_j$。

这样找的正确性证明：

考察 $a_{i'}&gt;(a_i+a_j)/2$：

![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230215104433273-1655233871.png)

红色这段一定比绿色这段优，$a_{i'}$ 无意义。

# P3665 [USACO17OPEN]Switch Grass P

Cxy 写了一个小常数双 $\log$ 做法吊打大部分单 $\log$ 线段树大常数做法，然后我稍微改进了一下变成小常数单 $\log$，抢到最优解 454ms，次优解是 5ab 994ms，可见差距。

简要题意：一个无向连通图边有边权点有颜色保证任意时刻至少有两种颜色存在单点修改颜色查询全局两异色点最短距离。$n,m\le 2\times 10^5$

首先最短距离就是两端异色的最小边权。

任意找一棵最小生成树 $T$（使用 Kruskal，之后有用），每个询问都存在答案边使得此路径在 $T$ 上。因为对于任意不在 $T$ 上的边 $(x,y)$，$x,y$ 在 $T$ 上的路径所有边权均不大于 $(x,y)$ 的边权，由于 $x,y$ 异色，所以 $T$ 上 $x,y$ 路径上必然有一条边两端异色，必然不劣。

所以我们就转化成了树上的问题，这样就可以用线段树做了，但是我们继续转化。

考虑 Kruskal 建最小生成树的过程，当前边 $(x,y)$，$x,y$ 现在不属于同个集合。

若 $x,y$ 任意一个集合中颜色不全相同，则答案一定不比 $(x,y)$ 的边权大，$(x,y)$ 这条边也就无意义了。

否则，我们可以假设 $x,y$ 集合内的点颜色分别相同。这样 $(x,y)$ 这条边可以改为两端分别连 $x,y$ 集合中的任意点。

那我们就可以将整棵 $T$ 变为答案相同的链（每次连接两个集合链的头，继续形成链）。

链还不好做？每次改变一个点时只会改变 $2$ 条边是否可取的状态，然后用两个堆维护答案即可。

[Code](https://www.luogu.com.cn/record/101283470)

# CF1790F Timofey and Black-White Tree

有 $x$ 个黑点的答案是 $O(n/x)$ 的，证明可考虑欧拉序。

所以我们每个点直接暴力向上跳，更新答案以及每个点子树内黑点的最小深度，直到我们跳的距离超过了答案。

这样复杂度是调和的。

[Code](https://codeforces.com/contest/1790/submission/191044244)

# CF1777F Comfortably Numb

## 方法一

建出 $\{a\}$ 的笛卡尔树（相同值随意选），$\{b\}$ 为 $\{a\}$ 的前缀异或和，每个节点维护其代表的区间的 $\{b\}$ 值的 01trie。

每个节点通过左右儿子 trie 启发式合并更新答案并求出本节点的 trie。

复杂度 $O(n\log n\log V)$。

01trie 合并用线段树合并可以减少常数使得跑得比方法二快。

[Code](https://codeforces.com/contest/1777/submission/190096329)

## 方法二

构建 $\{b\}$ 数组的可持久化 01 trie，这样就不用像方法一那样合并了，每个点用正反单调栈求出其作为最大值的区间，然后依然是小的去大的 trie 里查询更新答案。

复杂度相同，写起来更方便些。

[Code](https://codeforces.com/contest/1777/submission/190099649)

# P8326 [COCI2021-2022#5] Fliper

WC 讲的。

将环视为点，将板视为两侧环之间的边（可能有自环，若有一侧不是环则连向 $0$ 节点）。

接下来就是问这个新图是否存在一种边的四着色，使得除了 $0$ 节点以外，每个点相接的边四种颜色数量相同且为偶数。

欧拉回路跑几遍即可。

# P8493 [IOI2022] 数字电路

WC2023 讲了。

这个电路形成了一棵有根树，发现使得 $0$ 号门值为 1 的方案数等价于以下的方案数：

&gt; 给每一个非叶子节点选定一个重儿子（共儿子个数种选法），使得 $0$ 号节点一直走重儿子到的叶子节点权值为 1。

所以每个叶子节点的系数是可以用 dfs 算出来的，设为序列 $\{A\}$。

接下来问题就变成了：

&gt; 维护一个长度为 $m$ 的 $\{B\}$ 01 序列，操作为区间 flip。
&gt;
&gt; 查询区间 $\sum_{i=l}^r A_iB_i$。

这个可以一棵线段树轻松维护。

[Code](https://www.luogu.com.cn/record/100270043)

# P8419 [THUPC2022 决赛] riapq

最近几天好颓，三天写这道题。

拆贡献：
$$\forall x\in[l,r]
\\
([l,x]\to x)\implies([1,x]\to x)-([1,l)\to x)$$

前面部分树状数组预处理每个 $x$ 的 $[1,x]\to x$，然后操作直接分块 / 树状数组加贡献即可。

难点在后面 $[1,l)\to [l,r]$。

## O(n sqrt n) 在线做法

序列 $\sqrt n$ 分块，贡献按攻和受在序列中的地位分为：

### 整整

预处理出每个“块前缀”（共 $O(\sqrt n)$ 个）每种值的出现次数（的前缀和）。

操作直接对受的每个整块打标记，即每块维护每个块前缀对其的贡献次数。

查询的时候 $O(\sqrt n)$ 算贡献。

### 整散

操作依然用上文预处理的 $n\times \sqrt n$ 的数组，但是这部分直接暴力每个受的位置加贡献。

查询直接 $O(1)$。

### 散散

预处理块内排序位置序列。

操作直接 $O(\sqrt n)$ 列出攻的值（通过预处理的数组可以直接排好序了），然后对于受的块暴力按排序位置扫描，让那后维护指针即可直接加贡献。

查询 $O(1)$。

### 散整

这部分难，也是常数的大头。

（这部分重写过，之前写的不好）

咕咕咕。

* * *

$O(n\sqrt n)$ 交了无数发，但是常数巨大，被卡，死活调不过去。

## O(n sqrt n log n) 离线做法

咕咕咕。

$O(n\sqrt n\log n)$ 8.65s 最优解[代码](https://www.luogu.com.cn/record/102061329)。

# P5471 [NOI2019] 弹跳

感觉很妙。

朴素的 dij 建边 $O(nm)$ 条直接炸。

考虑一种延迟的手法：我们给每一个跳板新建一个节点，从跳板向这个点连边，边权为跳板时间。

当这个节点从堆中取出时，我们去给所有矩形范围内的点的 dis 更新，而且不会再更新，所以我们从平面上删掉这些点就行，这样下次就不会再遍历到她们。

这样均摊一下复杂度证明就是对的了。

# CF1768F Wonderful Jump

贺自 wds。

只能说这题太妙了，场上 tourist 都没过。

首先考虑 $O(n^2)$ 的 DP，$f_i$ 表示从 $1$ 到 $i$ 的最短路径，转移很简单。

现在要考虑把这个 DP 优化到可以接受的时间复杂度内，考虑有以下性质。

## 结论 1

存在最优方案，使得每一个跳跃 $i\to j$ 都有 $\min(a_i,a_j)&lt;\min(a_{i+1},\dots,a_{j-1})$。

证明很简单，假设存在最小值位置 $k\in(i,j)$，如果直接从 $i$ 跳到 $j$，那么代价就是 $a_k\cdot(i-j)^2$。

然而经过 $k$ 的代价是
$$a_k\cdot(k-i)^2+a_k\cdot(j-k)^2=a_k\cdot((k-i)^2+(j-k)^2)$$
显然因为对于 $a,b\ge0$，有 $(a+b)^2\ge a^2+b^2$，所以经过 $k$ 更不劣。

## 结论 2

对于一个最小值 $a_i$，一定满足他前面和后面的步长一定不会超过 $n/a_i$。

证明：

对于一个步长为 $d$ 的跳跃，我们换一种跳跃方式——每次只跳 $1$ 的距离，那么单步花费不会超过 $n$，总花费不会超过 $n\cdot d$。

然而一步跳到的花费是 $a_i\cdot d^2$。

要满足一步跳到更优，就有 $a_i\cdot d^2\le n\cdot d$，既 $d\le\frac{n}{a_i}$。

## Sol

有了以上结论我们就只要对于每个 $i$，考虑以 $a_i$ 为最小值转移既可，可以证明这样的时间复杂度是 $O(n\sqrt n)$ 的。

对于 $a_i\ge\sqrt n$，步长上限 $d=\frac n {a_i}\le\sqrt n$，所以时间复杂度不会超过 $O(n\sqrt n)$。

而对于 $a_i&lt;\sqrt n$，考虑将将同的 $a_i$ 放在一起考虑。

那么对于一个相同的 $a_i$，以他们为最小值的区间长度之和是 $O(n)$。

然而最多有 $\sqrt n$ 种数，所以时间复杂度也不会超过 $O(n\sqrt n)$。

## Code

[Link](https://codeforces.com/contest/1768/submission/188159903)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17030445.html</id>
    <title type="text">SAM &amp; exSAM-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-06T06:41:00Z</published>
    <updated>2023-01-06T06:41:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17030445.html" />
    <content type="text"># SAM

## 好 blog 的链接

[shadowice1984 的博客](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3804)

## 基础 &amp; 模板

后缀自动机（suffix automaton，SAM）。

学了 114 遍，看了 514 份代码，尝试理解了 1919810 遍 OI-wiki，终于在 2023 年 1 月 20 日彻底明白了。

基础的 $endpos,link,len$ 等等的就不再赘述了。

首先，这是一个接受子串的自动机（接受：跑自动机的时候不会 fail），所以我们的考察对象就是所有子串。

SAM 的构造算法是在线的，我们顺序依次加入字符。

以下下标从 $1$ 开始。

假设当前字符串为 $S$，长度为 $n$，接下来我们要插入字符 $c$ 在 $S$ 的末尾，设插入后为 $S'$。

若我们保持自动机不变，则某些（无、部分、全部） $S'$ 的后缀没能接受。

首先考虑 $S'$ 整个串，其必然 $endpos=\{n+1\}$，所以我们给她新建一个节点 $cur$，$len=n+1$。

当前区间为 $[1,n+1]$，考虑不断收缩左端点，直到 $endpos$ 在某一时刻突然变成了原来的真超集，设当前左端点为 $l$。

$S$ 的左端点小于 $l$ 的后缀连出边 $c$ 至 $cur$。

则 $[l,n]$ 在 $S$ 中 $endpos\supsetneq\{n\}$，而且除了 $n$ 前面至少有一个 $endpos$ 之后紧跟着 $c$。

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230120214752493-665170928.png)

（上面的子串可以部分重叠的，但是为了美观和清楚就这样画，下面的图同理）

我们如何找到这样的 $l$ 呢？在 $S$ 中整个字符串的节点不断跳 $link$（不断变成真超集且不会遗漏，类似 KMP），直到存在一个边权为 $c$ 的出边，设这个节点为 $p$。

怎么办，我们要给 $S'$ 中 $[l,n+1]$ 以及其后缀找到一个 $endpos$ 的家啊！

考虑 $p$ 的 $c$ 出边的终点 $q$，$q$ 的 $endpos$ 是 $p$ 的真子集。

若 $len(q)=len(p)+1$，代表着当 $endpos$ 收缩的时候并不会向前扩展，只会在后面跟一个 $c$：

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230120215616710-1720640577.png)

这样的话 $q$ 就是他们的家，只要在 $q$ 的 link(parent) 树上的子树所有节点的 endpos 加入一个 $n+1$ 即可（本来也就该这样），因为我们不记录每个节点的 endpos 所以直接 $link(cur)=q$。

特殊情况：一路上找不到这样的 $p$，代表着 $S$ 中不存在 $c$ 字符（否则自动机初始点就有 $c$ 的出边），则 $link(cur)=$ 自动机初始点。

否则，若 $len(q)&gt;len(q)+1$（不可能小于），这部分就有意思了。

这样的话 $q$ 就不是这些后缀的家了，因为她包含了左端点更左的子串，类似这样：

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230120221902294-564622085.png)

（除了后缀子串，每个后面有 $c$ 的前面一定要有 $a$）

（这里举了 $len(q)=len(q)+2$，把 $a$ 换成更长的相等子串 $len(q)$ 就会更大）

(后缀子串前面不可能是 $a$，考虑 $p$ 的 $endpos$ 最小性)

所以我们再新建一个节点 $clone$，差不多算是 $q$ 的镜像，复制 $q$ 的 $link$ 和转移边。

我们只要设 $len(clone)=len(p)+1$，好，我们有家了！

当然这里 $link(q)$ 设为 $clone$。

但是还有一个问题：$S$ 本来有些点通过某条边要到 $q$ 的，现在则会变成 $clone$（比如 $p$ 就会这样）。

那么是哪些呢？首先 endpos 得是 $q$ 的真超集，其次在 $S'$ 中必须走向 $clone$，说明 endpos 包含 $n+1$。

也就是说，我们从 $p$ 继续沿着 $link$ 一直走走过的点（包括 $p$ 本身）有可能本应去 $clone$ 而误入歧途去了 $q$，所以每个判断是否有边权为 $c$，出边终点为 $q$ 的边，若有，改为 $clone$。

[P3804 【模板】后缀自动机 (SAM) 未封装代码](https://www.luogu.com.cn/record/100396355)

时空复杂度线性，虽然我也不知道为什么。

记录每个 endpos 集合大小为 $1$ 的点的 endpos 位置，在 link 树上做一遍儿子 endpos 线段树合并就是每个点的 endpos 集合。

## CF700E Cool Slogans

内含求节点 endpos 线段树合并代码 $\to$ [跳转至题解](https://www.cnblogs.com/shaojia/p/17063207.html#e)

# exSAM

注：本人认为 exSAM 的实现完全可以用 SAM 替代，将多个字符串用一种没出现过的字符拼接，但是 oi-wiki 上说这样常数大。

## P6139 【模板】广义后缀自动机（广义 SAM）

## SP10570 LONGCS - Longest Common Substring

## SP1811 LCS - Longest Common Substring

## SP1812 LCS2 - Longest Common Substring II</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17062425.html</id>
    <title type="text">广义串并联图（原标题：有向图出度零一二）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-20T01:28:00Z</published>
    <updated>2023-01-20T01:28:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17062425.html" />
    <content type="text"># 2023年12月20日

[_LPF_ - 广义串并联图方法学习笔记](https://www.cnblogs.com/lpf-666/p/16602167.html)

广义串并联图的定义：对于任意 $4$ 个节点都不存在 $6$ 条两两没有公共边的路径连接这 $4$ 个节点中的每一对节点的无向连通图。

更简短地：不存在同胚于 $K_4$ 子图的无向连通图。

由于 $K_{3,3}$ 和 $K_5$ 均不满足上述条件，所以广义串并联图一定是平面图。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231220095802047-2094853245.png)

👆 $K_{3,3}$ 的 $4$ 个点和 $6$ 条路径。

树、仙人掌、仙人掌添加任意一条边，都是广义串并联图。

广义串并联图的等价定义：不断删一度点、缩二度点、叠合重边，最后是单点。

## P6790 [SNOI2020] 生成树

由于仙人掌添加任意一条边是广义串并联图，所以可以删一度点、缩二度点、叠合重边。

每条边维护 $f_x,g_x$ 分别表示这条边连通、不连通的方案数，初始每条边 $f_x=g_x=1$（是否选入生成树）。
* 删一度点，设其连的边为 $x$：$ans\times f_x\to ans$
* 缩二度点，设其连的边为 $x,y$，新边为 $z$：$f_z=f_xf_y,g_z=f_xg_y+g_xf_y$
* 叠合重边，设叠合的边为 $x,y$，新边为 $z$：$f_z=f_xg_y+g_xf_y,g_z=g_xg_y$

复杂度写的单 $\log$。

**如果要找执行 删一度点、缩二度点、叠合重边 的代码模板，必须看这份。**

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// Problem: Luogu P6790 [SNOI2020] 生成树
// Url: https://www.luogu.com.cn/problem/P6790
// T/M Limit: 1000ms 128MB
// Time: 2023-12-19 15:30:18
// Author: ShaoJia

// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef long double db;
#define fir first
#define sec second
#define pb push_back
#define eb emplace_back
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
template&lt;int P&gt;
struct mod_int{
	using Z=mod_int;
	static signed mo(signed x){return x&lt;0?x+P:x;}
	signed x;
	signed val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;signed&gt;(x_):mo(static_cast&lt;signed&gt;(x_%P))){}
	bool operator==(const Z&amp;rhs)const{return x==rhs.x;}
	bool operator!=(const Z&amp;rhs)const{return x!=rhs.x;}
	Z operator-()const{return Z(x?P-x:0);}
	Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&amp;1)res*=t;if(k&gt;&gt;=1)t*=t;}return res;}
	Z&amp;operator++(){x&lt;P-1?++x:x=0;return *this;}
	Z&amp;operator--(){x?--x:x=P-1;return *this;}
	Z operator++(signed){Z ret=x;x&lt;P-1?++x:x=0;return ret;}
	Z operator--(signed){Z ret=x;x?--x:x=P-1;return ret;}
	Z inv()const{assert(x);return pow(P-2);}
	Z&amp;operator+=(const Z&amp;rhs){(x+=rhs.x)&gt;=P&amp;&amp;(x-=P);return *this;}
	Z&amp;operator-=(const Z&amp;rhs){(x-=rhs.x)&lt;0&amp;&amp;(x+=P);return *this;}
	Z&amp;operator*=(const Z&amp;rhs){x=1ULL*x*rhs.x%P;return *this;}
	Z&amp;operator/=(const Z&amp;rhs){return *this*=rhs.inv();}
#define setO(o) friend Z operator o(const Z&amp;lhs,const Z&amp;rhs){Z res=lhs;return res o##=rhs;}
	setO(+)setO(-)setO(*)setO(/)
#undef setO
	friend istream&amp; operator&gt;&gt;(istream&amp;is,Z&amp;x){long long y;is&gt;&gt;y;x=Z(y);return is;}
	friend ostream&amp; operator&lt;&lt;(ostream&amp;os,const Z&amp;x){return os&lt;&lt;x.val();}
};
const int P=119&lt;&lt;23|1;
using Z=mod_int&lt;P&gt;;

const int N=500010;
int n,m;
Z f[N],g[N],ans=1;
map&lt;int,int&gt; e[N];
void ade(int u,int v,int x){
	if(e[u].count(v)){
		int y=e[u][v];
		tie(f[x],g[x])=make_pair(f[x]*g[y]+g[x]*f[y],g[x]*g[y]);
	}
	e[u][v]=e[v][u]=x;
}
queue&lt;int&gt; q;
void push(int u){
	if(siz(e[u])&lt;=2) q.push(u);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,1,m){
    	int u,v;
    	cin&gt;&gt;u&gt;&gt;v;
    	f[i]=g[i]=1;
    	ade(u,v,i);
    }
    rep(i,1,n) push(i);
    while(!q.empty()){
    	int u=q.front();
    	q.pop();
    	if(e[u].empty()) continue;
    	// cout&lt;&lt;u&lt;&lt;"!!!!!!!!!!!!!!!!!!!!!!!!"&lt;&lt;endl;
    	if(siz(e[u])==1){
    		auto it=e[u].begin();
    		ans*=f[it-&gt;sec];
    		e[it-&gt;fir].erase(u);
    	}else{// siz(e[u])==2
    		auto[v,x]=*e[u].begin();
    		auto[w,y]=*next(e[u].begin());
    		e[v].erase(u);
    		e[w].erase(u);
    		tie(f[x],g[x])=make_pair(f[x]*f[y],f[x]*g[y]+g[x]*f[y]);
    		ade(v,w,x);
    	}
    	for(auto[to,id]:e[u]) push(to); 
    	e[u].clear();
    	// rep(i,1,n){
    		// cout&lt;&lt;i&lt;&lt;"-------:\n";
    		// for(auto[to,id]:e[i]) cout&lt;&lt;to&lt;&lt;" "&lt;&lt;id&lt;&lt;"\n";
    	// }
    	// rep(i,1,m) cout&lt;&lt;i&lt;&lt;":"&lt;&lt;f[i]&lt;&lt;" "&lt;&lt;g[i]&lt;&lt;"\n";
    	// cout&lt;&lt;ans&lt;&lt;"\n";
    	// cout&lt;&lt;endl;
    }
    cout&lt;&lt;ans&lt;&lt;"\n";
return 0;}
/*
*/
```
&lt;/details&gt;

## P8426 [JOI Open 2022] 放学路（School Road）

有点难，稍等。

# 2023年初写的

WC2023 张隽恺（zjk）讲了他的悲惨经历，警钟长鸣。

## P8276 [USACO22OPEN] Hoof and Brain P

据 zjk 说这题好多支配树的做法是假的但是没卡，这里写的是正解。

局面定义为二元组，表示两个棋子的位置，若二元组两者相同定义为必输局面。

首先若局面中存在一个出度为 $0$ 的点，则必输，所以我们可以不断删掉出度为 $0$ 的点。

若局面中两者位置不同且存在一个出度度为 $1$ 的点（且这个出边不为自环），我们可以将这个点变成其出边的终点，发现这样输赢是等价的，所以我们就可以不断把出度为 $1$ 的点（且不为自环）缩至出边的终点，缩的时候记得合并重边。

我们可以用线段树合并维护每个点的入边来自哪里，这样上述过程可以做到 $O(m\log n)$。

这样我们得到了一个每个点要么出度 $\ge 2$ 要么形成自环的无重边有向图，通过一些分类讨论可以证明只要状态中两个点均没有被删去且不相同（指的是不在同一个缩点）则必然有解。

复杂度 $O(m\log n+q)$，并查集的 $\alpha(n)$ 当常数。

[Code](https://www.luogu.com.cn/record/100279672)

## P8495 [IOI2022] 千岛（不可提交）&amp; Loj#3835. 「IOI2022」千岛

这时 zjk IOI 就没在这道题上拿满，所以警钟长鸣。

Luogu 不可提交，因为 `std::variant&lt; ... , ... &gt;`。

以下约定若 $A,B$ 为边的有序集合，则 $A'$ 表示 $A$ 的 reverse，$AB$ 表示顺序拼接 $A,B$，$(A)=A$。

首先发现出度为 $0$ 的点是必死的（无用的），以下称连续删掉出度为 $0$ 的点直到不存在这样的点的操作为 check。

先 check 一遍。

若起点被删掉了，直接返回 NO。

否则若起点出度为 $1$，我们将起点设为出边的终点，并将原来的起点删掉（删掉时删掉所有入边，然后 check）。

重复上述两行，这样要么 NO 要么起点出度 $\ge 2$。

随意找两条起点的出边，设为 $e_0,e_1$。

沿着 $e_0$ 不断往下走（多条出边的话任意选一条），直到形成环，这样整个路径为 $\rho$ 形（$\rho$ 可能没有柄）。

设 $\rho$ 为 $r_0$，其柄为 $l_0$，环为 $c_0$。

若 $e_1$ 能不经过起点能走到 $r_0$，设这个路径为 $l_1$，经过完 $l_1$ 绕 $c_0$（是原来顺序的 rotate）的边顺序为 $c_1$。

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230119222008680-181181544.png)

则有答案 $(l_0c_0l_0')(l_1c_1'l_1')$。

否则，从 $e_1$ 开始走形成类似的 $\rho$ 形不可能和 $r_0$ 有相同边，类似地定义 $l_1,c_1$。

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230119222107981-434319444.png)

则有答案 $(l_0c_0l_0')(l_1c_1l_1')(l_0c_0'l_0')(l_1c_1'l_1')$。

[Code(Loj)](https://loj.ac/s/1678226)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17063207.html</id>
    <title type="text">CF700 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-20T12:27:00Z</published>
    <updated>2023-01-20T12:27:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17063207.html" />
    <content type="text">[TOC]

# A

数学题，一顿乱推。

# B

定根，要求两两配对共 $k$ 个 LCA 的深度和最小，直接摩尔投票法能在根解决的就根解决。

# C

要是 $S,T$ 不联通直接 $0$。

遍历割边取 $\min$ 得到割一条边的答案。

接下来就是两条边的最小割。

首先将一条边的割容量设为 inf。

设一个值 $B$，要大于所有容量之和（可能可以更小，我不好说）。

然后将每条边的容量加上 $B$，跑最大流，流量为 $F$。

若 $F\ge 3B$，则不存在两条边的最小割。

否则其最小割为 $F-2B$。

然后也可以找到是哪两条边。

[Code](https://codeforces.com/contest/700/submission/189821279)

# D

&gt; 给定一个序列 $a[1,n]$，$m$ 次询问，每次给出区间 $a[l,r]$，问区间最短二进制编码长度（即哈夫曼树），可离线。
&gt;
&gt; $n,m,\max a_i\le 10^5$

以下无脑 $n,m$ 同阶。

离线下来莫队做。

哈夫曼树不可能暴力建（$O(mn\log n)$），我们考虑按出现在区间内的次数分治。

若某值出现 $\le B$ 次，我们用一个数组记录有多少值出现次数为下标。

这样我们按出现次数从小到大合并建树，以 $O(B)$ 的复杂度建树（其实只是计算贡献，不显式建），然后变为了 $O(n/B)$ 个频次 $&gt;B$ 的子树（只要记录子树大小）。

若值出现 $&gt;B$ 次，这样不同的值只有 $n/B$ 种，结合上面传来的 $O(n/B)$ 个子树，用优先队列暴力建树复杂度 $O(n/B \log n/B)$。

$B$ 取 $\sqrt{n\log n}$，复杂度 $O(n\sqrt{n\log n})$。

[Code](https://codeforces.com/contest/700/submission/189836600)

# E

&gt; "Cool Slogans" is a cool slogan.

SAM 神仙题。

可以配合代码阅读 [Code](https://codeforces.com/contest/700/submission/190111654)。

&gt; 给定一个字符串 $S$，求最大的 $k$，使得存在字符串数组 $s_1,\dots,s_k$ 满足：
&gt; * $s_1$ 是 $S$ 的子串。
&gt; * $s_i$ 均非空。
&gt; * $s_{i+1}$ 在 $s_i$ 中至少出现了两次（可以部分重叠）。
&gt; 
&gt; $|S|\le 2\times 10^5$

建立 $S$ 的 SAM。

**结论 A：存在一个最优序列 $\{s\}$ 使得存在一个位置 $p$ 属于所有 $\{s\}$ 的 endpos。**

可以由内向外调整 $\{s\}$，细节不再赘述。

**结论 B：存在一个最优序列 $\{s\}$ 使得后一项的 endpos 是前一项的真超集。**

由结论 A 显然。

等价命题是每个 $\{s\}$ 对应到 SAM 对应的节点后后一项是前一项的祖先（不包括自己）。

**结论 C：存在一个最优序列 $\{s\}$ 使得每一项的长度都是其对应 SAM 节点的 len，即该节点的最长子串。**

假设将每个字符串直接变长成其节点 len 出现矛盾，则必然是：

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230122233448821-2088558563.png)

即 $s_{i+1}$ 溢出了 $s_i$ 的左端点。

发现 $s_i$ 可以更长（至溢出来的位置）而不会减少 endpos，与 len 矛盾。

**结论 D：若给出字符串序列 $t_1,\dots,t_m$，要求一个最长的子序列使得满足题面要求，则顺序地贪心选是可行的。**

设一个最优解的选取方案为 01 序列 $p_1,\dots,p_m$（$1$ 表示取），而贪心的方案为 $q_1,\dots,q_m$。

找到从左往右第一个不同的位，设为 $x$，则必然 $p_x=0,q_x=1$。

找到 $x$ 之后下一个 $p_y=1$，则有 $\sum_{i=1}^y q_i\ge \sum_{i=1}^y p_i$，此时假装 $q_y=1$（或者本来就是这样）（若是假装的话不计入总数）对于 $q$ 来说不优，接着转化为更小规模的子证明 $p[y,m],q[y,m]$，归纳得证。

* * *

所以，我们用线段树合并求出每个节点的 endpos。

称 $x$ 节点在 link 树上的祖先 $y$ 能够跳跃到 $x$ 当且仅当 $y$ 的最长子串中至少含有两个 $x$ 的最长子串。

不妨设根节点能跳到所有非根节点。

答案就是从根节点能跳的最多次数。

由结论 D，dfs 的时候贪心跳取 $\max$ 即为答案。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17065106.html</id>
    <title type="text">2023 跳坑-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-23T04:21:00Z</published>
    <updated>2023-01-23T04:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17065106.html" />
    <content type="text">## windows.h

在 c++17 版本后（据说），必须加在 `using namespace std;` 之前，因为 `byte` 重定义了。

## 左移 右移 &lt;&lt; &gt;&gt;

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240102185416666-1175469718.png)

所以 c++20 之前的负数左右移和有符号左移溢出是危险的。

## minmax() minmax_element()

[C++ std::minmax()、std::minmax_element()用法及代码示例
](https://vimsky.com/examples/usage/stdminmax-stdminmax_element-c-stl.html)

前者一个用法特例是代替 make_pair 让两个值排好序作为 pair。

## 一种对拍加 spj 的方法

ckr.cpp

```cpp
signed main(int argc,char**argv){ios::sync_with_stdio(false),cin.tie(nullptr);
    ifstream f1(argv[1]);
    ifstream f2(argv[2]);
    db x,y;
    while(f1&gt;&gt;x){
    	f2&gt;&gt;y;
    	if(fabs(x-y)&gt;1e-6) return 114;
    }
    cerr&lt;&lt;"YEAH\n";
return 0;}
```

run.cpp:

```cpp
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	system("g++ -std=c++17 -O2 -Wl,--stack=998244353 P6106.cpp -o 1");
	system("g++ -std=c++17 -O2 -Wl,--stack=998244353 sdt.cpp -o 2");
	system("g++ -std=c++17 -O2 -Wl,--stack=998244353 meka.cpp -o m");
	system("g++ -std=c++17 -O2 -Wl,--stack=998244353 ckr.cpp -o ckr");
	rep(i,1,10){
		system("m.exe &gt; m.in");
		system("1.exe &lt; m.in &gt; 1.out");
		system("2.exe &lt; m.in &gt; 2.out");
		if(system("ckr.exe 1.out 2.out")) break;
		cout&lt;&lt;i&lt;&lt;endl;
	}
return 0;}
```

## CF1464F My Beautiful Madness

树上点集，实现一个动态加删点，维护深度最大的点编号。

实现使用了 set，但是我是这样写的：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212140456337-388793477.png)

插入：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212140504804-1322671882.png)

删除：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212140511545-2130638236.png)

查询：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212140524610-1774276183.png)

这样在删除时 s.find 可能会找到任意一个和 z 深度相同的点，所以删除的不一定是 z 这个点，就出锅了。

可以改成 `multiset&lt;pair&lt;int,int&gt;&gt;` 的写法或者把比较函数写成：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212140711097-1436579772.png)

## CF1850C Word on the Paper

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230722190754442-7284452.png)

## CF833C Ever-Hungry Krakozyabra

排序 `long long` 不要用 `greater&lt;int&gt;()`。

## P7349 「MCOI-04」Dream and the Multiverse

左移右移位运算注意 UB。

[资料](https://zh.cppreference.com/w/cpp/language/operator_arithmetic)

**任何情况下，如果右操作数的值为负或大于等于提升后左操作数中的位数，那么行为未定义。**

## uniform_int_distribution

可以用流输入输出，具体参照 [cppreference](https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/operator_ltltgtgt)

```cpp
mt19937 rgen(time(0)+size_t(new(char)));
#define uid uniform_int_distribution
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	uid&lt;int&gt; R;
	cin&gt;&gt;R;
	cout&lt;&lt;R&lt;&lt;"\n";
	rep(i,0,10) cout&lt;&lt;R(rgen)&lt;&lt;"\n";
return 0;}
```

输入：

```text
114 514
```

可能的输出：

```text
114 514
469
458
239
127
456
289
161
354
349
374
491
```

## raw string

格式：

```cpp
string s=R"(114
514
1919)";
```

[看这个](https://www.luogu.com.cn/record/106074710)

## CF963D Frequency of String

1e5 - 3e7 前向星 2700ms，vector 300ms，说明跳表慢得一批。

## 自定义哈希

```cpp
struct custom_hash {
    size_t operator()(const vector&lt;int&gt; &amp;x)const {//一种 hash 方式
        size_t res=0;
        for(int i:x) res^=i;
        return res;
    }
};
unordered_map&lt;vector&lt;int&gt;,int,custom_hash&gt; map;
__gnu_pbds::gp_hash_table&lt;vector&lt;int&gt;,int,custom_hash&gt; hash_table;
```

## 调试时

不要偷懒写 `g++ -std=c++14 1.cpp -o 1`，这样可能会爆栈（而且很难调出来）。

`g++ -std=c++14 -O2 -Wl,--stack=998244353 1.cpp -o 1`。

## CF700E Cool Slogans

把 trie 当线段树查询区间时出现的脑残问题。

将一个数 $x$ 的末 $y$ 位赋为 $1$：`x|((1&lt;&lt;y)-1)`。

结果我写成了 `(x|(1&lt;&lt;y))-1`。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17073111.html</id>
    <title type="text">Stoer-Wagner 无向图最小割-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-29T08:40:00Z</published>
    <updated>2023-01-29T08:40:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17073111.html" />
    <content type="text">SW是我上午三维设为思维死亡稍微失误

在 $O(nm+n^2\log n)$（一般看作 $O(n^3)$，我也直接按这个写了）时间内解决无向连通图的无源汇最小割问题。

每次将当前图中的任意两个点做 $S-T$ 割，然后将 $S,T$ 缩点，$n-1$ 次操作后将割取 $\min$ 即为答案。

$S,T$ 缩点方式：将 $w(S,i)+w(T,i)$ 作为缩点到 $i$ 的边权。

$S,T$ 做割求出了 $S,T$ 不在同一边的最小割，递归求出了在同一边（因为缩点）的最小割，这样涵盖了所有可能的最小割。

$S,T$ 在原图中是任意的。若给定了 $S,T$，则单次 $S-T$ 割时间复杂度为 $O(n^2m)$（网络流）。

考虑以下算法（初始 $A=\varnothing$）：

1. 在图中找到权值最大（权值为这个点与 $A$ 中点连边边权和）且不在 $A$ 中的点 $x$（若有多个则任意）。
2. 将 $x$ 加入 $A$，并更新权值。
3. 重复上述步骤直到 $A$ 为点全集。

我们选定 $S,T$ 分别为最后第二、第一个入 $A$ 集合的点。

可以证明 $S-T$ 割是平凡的：即 $T$ 点相邻的所有边。$(*)$

所以单次 $S-T$ 割的求解是 $O(n^2)$ 的，总复杂度 $O(n^3)$。

$(*)$ 的证明：

我们证明任意割 $C$ 都不小于我们求出来的割。

不妨设入 $A$ 的顺序是 $1,2,\dots,n$，则 $S=n-1,T=n$。

我们称一个点 $x$ 是跨越点当 $x$ 和 $x-1$ 在割 $C$ 的异侧（点 $1$ 不是跨越点）。

我们记 $[A,B]$ 表示 $A,B$ 之间的边集（即分割 $A,B$ 的割），$P_i$ 为点集 $\{1,\dots,i\}$。

归纳证明任意跨越点 $x$ 均有 $|[P_{x-1},x]|\le |C_x|$，其中 $C_x$ 是 $P_x$ 对 $C$ 的诱导子图，$|\dots|$ 表示边权和（割的大小）。

找到第一个跨越点 $u$，由于 $P_{u-1}$ 均属于 $u$ 的异侧，所以 $|[P_{u-1},u]|=|C_u|$。

若我们对点 $u$ 证明了结论，找到 $u$ 之后的下一个跨越点 $v$。

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230129181558495-153786071.png)

由于 $u$ 加入比 $v$ 早，所以
$$
|[P_{u-1},v]|&lt;|[P_{u-1},u]|
$$
由跨越点的定义和 $v$ 的由来，$P_{v-1}/P_{u-1}$ 里的点都和 $v$ 异侧（所以被 $C_v$ 包含），且 $[P_{v-1}/P_{u-1},v]$ 不在 $C_u$ 中，再说 $C_u\subseteq C_v$：
$$
|C_u|+|[P_{v-1}/P_{u-1},v]|\le |C_v|
$$
所以：
$$\begin{aligned}
&amp;|[P_{v-1},v]|
\\=&amp;|[P_{v-1}/P_{u-1},v]|+|[P_{u-1},v]|
\\ \le &amp;|C_v|-|C_u|+|[P_{u-1},v]|
\\=&amp;|C_v|-(|C_u|-|[P_{u-1},v]|)
\\ \le &amp;|C_v|
\end{aligned}$$
归纳得证。

由于 $C$ 是 $S,T$ 割且 $S=T-1$，所以 $T$ 为跨越点，所以我们求出来的割 $|[P_{n-1},n]|\le C$。$\blacksquare$

* * *

P5632 【模板】Stoer-Wagner算法

[Code](https://www.luogu.com.cn/record/100763894)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17078739.html</id>
    <title type="text">CF1787 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-01-31T05:57:00Z</published>
    <updated>2023-01-31T05:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17078739.html" />
    <content type="text"># E

场上胡乱猜的结论，然后就过了，我都不敢相信。

构造集合数最多的方案，若多了将 $3$ 个合并成 $1$ 个即可。

将每两个异或为 $x$ 的数对放入集合，若可以则将 $x$ 单独成一个集合，剩下的成一个集合。

"This would be optimal."

这里翻译一下官方证明：

设 $B$ 是 $x$ 的最高位，$M$ 是 $1,\dots,n$ 中第 $B$ 位为 $1$ 的数的个数。

显然最多的集合数一定不大于 $M$，原因即为 $M$ 的定义。

我们的构造中统计入 $M$ 的每个数都会和比她小的一个数配对（或者自己就是 $x$，自成一集合），所以取到最大值，得证。

# F

场上写复杂了。

轻松抢到最优解 OvO：

![](https://img2023.cnblogs.com/blog/2213867/202301/2213867-20230131135756640-1971974592.png)

其实就是让我们初始排列环的个数最少。考察环长集合，每一次操作都会讲所有偶环长裂变成两个一半大小的环，奇数则不会裂变。

所以若 $k&gt;\log n$ 且仍存在偶环则无解。

那么反着做就是合并，我们可以轻松合并（或判得无解）所有偶环，以及贪心地多合并奇环，这样就得到了初始的环长集合。

至于构造，我们初始随意构造合法环长集合的排列，然后用快速幂 + dfs 求出 $k$ 次操作后的结果。

然后将这个结果和题目给的序列进行各个环的缝合，得到点标号的置换，然后输出即可。

[代码](https://codeforces.com/contest/1787/submission/191337664) 好写的，卡常用了前向星和 FastIO。

# G

有 BFS 序 + 线段树 的做法，但是有点套路，所以讲这种官方 sol。

首先不构成链的颜色直接判掉。

我们有两种暴力做法：

* 修改时每个点暴力修改经过她的链是否合法，被菊花图卡掉。
* 询问时每条链暴力判断是否有非法点，被 $n-1$ 条链的图卡掉。

所以我们匀一下，定义每个链的代表点为其 LCA。

当修改一个点的状态时，会修改所有代表的链的贡献，和她到父亲这条边所属的链的贡献。

所以每个点存一个堆，表示其代表的链的贡献集合，然后全局开一个堆，存每个点的贡献。

复杂度线性对数。

[Code](https://codeforces.com/contest/1787/submission/191335065)

# H

在路上了。

# I

可能永远在路上了。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17081736.html</id>
    <title type="text">自计数序列 self-counting sequence-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-01T02:22:00Z</published>
    <updated>2023-02-01T02:22:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17081736.html" />
    <content type="text">[OEIS](http://oeis.org/A349595)

简单说就是入桶等于自身的序列（下标 $0,\dots,(n-1)$）（易证自计数序列入桶不会越界）。

通过暴力枚举，得到 $n\le 6$ 的自计数序列只有：
$$
\{1,2,1,0\},\{2,0,2,0\},\{2,1,2,0,0\}
$$
我们证明对于所有 $n\ge 7$，自计数序列存在且仅存在这一种：
$$
\{(n-4),2,1,0,\dots,0,1,0,0,0\}
$$
举例 $n=7$：
$$
\{3,2,1,1,0,0,0\}
$$
$n=15$：
$$
\{11,2,1,0,0,0,0,0,0,0,0,1,0,0,0\}
$$

证明：

设自计数序列为 $a_0,\dots,a_{n-1}$，易证 $a_0\ne 0$，首先由于入桶不越界，得到
$$
\sum_{i=0}^{n-1} a_i=n
$$
即
$$
\sum_{i=0}^{n-1} (a_i-1)=0
$$
将下标划分为三个集合：$\{0\},S,T$ 其中 $S$ 为 $a
_i=0$ 的下标 $i$ 集合。
$$
(a_0-1)-|S|+\sum_{i\in T}(a_i-1)=0
$$
由定义 $a_0=|S|$，得：
$$
\sum_{i\in T}(a_i-1)=1
$$
由于 $T$ 中 $i$ 的 $a_i-1$ 均非负，所以 $T$ 中有且仅有一个 $a_i=2$，设该下标为 $x$，剩余 $a_i=1$。

显然 $x\in\{1,2\}$（若 $\ge 3$ 则没有足够多的值入这个桶）。若 $x=2$，则 $a_0=2$，则 $a_1=n-4\ge 3$，矛盾，所以 $x=1$。

所以 $a_1=2,a_2=1,a_0=n-1-a_1-a_2=n-4,a_{a_0}=a_{n-4}=1$，剩余的值均为 $0$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17093966.html</id>
    <title type="text">[USACO23Jan] 部分题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-05T13:16:00Z</published>
    <updated>2023-02-05T13:16:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17093966.html" />
    <content type="text">![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230205205221667-1002694841.png)

# Ag

## Find and Replace

细节爆表。

首先，若 $S=T$ 直接输出 $0$，这个特判是阴险的。

否则，若 $T$ 包含了字符全集，由于 $S\ne T$，我们至少得动一步有用的，但是动一步必然会将字符集减少，所以输出 $-1$。

若 $S$ 中相同字符变为了不同字符，输出 $-1$。

接下来一定有解，我们先假设让每个没有出现的字符保持原来的字符。

我们将相同的字符合并，这样变成了一张 $52$ 个点的内向基环树森林（基环可以是自环），初始时每个点上有一枚棋子，每次操作可以将一个点上的所有棋子移到其出边指向的点，求每个棋子移到初始位置出边指向的点的最小操作次数。

先将非纯环的基环树解决了，操作次数是其点集大小（其实也是边集大小）。

具体地，我们找到环上有子树的其中一个点 $x$，环上 $y$ 指向 $x$，这样我们让 $y$ 中的棋子先移到 $x$ 子树任意一个儿子，这样这个儿子操作时就会顺带将 $y$ 带到 $x$，然后再点数 $-1$ 次树上操作即可。

由于 $T$ 不是全集，所以一定有非纯环，所以一定有操作完后点上没有棋子的点，我们只要一个，设为 $p$。

对于每一个纯环，用 $p$ 作为临时变量将这个序列 rotate 一下，次数为点数 $+1$。

[Code](https://www.luogu.com.cn/record/101532577)

# Au

## Find and Replace

这种字符串变换后长度巨大然后问子串的我真的要好好学学。

我们可以求出每种字符经过操作序列的每个后缀后的长度（与 $10^{18}$ 取 $\min$，因为再大也用不到）。

接着我们就从第一个操作之前为 `'a'` 开始递归，每次只递归到会取到值的子树。

相当于可持久化线段树状物，子树链接共用。

但是这样复杂度爆了，因为深度和宽度可以同时达到 $10^5$ 级别。

发现均摊的问题出现在单个儿子的节点上，所以我们线段树缩链：每个节点预处理出不断走单子树的点到达的地方，递归的时候直接跳到那里。

这样复杂度是 $O(26n)$。

[Code](https://www.luogu.com.cn/record/101532676)，yzc 说我这种写法不够高明，自我感觉还行。~~能过就行~~

## Moo Route G

其实我是秒切的（因为 Ag 有弱化版我正好用了能扩展的做法），但是感觉很妙就写一下。

首先 $A$ 中肯定都是偶数，所以我们都 $/2$。

观察到每一个合法的 LR 序列对应一个“平躺”在数轴上的树，其中树每个深度的边的个数正好是 $A$ 中的对应项。

![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230205212940503-2115404257.png)

注意这里是“树”改变平躺顺序不算同构。举例：这两棵树不是同构的：

![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230205213115759-1453173983.png)

因为根的儿子换了上下顺序。

而让 LR 序列转弯次数最少，等价于这棵树的叶子数最少。

不难证明这等价于每层边（设边数为 $y$，则右侧点数也为 $y$，设左侧点数为 $x$）：

* 若 $x&lt;y$，则 $x$ 个点都至少有一个儿子。
* 若 $x\ge y$，则 $x$ 个点都至多有一个儿子。

所以每层组合数，每一层乘起来即可。

[Code](https://www.luogu.com.cn/record/101532708) 非常短。

# Pt

## Tractor Paths

对于询问 $l,r$，我们只可能经过 $[l,r]$ 编号的区间。

虚构一个 DAG 表示 $[l,r]$ 区间作为点，向右跳为有向边。

取出这个 DAG 的 $S\to T$ 最短路子图，每个点在最短路的位置（即是第几个经过的）是固定的。

从 $l$ 开始向右贪心（每次跳最右的有交区间）跳，这样我们就得到了最小步数 $len$。

遍历 $i$ 从 $0$ 到 $len$，DAG 中每一层的点编号一定是连续的一段区间，最大为 $l$ 贪心跳 $i$ 次的编号，最小为 $r$ 贪心向左跳 $len-i$ 次的编号。

中间有多少关键节点直接前缀和相减即可。

用倍增简单维护。

[Code](https://www.luogu.com.cn/record/101532740)

## Mana Collection

估计是本场最难。

设**传递闭包后**边权为 $w(i,j)$，圣水采集器（点）每秒生产圣水量为 $a_i$，首先正着做不好做，考虑倒着跑。

转移需要的条件是那些倒着跑没跑到但接下来要跑到的点的权值和。

所以我们 DP 式子是 $f_{i,j}$ 保证 $j\in i$ 表示 $i$ 集合还没经过，现在在 $j$ 点的最小浪费圣水量。
$$
f_{2^j,j}=0
$$
$$
A(i)=\sum_{j\in i}a_j
$$
$$
f_{i,j}=\min_{k\in(i-2^j)}(f_{i-2^j,k}+A(i-2^j)\times w(j,k))
$$
这样我们就得到了每个点作为终点，每个点集合被经过的最小浪费圣水量。

发现这样我们不用操心那些时间不够但被我们计算到结果里的圣水采集器，因为其贡献为负，必然被最优解盖住。

离线询问，发现对于同一个终点，问题转化为多条直线（代表 $f_{i,j}$ 等）求某一点（询问给出的时间）的最大值。

每个终点用斜率优化那套求凸壳，然后将询问排序求解即可。

[Code](https://www.luogu.com.cn/record/101532751)

## Subtree Activation

[看这篇吧，我懒得写](https://www.luogu.com.cn/blog/Ecrade/usaco23jan-subtree-activation-p-ti-xie)

[Code](https://www.luogu.com.cn/record/101532793)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17114835.html</id>
    <title type="text">【一句话证明】费马平方和定理：奇素数能表示为两平方和当且仅当模4余1-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-12T14:02:00Z</published>
    <updated>2023-02-12T14:02:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17114835.html" />
    <content type="text"># 链接

[Bilibili 视频](https://www.bilibili.com/video/BV1ix411W7KV/)

[正整数的情况](https://www.cnblogs.com/shaojia/p/16546961.html)

# 一句话证明

必要性是显然的：一个平方数模 $4$ 余 $0$ 或 $1$，所以模 $4$ 余 $3$ 的数不可能拆成两平方和。

充分性：

[D.Zagier](https://baike.baidu.com/item/%E5%94%90%C2%B7%E6%9F%A5%E5%90%89%E5%B0%94) 的一句话证明（设这个模 $4$ 余 $1$ 的素数为 $p$）：

&gt; 定义在有限集 $S=\{(x,y,z)\in\mathbb N^3:x^2+4yz=p\}$ 上的[对合](https://baike.baidu.com/item/%E5%AF%B9%E5%90%88/1059963)
&gt; $$
&gt; (x,y,z)\to \begin{cases}
&gt; (x+2z,z,y-x-z)&amp; ,x&lt;y-z
&gt; \\
&gt; (2y-x,y,x-y+z)&amp; ,y-z&lt;x&lt;2y
&gt; \\
&gt; (x-2y,x-y+z,y)&amp; ,2y&lt;x
&gt; \end{cases}
&gt; $$
&gt; 恰好有一个不动点，故 $|S|$ 为奇数，因此对合 $(x,y,z)\to (x,z,y)$ 同样也有一个不动点。

# 解析

设上面这个映射为 $f$，按上述映射分类将 $S$ 划分成三个子集分别为 $A_0,A_1,A_2$。

由于 $p$ 是素数，所以上面用了四个小于号（表示 $x$ 取不到 $y-z$ 或 $2y$，证明不难）是合法的。

不难验证 $A_0,A_1,A_2$ 通过 $f$ 分别映射到 $A_2,A_1,A_0$，所以不动点不存在于 $A_0,A_2$。

将 $A_1$ 按 $x$ 是否等于 $y$ 划分成 $B_0(x=y),B_1(x\ne y)$。

考察 $B_1$ 中 $x$ 的变化，可知 $B_1$ 中不存在不动点。

$B_0$ 中的元素要满足 $x^2+4xz=x(x+4z)=p$，由于 $p$ 是模 $4$ 余 $1$ 的素数，得 $B_0=\{(1,1,(p-1)/4\}$，即 $|S|$ 唯一一个不动点。

不动点有且仅有一个可以得到 $|S|$ 为奇数（其他都两两匹配了），即 $x^2+4yz=p$ 的非负整数解有奇数个。

而若 $(x,y,z)$ 为解，则 $(x,z,y)$ 也为解（本质是 $S$ 集合上另一种对合），而 $|S|$ 为奇数，得到这个对合也有不动点，而 $(x,y,z)\to (x,z,y)$ 不动等价于 $y=z$。
$$
x^2+4y^2=p\implies x^2+(2y)^2=p\quad \blacksquare
$$

# 课后练习

为什么将奇素数变为奇数就不再适用？（比如说 $21$ 就不能表示为两平方和）

尝试用对合的方法证明正整数为完全平方数当且仅当其因子个数为奇数。

哪些正整数能表示为两平方和？（详见顶部链接）

CF113C Double Happiness</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17126064.html</id>
    <title type="text">鞅和停时定理-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-16T03:18:00Z</published>
    <updated>2023-02-16T03:18:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17126064.html" />
    <content type="text">[gxy001 鞅与停时定理学习笔记](https://www.luogu.com.cn/blog/gxy001/yang-yu-ting-shi-ding-li-xue-xi-bi-ji) ⭐

[赌徒的长征(3)——鞅的停时定理](https://zhuanlan.zhihu.com/p/20280190)

鞅和停时定理的基础内容就不写了，毕竟我是 OIer。

下文很可能不严谨，但是我是 OIer。

这个定理能解决一类这样的问题：给你一个局面、操作规则和终止局面集合，问你从这个局面不断操作直到终止局面的期望操作数。

对于每个局面 $x$，构造势能函数 $\Phi(x)$，使得：

* 设局面 $x$ 操作一次后的局面随机变量为 $X$，满足 $E(\Phi(X))=\Phi(x)-1$。
* 设终止局面集合为 $T$，终止势能为 $\varphi$，满足
$\forall x\in T,y\in T\text{ s.t. }\Phi(x)=\varphi\ne \Phi(y)$
即可以通过势能的比较判断是否是终止态。

那么对于任意局面 $x$，其通过操作到终止态的期望操作数为 $\Phi(x)-\varphi$。

例题：

CF1025G Company Acquisitions

[ABC249Ex] Dye Color

↑ 这道在 23.02.16 被 wn 拿来当模拟赛出了，我和 cxny 场上推出式子过了 ovo。

&lt;details&gt;
&lt;summary&gt;草稿纸效果图&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202302/2213867-20230216222600565-774914393.jpg)
&lt;/details&gt;

CF850F Rainbow Balls

↑↓ 这两道神似

P5516 [MtOI2019]小铃的烦恼

CF1349D Slime and Biscuits（没补）

CF1479E School Clubs（没补）

[ABC270Ex] add 1

↑ 这道题可能没别的题关系那么大</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17138127.html</id>
    <title type="text">P NP NPC NPH-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-20T09:04:00Z</published>
    <updated>2023-02-20T09:04:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17138127.html" />
    <content type="text">[Matrix67-什么是P问题、NP问题和NPC问题](http://www.matrix67.com/blog/archives/105)

# P(Polynomial)

可以在多项式复杂度内解决的判定性问题。

# NP(Non-deterministic Polynomial)

可以多项式复杂度验证一个解的问题。

看了 matrix67 的文章，这里是我的理解：

```text
in.txt
run.exe
out.txt
proof.txt
checker.exe
首先输入 in.txt 给 run.exe 跑出来判定结果 out.txt 和证明 proof.txt
若 out.txt 为 Yes，输入 in.txt 和 proof.txt 给 checker.exe
```

若 checker 能在多项式复杂度内通过 in 和 proof 验证 run 给出的 "Yes" 是否属实，则称 in 这个问题为 NP 问题。

NP 中的 N 表示非确定，意思是若你 RP 极好且问题有解（爆搜不回溯就得到解），则可以在多项式复杂度内得到该解。

显然 P $\subseteq$ NP。

但是 P=NP 吗？仍然是未解之谜。

# NPC(NP-complete)&amp;NPH(NP-hard)

基于比较的排序最快是 $O(n\log n)$ 的，那么我们就一定可以在 $O(n\log n)$ 甚至更短的时间内排序 01 序列。

上面这句话就是问题的约化，也就是归约（Reducibility）。

简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A。这有一个重要的直观意义：B 的时间复杂度高于或者等于 A 的时间复杂度。也就是说，问题 A 不比问题 B 难。

约化具有传递性。

当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。

NPH 指那些可以被全体 NP 问题归约到的问题集合，而 NPC 指 NPH 中 NP 问题的集合。

由定义，NPC 问题可以相互归约，所以是相互“等价”的。

若 NPC 问题中的任意一个被证明是 P 问题，则 P=NP。

但是现在人们认为是不太可能的：图的哈密顿回路判定等一系列重难问题是 NPC。

第一个被发现的 NPC 问题，NPC 的鼻祖：逻辑电路问题。

给你一个逻辑电路（And Or Xor Not），输出只有一个，问你是否存在一种输入使输出为 True。

逻辑电路问题属于 NPC 问题。这是有严格证明的。它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它（不要以为 NP 问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0 和 1 的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为 True 的一个输入（即一个可行解）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17138688.html</id>
    <title type="text">可持久化-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-20T11:40:00Z</published>
    <updated>2023-02-20T11:40:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17138688.html" />
    <content type="text"># P3919 【模板】可持久化线段树 1（可持久化数组）&amp; P3834 【模板】可持久化线段树 2

略。

# P3402 可持久化并查集

RT。

# P3835 【模板】可持久化平衡树 &amp; P5055 【模板】可持久化文艺平衡树

RT，均使用 fhq treap 实现持久化，注意下传标记时要新建节点。

# P8263 [Ynoi Easy Round 2020] TEST_8

可持久化 Leafy Tree。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17161308.html</id>
    <title type="text">可并堆-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-02-27T09:49:00Z</published>
    <updated>2023-02-27T09:49:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17161308.html" />
    <content type="text">[OIwiki](https://oi-wiki.org/ds/heap/)

[P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)

# 左偏树

[record](https://www.luogu.com.cn/record/73862971)

# 配对堆

[record](https://www.luogu.com.cn/record/77517948)

# 斜堆

[record](https://www.luogu.com.cn/record/103188838)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17167209.html</id>
    <title type="text">CF1796 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-01T02:31:00Z</published>
    <updated>2023-03-01T02:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17167209.html" />
    <content type="text"># A

FB 序列有循环节，$k$ 很小，随便判一下是否是子串即可（`s.find(t)!=s.npos`）。

# B

YES 当且仅当 $s,t$ 首字母或尾字母相同或存在长度为 $2$ 的公共子串，随便判均可。

# C

最大大小为 $l$ 倍增 $\le r$ 的个数。

个数可以按 $\lfloor r/l\rfloor$ 整除分块，预处理出每种商的答案。

但是这样复杂了，注意到 $3^2&gt;2^3$，所以我们至多在倍增中将一个 $2$ 换成 $3$，所以每次询问可以做到 $O(1)$。

# D

小清新 DP，$f_{i,j}$ 表示长度为 $i$ 的前缀操作 $j$ 次的最大后缀和。

# E

线性复杂度抢到最优解，108ms，DP 王子 copy 我代码后改快读啥的和我抢最优，多少沾点【】。

若定根，则答案可以用“短链剖分”线性求。[暴力代码](https://codeforces.com/contest/1796/submission/195407937)

不定根就二次扫描即可。[最优解](https://codeforces.com/contest/1796/submission/195410794)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17174343.html</id>
    <title type="text">SMAWK 算法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-03T00:54:00Z</published>
    <updated>2023-03-03T00:54:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17174343.html" />
    <content type="text">[没来及看但是可能有用的 blog](https://www.cnblogs.com/p-b-p-b/p/15054179.html)

[CF1423M Milutin's Plums](https://www.luogu.com.cn/problem/CF1423M)

完全单调矩阵：任意 $1\le u&lt; d\le n,1\le l&lt; r\le m$，若 $A_{u,l}&gt;A_{u,r}$ 则 $A_{d,l}&gt;A_{d,r}$。

也就是说，把这个矩阵看作 $n$ 个长度为 $m$ 的数组，则从上到下逆序对只增不减。

&gt; 有一个 $n\times m$ 的完全单调矩阵，你可以问 $4(n+m)$ 次点值，求出矩阵最小值。
&gt;
&gt; $n,m\le 10^6$，做法不基于值域。

`reduce(A)`：

我们称一个位置为“冗余”的当且仅当其不可能为该行最小值位置（多个取最左）。

维护一个变量 $k$ 初始为 $1$，表示 $A$ 矩阵左上角 $k\times k$ 方形的上三角（不包括对角线）均冗余。

重复以下步骤直到不存在第 $k+1$ 列：

1. 查询 $A_{k,k}$ 和 $A_{k,k+1}$ 的值。
2. 若 $A_{k,k}&gt;A_{k,k+1}$ 则 $\forall d\ge k,A_{d,k}&gt;A_{d,k+1}$，而且 $\forall d&lt;k,A_{d,k}$ 均为冗余，我们删掉第 $k$ 列，$\max(k-1,1)\to k$。回到步骤 1。
3. 若 $k=n$，则 $\forall d,A_{d,k}\le A_{d,k+1}$，删除第 $k+1$ 列。回到步骤 1。
4. 此时 $\forall d\le k,A_{d,k}\le A_{d,k+1}$，$\forall d\le k,A_{d,k+1}$ 冗余，$k+1\to k$，回到步骤 1。

可以让 $A$ 矩阵变为等价的、列数不大于行数的矩阵。

`SMAWK(A)`：

将 $A$ 所有行按奇偶分，奇 $A_1$，偶 $A_2$。

当我们求出 $A_2$ 的每行最小值位置后，可以暴力求最小值 $O(n+m)$ 次询问得出 $A_1$ 每行最小值位置。

将 $A_2$ 执行 `reduce`，则变成一个规模为原来 $1/2$ 的子问题，边界 $n=1$ 时暴力找最小值。

做完了。

实现时可用链表等数据结构。

[Code](https://codeforces.com/contest/1423/submission/195761014)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17182974.html</id>
    <title type="text">2023 NOI 春季测试 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-06T02:53:00Z</published>
    <updated>2023-03-06T02:53:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17182974.html" />
    <content type="text">大概是 普及+/提高- 难度的（？）

# 涂色游戏

每行每列记录最后涂色的时间和颜色即可。

# 幂次

$k=1$ 直接输出 $n$。

$k\ge 3$ 时

# 圣诞树

# 密码锁</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17185774.html</id>
    <title type="text">ARC141 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-06T14:29:00Z</published>
    <updated>2023-03-06T14:29:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17185774.html" />
    <content type="text">老规矩（？）挂张图：

![](https://img2023.cnblogs.com/blog/2213867/202303/2213867-20230313214547464-237262689.png)

# A

若答案位数和原数相同，则可以枚举循环节长度后二分循环节的值（反正随便做）。

否则答案一定是原数位数少一的 $999\dots 99$。

# B

$n$ 上限是假的，最大 $60$，$\{A\}$ 合法的充要条件是 $\forall i,A_i$ 比 $A_{i-1}$ 二进制最高位高。

然后 DP 一下就行。

# C

cxy 此题卡了一上午，警钟长鸣。

以下设 $n$ 为长度，即题面中的 $2N$。

先考虑已知 $S$ 怎么求出 $P,Q$。

![](https://img2023.cnblogs.com/blog/2213867/202303/2213867-20230306223139285-1547284988.png)

画出折线图。

$P$ 先贪心 $1\to n$ 选取，直到折线低于地平线。

低于时左右括号交替选，选的时候贪心选前面的：

![](https://img2023.cnblogs.com/blog/2213867/202303/2213867-20230306223350498-87002104.png)

发现这一段得到的 $P$ 一定形成 $()()()\dots()$ 这样相邻配对括号。

直到再次高于地平线。

$Q$ 同理，贪心 $n\to 1$，高于地平线要上述处理。

易得 $S$ 中位置 $i$ 高于地平线时 $P_i=i,Q_i\ne n+1-i$，反之 $P_i\ne i,Q_i=n+1-i$。

高于地平线 $S$ 的段可以由 $Q$ 的相邻配对括号求出，同理低于的由 $P$ 得出。

得出的 $S$ 再跑一边构造 $P,Q$，check 是否相同。

复杂度线性。

# D

值域是特殊的 $2m$，说明有用。

将 $1\sim 2m$ 都分解成 $a\times 2^b(a\text{ is odd})$ 的形式，容易发现 $a$ 相同的值至多选一个，所以 good set 最大只能是 $m$。

所以设奇数 $x$ 作为 $a$ 时的值为 $x\times 2^{p_x}$。

good set 要满足 $\forall x|y,p_x&gt;p_y$。

因此我们可以调和时间求出每个奇数 $x$ 的 $p_x$ 的上下界 $L_x,R_x$。

然后就行了，$x\times 2^y(L_x\le y\le R_x)$ 都有可能在 good set 里，因为你可以将 $x'&lt;x$ 的设为 $x'\times 2^{R_{x'}}$，将 $x'&gt;x$ 的设为 $x'\times 2^{L_{x'}}$，这样一定满足。

# E

设 $Z_n$ 表示模 $n$ 同余系。

将点排在二维平面上 $Z_n^2$。

然后进行一个斜向变换 $(x,y)\to (x,(y-x)\bmod n)$，这样连边操作变成三个数 $x,y,z\in Z_n$，$\forall i\in Z_n,$ 将 $(x,i)$ 和 $(y,(i+z)\bmod n)$ 连边。

注意 $x=y$ 是可能的。

带权并查集维护每行连边方式，并查集根向自己错位连。

连通块随便维护一下即可。

复杂度 $O(n\alpha(n))$。

# F

好题，但是实现需要清楚的头脑。

设 $f(X,Y)$ 表示字符串 $X$ 通过不断删除 $Y$ 集合中的作为 $X$ 子串的字符串直到无法操作能得到的最终串集合。

如 $f(\mathtt{"ABC"},\{\mathtt{"AB"},\mathtt{"BC"}\})=\{\mathtt{"A"},\mathtt{"C"}\}$。

设 $f(X)=f(X,S)$。

找到 $A\in S$ 使得 $f(A,S/A)\ne \{A\}$ 直到找不到为止：
* 若 $f(A,S/A)=\{\mathtt{""}\}$，说明 $A$ 能被比她更短的 $S$ 中串代替，从 $S$ 中删除 $A$。
* 否则，$A$ 一定满足 $|f(A)|\ge 2$，即直接输出 Yes 结束程序（这部分被特判掉了，之后不再考虑）。

这样得到了 $S$ 的子集，设为 $S'$。

有性质：
1. $S'\subseteq S$。
2. 同 $S$，$S'$ 元素互异。
3. $\forall T,f(T,S)=f(T,S')$。
4. $\forall A,B\in S' \cap A\ne B, A$ 不是 $B$ 的子串。

**结论：答案为 Yes 当且仅当存在三个串 $A,B,C$ 使得 $A\ne C\cap A+B\in S',B+C\in S'$。**

注意这里的 $A+B$ 可以等于 $B+C$。

证明：

* * *

**充分性：**

由性质 4，$f(A)=\{A\},f(C)=\{C\}$，所以 $\{A,C\}\subseteq f(A+B+C)$，$|f(A+B+C)|\ge 2$。

**必要性：**

考虑反面，不存在三个串 $A,B,C$ 满足条件 $(*)$，我们证明 $\forall |f(T)|=1$。

按 $T$ 串的长度强数学归纳法，首先 $T$ 为空串时成立。

设 $T$ 在某个位置删掉 $A\in S'$ 成为 $A'$，在某个位置删掉 $B\in S'$ 成为 $B'$，我们证明 $f(A')=f(B')$ 即可。

考察 $A,B$ 在 $T$ 中删掉的位置：
* 包含，由性质 4，得 $A'=B'$。
* 有交但不包含，由 $(*)$，得 $A,B$ 非重叠部分相同，得 $A'=B'$。
* 无交，设 $C$ 为 $T$ 删掉 $A,B$ 两者后的串，由归纳，$f(A')=f(B')=f(C)$。

* * *

我们先通过 ACAM 求出 $S'$，然后再枚举每个串的后缀，判断是否存在一个串的前缀与其相同且剩余部分不同，fail 树上跑 dfs 序即可。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17189639.html</id>
    <title type="text">TJOI2019 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-07T12:52:00Z</published>
    <updated>2023-03-07T12:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17189639.html" />
    <content type="text"># P5337 [TJOI2019]甲苯先生的字符串

处理出 ban 掉的长度为 $2$ 的子串，然后矩阵快速幂即可。

# P5338 [TJOI2019]甲苯先生的滚榜

简单平衡树题，可用 pbds，我写了 fhq treap。

# P5339 [TJOI2019]唱、跳、rap和篮球

设输入的五个数分别为 $N,A,B,C,D$。

容斥有多少个“鸡你太美”，之后算一个组合状物，答案为：
$$
\sum_{k=0}^{\min(\lfloor N/4\rfloor,A,B,C,D)}(-1)^k\binom{N-3k}{k}
\sum_{a,b,c,d=0}^{A-k,B-k,C-k,D-k}[a+b+c+d=N-4k]\binom{N-4k}{a\ \ b\ \  c\ \ d}
$$
发现后面是四个多项式卷积的形式，然后就可以 NTT $O(N^2\log N)$ 做了。

但是这样还不够，观察 $k$ 从上界到下界时四个多项式的变化，$k$ 减小 $1$ 后四个多项式都新增了一个最高项，设这四个多项式分别为 $F,G,H,I$。

每次 $k$ 变化的时候 $O(N)$ 维护 $F\times G,H\times I$，再 $O(N)$ 求出这两个卷积的第 $N-4k$ 项系数即可。

复杂度 $O(N^2)$。

# P5340 [TJOI2019]大中锋的游乐场

$k$ 很小，建 $n(2k+1)$ 个点后 dijkstra 跑最短路即可。

# P5341 [TJOI2019]甲苯先生和大中锋的字符串

基本上是 SAM 板子。

# P5342 [TJOI2019]甲苯先生的线段树

原题：CF750G New Year and Binary Tree Paths</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17205340.html</id>
    <title type="text">倍增并查集-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-11T01:57:00Z</published>
    <updated>2023-03-11T01:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17205340.html" />
    <content type="text">P3295 [SCOI2016]萌萌哒

[Code](https://www.luogu.com.cn/record/113329536)

CF1801E Gasoline prices

上一道题上树版本，当然有别的做法（比如基于哈希的定位方法）。

[Code](https://codeforces.com/contest/1801/submission/221828752)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17220180.html</id>
    <title type="text">树哈希-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-15T13:35:00Z</published>
    <updated>2023-03-15T13:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17220180.html" />
    <content type="text"># 无根树

无根树同构判定可以通过找重心（两个重心的情况需要特殊处理）或所有点为根均求一遍转化为有根树同构判定。

# 有根树

对于一棵以 $rt$ 为根的子树，假设儿子集合是 $S$，定义子树的哈希
$$h(rt)=1+\sum_{i\in S} f(h(i))$$
其中 $h(i)$ 是 $i$ 对应子树的哈希，$f$ 为一个待定函数。

可以证明：如果 $f$ 为随机函数，这样的哈希在自然溢出下的期望冲突数不超过 $O(n^2/2^w)$。只需考虑最深的一对冲突点即可。

上述哈希最大的优势是好写。如果需要换根，第二次 dp 时只需把子树哈希减掉即可。

实践中，我们并不能取一个真正的随机函数当 $f$。但事实上，没有特殊性质的 $f$ 几乎都卡不掉；因为随便找个 $f$ 大概率很随机。

有一些反例：如果 $f$ 取多项式，可能因为一直保持 $2^k$ 同余关系而白给。但是经过我的实验，似乎只要扰动一下改掉这个性质即可。例如下述函数：

```cpp
ull g(ull x){ return x*x*x*13331+1011451423; }
ull f(ull x){ return g(x&amp;7)+g(x&gt;&gt;3); }
```

卡这种方法据说只能对着硬撞。

`f(ull x)` 用 $x$ 作为种子的 mt19937 也行，但跑起来较慢。

# 例题

CF1800G Symmetree

P5043 【模板】树同构（[BJOI2015]树的同构）

P4323 [JSOI2016]独特的树叶

UOJ763. 树哈希

&lt;details&gt;
&lt;summary&gt;UOJ_763_AC_code&lt;/summary&gt;

```cpp
// Problem: UOJ #763. 树哈希
// Url: https://uoj.ac/problem/763
// T/M Limit: 5000ms 512MB
// Time: 2023-03-16 20:33:52
// Author: ShaoJia

#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
struct Qis{
	FILE *I;char B[65536],*p1=B,*p2=B;
	char gc(){return p1==p2&amp;&amp;(p2=(p1=B)+fread(B,1,65536,I),p1==p2)?EOF:*p1++;}
	Qis(FILE *I_):I(I_){}
	template&lt;typename T&gt;void read(T &amp;x){x=0;T f=1;char ch=' ';for(;!isdigit(ch);f=ch=='-'?-1:1,ch=gc());for(;isdigit(ch);x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=gc());x*=f;}
	template&lt;typename T&gt;Qis&amp; operator&gt;&gt;(T&amp; x){read(x);return *this;}
	Qis&amp;operator&gt;&gt;(char&amp; x){x=' ';for(;x&lt;=' ';)x=gc();return *this;}
	Qis&amp;operator&gt;&gt;(char *x){char c=' ';for(;c&lt;=' ';c=gc());for(;c&gt;' ';*(x++)=c,c=gc());*x=0;return *this;}
	Qis&amp;operator&gt;&gt;(string &amp;x){x="";char c=' ';for(;c&lt;=' ';c=gc());for(;c&gt;' ';x+=c,c=gc());return *this;}
}qin(stdin);
struct Qos{
	FILE *O;char B[65536],*p=B;
	void pc(char x){p-B&lt;65536?*p++=x:(fwrite(B,p-B,1,O),p=B,*p++=x);}
	void flush(){fwrite(B,p-B,1,O);}
	Qos(FILE *O_):O(O_){} ~Qos(){flush();}
	template&lt;typename T&gt;void write(T x){if(x&lt;0){pc('-');if(x&lt;-9)write(-(x/10));pc(48-x%10);}else{if(x&gt;9)write(x/10);pc(48+x%10);}}
	template&lt;typename T&gt;Qos&amp; operator&lt;&lt;(T x){write(x);return *this;}
	Qos&amp;operator&lt;&lt;(const char x){pc(x);return *this;}
	Qos&amp;operator&lt;&lt;(const char *x){for(int i=0;x[i];++i)pc(x[i]);return *this;}
	Qos&amp;operator&lt;&lt;(const string x){for(char c:x)pc(c);return *this;}
}qout(stdout);
#define N 1000010
int n;
vi e[N];
ull h[N];
ull g(ull x){ return x*x*x*13331+1011451423; }
ull f(ull x){ return g(x&gt;&gt;3)+g(x&amp;7); }
void dfs(int rt,int fa){
	h[rt]=1;
	for(int i:e[rt]) if(i!=fa){
		dfs(i,rt);
		h[rt]+=f(h[i]);
	}
}
signed main(){
	qin&gt;&gt;n;
	int x,y;
	rep(i,1,n-1){
		qin&gt;&gt;x&gt;&gt;y;
		e[x].pb(y);
		e[y].pb(x);
	}
	dfs(1,0);
	sort(h+1,h+1+n);
	qout&lt;&lt;unique(h+1,h+1+n)-h-1&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17242551.html</id>
    <title type="text">牛顿迭代法（牛迭）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-22T01:59:00Z</published>
    <updated>2023-03-22T01:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17242551.html" />
    <content type="text"># 模 2^k 的逆元

先求出基本：
$$
\forall A\text{ is odd},A^2\equiv 1\pmod 8
$$
也就是说自身就是逆元。

或者来一个更厉害的：
$$
\forall A\text{ is odd},A(3A\text{ xor }2)\equiv 1\pmod{32}
$$
然后我们用牛迭求根
$$
F(x)=\frac{1}{x}-A
\\
x_{n+1}=x_n-\frac{F(x_n)}{F'(x_n)}=x_n(2-Ax_n)
$$

# 多项式求逆

把上面 $A$ 二进制看成多项式系数，然后就一样了。

请自行跳转至“多项式”。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17249312.html</id>
    <title type="text">抽象编程语言集锦-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-23T12:23:00Z</published>
    <updated>2023-03-23T12:23:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17249312.html" />
    <content type="text">[brainfuck](http://www.muppetlabs.com/~breadbox/bf/)

[whitespace](https://zhuanlan.zhihu.com/p/44093635)

[Befunge](https://zhuanlan.zhihu.com/p/44093884)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17262946.html</id>
    <title type="text">Erdos-Ginzburg-Ziv 定理（EGZ）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-27T13:19:00Z</published>
    <updated>2023-03-27T13:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17262946.html" />
    <content type="text">定理：$n$ 为任意正整数，任意 $2n-1$ 个整数中必定存在 $n$ 个数，它们的和是 $n$ 的倍数。

证明：

$n=1$ 显然成立，我们先证明当 $n$ 为素数的时候成立。

将 $2n-1$ 个数排序，设为 $a_1,a_2,\dots,a_{2n-1}$。若 $\exists i\le n,a_i=a_{i+n-1}$，即代表 $a_i,\dots,a_{i+n-1}$ 均相同，选它们即可。

否则，我们有 $\forall i&lt;n,a_i\ne a_{i+n}(\Delta)$。

设 $S=\sum_{i=1}^n a_i,b_i=a_{i+n}-a_i,B=\{b_1,\dots,b_{n-1}\}$，我们只要证明存在一个 $B$ 的子集使得子集和与 $S$ 的和为 $n$ 的倍数（$B$ 选取子集的过程等价于将 $a_i$ 替换为 $a_{n+i}$ 的过程）。

设 $f_j^{(i)}$ 表示 $B$ 中前 $i$ 项的子集和加上 $S$ 模 $n$ 是否能是 $j$，特殊地 $f^{(0)}_{S\bmod n}=1$。

我们证明 $f^{(i)}$ 中 $1$ 的个数一定严格大于 $f^{(i-1)}$ 的个数（除非 $f^{(i-1)}$ 已经全是 $1$ 了），这样 $f^{(n-1)}$ 就全是 $1$ 了，进一步 $f^{(n-1)}_{0}=1$，即定理成立。
$$
\forall 0&lt;i&lt;n,j,f^{(i)}_{j}=f^{(i-1)}_{j}\text{ or }f^{(i-1)}_{(j-b_i)\bmod n}
$$
由 $(\Delta),\forall i,b_i\ne 0$，所以将 $[0,n)$ 中的整数建点，$j\to (j+b_i)\bmod n$ 建有向边，由于素数同余系下加非零整数的置换一定形成一个大置换环，所以若 $f^{(i-1)}$ 非全 $1$，我们一定能找到一个 $j$ 使得 $f^{(i-1)}_j=1,f^{(i-1)}_{(j+b_i)\bmod n}=0$，则 $f^{(i)}_{(j+b_i)\bmod n}=1$，所以 $1$ 的个数只增不减。

&gt; 每次找 $1\to 0$ 这样的边可以 $\log n$ 求出，具体做法为二分，类似于在一个头为1尾为0的01串中找到一个10子串。
&gt;
&gt; 每次查询中间的值，若为1则向右边二分，为0向左边。

考虑完素数的情况，若 $n=ab(a,b&gt;1)$，我们可以这样构造。

共 $2ab-1$ 个数，每次取出 $2a-1$ 个数做子问题，然后将没有被选中的 $a-1$ 个放回，这样能恰好做 $2b-1$ 次。

我们得到了 $2b-1$ 组，每组 $a$ 个数，我们将每组求和，和都一定是 $a$ 的倍数（子问题所得）。将这 $2b-1$ 个序列的和先均除以 $a$ 做一遍 $b$ 规模的子问题后再乘回 $a$ 就得到了 $ab$ 个和为 $ab$ 倍数的数了。

[UOJ771. 【UER #11】科考工作](https://uoj.ac/problem/771)

&lt;details&gt;
&lt;summary&gt;科考工作代码&lt;/summary&gt;

```cpp
// Problem: UOJ #771. 【UER #11】科考工作
// Url: https://uoj.ac/problem/771
// T/M Limit: 3000ms 512MB
// Time: 2023-03-29 09:59:14
// Author: ShaoJia

#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#ifdef SuperAnton
#define D(...) fprintf(stderr,__VA_ARGS__)
#define DD(...) D(#__VA_ARGS__ " = "),DEBUG::debug(__VA_ARGS__),D("\n"),fflush(stderr)
#include&lt;debug.hpp&gt;
#else
#define D(...) ((void)0)
#define DD(...) ((void)0)
#endif
#define rep(i,j,k) for(int i=(j),i##_=(k);i&lt;=i##_;i++)
#define per(i,j,k) for(int i=(j),i##_=(k);i&gt;=i##_;i--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define pb emplace_back
#define ckmx(a,b) (a=max(a,b))
#define ckmn(a,b) (a=min(a,b))
const int N=300010,inf=1e9;
pi a[N&lt;&lt;1];
int n,b[N],c1,c0=0,base,ivbase;
bool up[N];
inline int o(int x){ return 1ll*x*base%n; }
inline int oo(int x){ return 1ll*x*ivbase%n; }
int fpw(int x,int y){
	int res=1;
	while(y){
		if(y&amp;1) res=1ll*res*x%n;
		y&gt;&gt;=1;
		x=1ll*x*x%n;
	}
	return res;
}
int expand(){
	while(b[c0]) c0++;
	int l=oo(c1),r=oo(c0),mid;
	assert(b[o(l)] &amp;&amp; !b[o(r)]);
	if(l&gt;r) r+=n;
	while(l&lt;r-1){
		mid=(l+r)&gt;&gt;1;
		if(b[o(mid)]) l=mid;
		else r=mid;
	}
	return o(r);
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,2*n-1) cin&gt;&gt;a[i].fir,a[i].sec=i;
	sort(a+1,a+2*n);
	rep(i,1,n) if(a[i].fir==a[i+n-1].fir){
		rep(j,i,i+n-1) cout&lt;&lt;a[j].sec&lt;&lt;" ";
		cout&lt;&lt;"\n";
		return 0;
	}
	int x=0;
	rep(i,1,n) (x+=a[i].fir)%=n;
	b[x]=inf;
	c1=x;
	rep(i,1,n-1){
		base=a[i+n].fir-a[i].fir;
		assert(base);
		ivbase=fpw(base,n-2);
		x=expand();
		b[x]=i;
	}
	assert(b[0]);
	x=0;
	while(b[x]!=inf){
		up[b[x]]=true;
		(x+=n+a[b[x]].fir-a[b[x]+n].fir)%=n;
	}
	rep(i,1,n-1) if(!up[i]) cout&lt;&lt;a[i].sec&lt;&lt;" ";
	cout&lt;&lt;a[n].sec&lt;&lt;" ";
	rep(i,n+1,2*n-1) if(up[i-n]) cout&lt;&lt;a[i].sec&lt;&lt;" ";
	cout&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

CF1798F Gifts from Grandfather Ahmed</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17268232.html</id>
    <title type="text">集合幂级数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-29T03:15:00Z</published>
    <updated>2023-03-29T03:15:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17268232.html" />
    <content type="text"># 2023年9月18日

首先你得会正常多项式 ln exp（可以 $O(n^2)$）[指路](https://www.cnblogs.com/shaojia/p/16411101.html#ln--exp)。

## P6570 [NOI Online #3 提高组] 优秀子序列

以前写的萌萌 $O(3^n)$ 做法（$n$ 是二进制下位数）。

题意：记 $\{a\}$ 中值为 $i$ 的个数为 $c_i$，给 $\sum c_ix^i$ 做子集 exp（注意先处理掉 $a_i=0$）。

沿用子集卷积的做法，发现 fmt 和 ifmt 中间我们做了一个多项式乘法，改成多项式 exp 即可，复杂度还是 $O(2^nn^2)$。

卡到最优解：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230918094255929-1077670922.png)

## LOJ154. 集合划分计数

题意：子集 $\exp_{\le k}$。

把多项式 $G=\exp F$ 改成 $G=\sum_{i=0}^k \frac{F^i}{i!}$。

同样的方法两边求导得 $G'=\sum_{i=0}^k \frac{iF^{i-1}F'}{i!}=F'(G-\frac{F^k}{k!})$。

然后就可以用类似的方法递推了。

$F^k$ 的求法：乘系数使得 $[x^0]F=1$，然后做 $\ln,\exp$。

复杂度 $O(2^nn^2)$。[Code](https://loj.ac/s/1889950)

如果暴力 $O(2^nn^3)$ 多项式乘法的话可以拿到 75pts 的 TLE 高分。

## LOJ6729. 点双连通生成子图计数

## LOJ6730. 边双连通生成子图计数

## CF1034E Little C Loves 3 III

发现是普通的子集卷积，但是 $n\le 21$，$O(2^nn^2)$ 卡常了。

发现答案对 $4$ 取模，我们将形式幂级数 $a_Sy^{|S|}x^S$ 中的 $y$ 直接设为 $4$，和 $a_S$ 一起作系数。

在子集卷积的过程中，不同的 $y$ 的幂次的系数会进位重叠，但是无所谓，不影响正确性。

最后取 $y^{|S|}x^S$ 的系数时，由于 $\forall s&lt;|S|,y^sx^S$ 的系数均为 $0$（$\text{ppcnt}(a)+\text{ppcnt}(b)\ge \text{ppcnt}(a|b)$），所以不会被进位，取 $\sum a_S4^{|S|}$ 中 $2^{2|S|}$ 和 $2^{2|S|+1}$ 两个二进制位即可。

注意使用 `unsigned long long` 时计算过程会自然溢出，但是无所谓，溢出的部分一定不会是不交并。

复杂度 $O(2^nn)$。

# 远古

[Alex_Wei Blog](https://www.cnblogs.com/alex-wei/p/set_power_series.html)

## P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)

略

## P6097 【模板】子集卷积

略

## P4221 [WC2018]州区划分

半在线卷积

## CF914G Sum the Fibonacci

子集 And Xor 卷积缝合题

## [ARC100E] Or Plus Max

简单题，高维前缀和维护最大及次大值。

## [ABC212H] Nim Counting

用了变换的线性性：
$$
\sum_{i=1}^n ifwt(fwt(a)^i)=ifwt(\sum_{i=1}^n fwt(a)^i)
$$
将 $a$ FWT 后每一项做一个等比数列求和，再 IFWT 即可。

## P5387 [Cnoi2019]人形演舞

暴力得知 $sg(x)=x-2^{\lfloor \log_2 x \rfloor}+1$，然后就和上题差不多了，将等比序列求和变成幂。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17270709.html</id>
    <title type="text">Matrix-Tree 矩阵树定理-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-29T14:32:00Z</published>
    <updated>2023-03-29T14:32:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17270709.html" />
    <content type="text">[Alex_Wei blog](https://www.cnblogs.com/alex-wei/p/LinearAlgebra.html)

证明（cxy 给的，可能很高妙）：

&gt; 无向图，任意取一个点 $r$ 作为根。对于剩下的点都认一个父亲
&gt;
&gt; 这样得到的图是一颗以 $r$ 为根的树和若干基环树。考虑容斥，枚举环的结构，其余部分令 $p_i = i$，代表这些点随便认父亲，这样其实枚举的是排列
&gt;
&gt; 这样一个排列的权值是所有 $p_i \neq i$ 的点，边 $(p_i,i)$ 权值之积，乘上所有 $p_i = i$ 的点，$i$ 的度数。容斥系数是除自环外，$-1$ 的置换环的数量次方
&gt;
&gt; 置换环的数量 + 排列逆序对数量与 $n$ 奇偶性一致。所以可以用 $(-1)^{\tau(p)}$ 代替置换环数量，最后要乘 $(-1)^n$。为了消除自环影响，给 $i$ 的度数乘 $-1$
&gt;
&gt; 也可以不乘 $(-1)^n$，给矩阵每项乘 $-1$
&gt;
&gt; 于是得到矩阵树定理：无向图生成树个数等于 邻接矩阵 - 度数矩阵 的行列式</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17277653.html</id>
    <title type="text">2023 联合省选 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-03-31T14:17:00Z</published>
    <updated>2023-03-31T14:17:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17277653.html" />
    <content type="text"># Day 0

拼车（好贵）去杭师大试机，上手感觉还行，毕竟我用过一段时间的 NOI Linux 虚拟机。

回来坐地铁用了 1h+ 有点痛苦。

# Day 1

愚人节，CCF 的愚人方式是错写成 2022。

![](https://img2023.cnblogs.com/blog/2213867/202304/2213867-20230403184510669-88076126.png)

（Day 2 写的是 2023，所以这显然是诈骗）

开局先全盘看，T1 题面细节有点多，T2 一眼谔谔子图题，T3 有根树看起来可做一点。

T3 简单 $O(nm\log^2 n)$ 启发式合并做法，有 48pts，好多、好写，拿了。

然后看 T1，发现是萌萌题，切了，100pts。

然后 T2 我没看出性质（cxny 他们说圆方树 DP 啥的，其实我也想到过），在搞啥整除分块（当时考场上好困），最后写了一个非多项式算法暴力，25pts。

接下来 2h，完全卡住了，T3 刚了好久发现 C 性质 6pts 可以 DDP，但是没调出来。

摆烂！考场上打块。

估计 100+25+48=173，出考场发现 wsyear 也是这个分，大众分了，自测也是这样。

下午和晚上与学长们打 goose goose duck，还背了一些字符串的板子。

# Day 2

好家伙没有字符串题！（气愤）

全局扫一眼，T1T2 题面含博弈成分，T2T3 题面含颜色序列。

把出题人刀了再说。

T1 发现可以转化为点边 1e6 的有向图走棋子博弈，但是可能有环，不太会处理，赛后发现自己纯纯的脑瘫，BFS 状物就解决了。

场上疯狂分讨部分分，没写挂（几乎不可能）的话 45pts。

T2 就更谔谔了，本来转化了一个 2sat，后来发现不对，结果之后脑子里全是 2sat 了，寄，32pts 封顶，好像说性质 C 可以根号网络流，考场上一心 2sat 了，没想过流/hsh 。

T3 上升下降子序列啥的，感觉联考考过啥的（？）不懂，一眼不会，打暴力走人。

结果我就打了 2pts 暴力，要是搞一搞逆序对啥的可以再加 8pts，但是我这个时候心态不太好了。

自测 62pts，wsyear 自测 71pts。

下午和晚上打鹅。

# Day 3

终结了，直接回学校了（要中考了啊）。属实是画了一个一点都不完美的句号。但是句号只是一句话的结束，我将续写我的 OI 篇章。

被 konata D 了。

发现 whk 被暴打了，落差感很足。

教训。教训。教训。教训。教训。教训。教训。教训。教训。教训。教训。教训。

一拳把自己打爆！一拳把自己打爆！一拳把自己打爆！一拳把自己打爆！一拳把自己打爆！

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230504212546492-1403632908.jpg)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17284030.html</id>
    <title type="text">APIO 2023 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-04-03T10:42:00Z</published>
    <updated>2023-04-03T10:42:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17284030.html" />
    <content type="text"># 2023年4月

报名，好多人都被强转线上了，我居然还是线下，不懂 CCF。

今年目标：比 Cu 好。

&lt;details&gt;
&lt;summary&gt;贴个日程表&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230519224519817-745685133.png)

&lt;/details&gt;

# 2023年5月14日

发了练习网址。

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230514141527339-833563100.png)

好看捏。

# 2023年5月17日

把练习赛 ak 了。

T1 签到题。

T2 等价于 缩点后 在线维护无根树上点集 $S$ 加/删单点 求 $S$ 构成的**无根**虚树节点集合是否 $\subseteq S$。

直接用 set 动态维护有根虚树节点集合 $T$，再动态维护 $T/S$，合法当且仅当 $T/S$ 为空或只有一个元素 $x$，使得 $x$ 为虚树的根且只有 $2$ 个儿子（虚树根二叉）。

复杂度单 log。

T3 &lt;https://www.cnblogs.com/zkyJuruo/p/17407535.html&gt;

最后 $K=4$ 的时候记得本地跑，找到一个较优的随机种子提交。

# 2023年5月19日

早上听了字符串合集，csy 口音+不带图我真的掉线呜呜呜，xtq 的还行，再讲了一遍 WC 讲过的基本字串结构。

下午 bmh 分配生，分配了东河，老师看傻了。

晚上高铁直奔南京。

臭豆腐好好吃！！！

&lt;details&gt;
&lt;summary&gt;一些图片&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230519224401000-1145793950.jpg)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230519224409094-864012189.jpg)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230519224651130-1398085644.jpg)

&lt;/details&gt;

领了东西，明天考试rp++。

# 2023年5月20日

520！和妹子发了一句骚话。

试机xjb写了一些东西。

发现发密码条的是小粉兔。

&lt;details&gt;
&lt;summary&gt;陈亮舟名牌&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230527123407478-1331173657.png)
&lt;/details&gt;

开题。

T1 模拟赛出过类似的，dij 跑一跑即可，写了交了。

看 T2，不太会 ds。但是看了 T3，还是回来乖乖看 T2。

把部分分全想会了，发现把部分分做法拼在一起（不是数据分治那种）就做完了。

T2 写完交了，过了。

发现 T1 只有 97 分，就开始玄学卡常。

后来发现可以分层图 dij 优化，写了交了，但是 queue 太长导致变成了 OI 赛制。

看 T3，发现要拿 8pts 以上要手搓加法器，但是我摆了（愤怒！！！）。

出场一问人均 266，我 T1 测出来分层 dij 写挂了，喜提 97+100+8=205。

傍晚国家队交流（Alex_wei 采访），ix35 上去问了一个“如何评价 APIO2023”，由于没有dzd在现场气氛越来越嚣张。

&lt;details&gt;
&lt;summary&gt;两张图片&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230527123959317-725580714.jpg)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230527124005938-1812182926.jpg)
&lt;/details&gt;

# 2023年5月21日

上午讲母函数，还行，后期有点无聊（最后一个半小时还剩最后一道题），签到后找机会润了。

下午问题选讲，挺好的，面基到了 rui_er，后面说要拖堂，而且我脑子快炸了，就先润了 10min。

&lt;details&gt;
&lt;summary&gt;rui_er 老师的史迪奇（讲课一直抱在手里）（现场没拍，这是之前别人拍的）&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230527123453343-1875217343.png)
&lt;/details&gt;

回宾馆发现川宝、lyc、花花在卷 gym。

晚上闭幕式，开场一个冰雪奇缘唱歌 + Never gonna give you up，然后报了线上分数线，极低。

然后中间插了一个节目《听我说谢谢你》，很超模。

然后线下分数线，很高，Ag。

晚上打雀。

# 2023年5月22日

一早赶高铁，再见南京。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17372472.html</id>
    <title type="text">PKUSC 2023 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-04T12:45:00Z</published>
    <updated>2023-05-04T12:45:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17372472.html" />
    <content type="text"># 2023年5月4日

青年节 + 杭二生日 + 星球大战日，颓了一天。收拾行李准备出发，明天一大早赶高铁。

下发了 pku 电子餐券的使用说明。

# 2023年5月5日

早早出发，早中饭都随便吃了点，下午、晚上打隔膜。

晚上打了网络流板子，虽然后两天都没用到。

还看了一眼 CF 的 E，和 wsy 马上秒了，睡觉。

# 2023年5月6日

北大我来了。

简短开幕了一下就开始试机，我打了一些 modint 啥的。

中午可以吃家园或农园，时间充裕逛了一下校园（e.g. 未名湖）。

下午一看我试机的文件咋还在。而且两道要用同余系的题，modint 赚翻。

晚上 5：00 比完，和一行人速通圆明园（6：00 到 7：00 关门）。

回来打游戏，睡觉。

# 2023年5月7日

上午讲了半个小时的北大广告和分专业流程，还邀请了 CCF 蒋婷婷讲~~废话~~。

然后又逛了一圈校园。

下午一看昨天的程序还在。

晚上匆匆离场，高铁 11：30 到杭州。

# 总结

北京挺好玩的，就是交通设施有点不顺。

北大校园很好！而且最近在举办五四长跑+125周年校庆，气氛很足。

比赛没拿到的分（从易到难）：支持区间定位及区间移动、单点 rank 的平衡树，min-max 容斥，DDP 抽象成矩阵的方法，随机化理论和类欧几里得算法。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17383129.html</id>
    <title type="text">我必须努力的原因-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-08T12:58:00Z</published>
    <updated>2023-05-08T12:58:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17383129.html" />
    <content type="text">唯物主义

中考一模分数没考过咔咔仙

wsy 一模碾压我 40+pts，WC2023 他 Au 我 Ag，省选也比我高 20+pts，PKUSC2023 比我高半百，而且人家停课比我少

杭二、北大真的好好，想去

立志、努力、为公

浙江 宁波市镇海蛟川书院 初二 女 王冠龛，跟我一起上计蒜客 X3，而且 PKUSC2023 也在，很猛。

和高一学长实力差距有点大

浏览器集锦堆成山，这是哪个傻逼喜欢拖延？

Bilibili 知乎 Pixiv 超厉害的推荐算法都推荐不过来我爱看的东西了，不想电子阳痿

我凭什么在同龄人之间突出，能参加线下 APIO2023，申请 NOI2023D 类</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17383336.html</id>
    <title type="text">Min-Max 容斥及拓展-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-08T14:15:00Z</published>
    <updated>2023-05-08T14:15:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17383336.html" />
    <content type="text">以下设
$$
S=\{a_1,\dots,a_n\}\ \ (a_1\le\dots\le a_n)
$$
直接上最普适的式子：
$$
\min_k(S)=a_k=\sum_{T\subseteq S,T\ne\varnothing}(-1)^{|T|-k}\binom{|T|-1}{k-1}\max(T)
$$

以及等式两边 MinMax 交换、套期望也是对的。

证明（本质是套二项式定理）：
$$\begin{aligned}
RHS=&amp;
\sum_{i=1}^na_i\sum_{j=1}^i\binom{i-1}{j-1}(-1)^{j-k}\binom{j-1}{k-1}
\\=&amp;
\sum_{i=k}^na_i\sum_{j=k}^i\binom{i-1}{j-1}\binom{j-1}{k-1}(-1)^{j-k}
\\=&amp;
\sum_{i=k}^na_i\sum_{j=k}^i\binom{i-1}{k-1}\binom{i-k}{j-k}(-1)^{j-k}
\\=&amp;
\sum_{i=k}^na_i\binom{i-1}{k-1}\sum_{j=0}^{i-k}\binom{i-k}{j}(-1)^j
\\=&amp;
\sum_{i=k}^na_i\binom{i-1}{k-1}[i-k=0]
\\=&amp;
a_k=LHS
\end{aligned}$$

&lt;https://www.luogu.com.cn/blog/command-block/min-max-rong-chi-xiao-ji&gt;

将素因子的指数做 min-max，就可以得到 gcd-lcm：
$$
\text{lcm}(S)=\prod_{T \subseteq S, T \neq \varnothing} \gcd(T)^{(-1)^{|T|-1}}
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17399537.html</id>
    <title type="text">树形背包时间复杂度再谈-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-14T08:33:00Z</published>
    <updated>2023-05-14T08:33:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17399537.html" />
    <content type="text">[前传](https://www.cnblogs.com/shaojia/p/15520224.html)

首先说明这个时间复杂度分析不止能用在“背包算法”上，满足以下条件的算法也适用：

1. 大小为 $n$ 的有根树每个节点 $i$ 要维护的信息个数 $cnt_i\le\min(sz_i,V)$。
2. 将 $u$ 的儿子 $v$ 信息合并 + 统计对答案的贡献复杂度 $O(cnt_ucnt_v)$，其中 $cnt_u$ 表示合并前的值。

这样的问题复杂度可以做到 $O(nV)$。

证明：

以下我们直接将 $\min(sz_i,V)$ 当作 $cnt_i$。

一方面我们说明 $n\le V$ 时复杂度可以做到 $O(n^2)$：

考虑每个点作为上述的 $u$ 合并的复杂度，发现不论按什么顺序合并复杂度都是 $sz_u^2-\sum_{v\in son_u} sz_v$，将每个点复杂度累加起来就是 $sz_{root}^2=n^2$。

另一方面我们说明 $n&gt;V$ 时复杂度可以做到 $O(nV)$：

考虑信息合并的顺序。显然可以抽象成 $n$ 个信息集的 Kruskal 重构树 $T$，同时 $T$ 也是 Leafy Tree，设 $T$ 上 Nodey 节点集合为 $P$。

我们将 $T$ 上的节点 $w_i$ 表示为 $i$ 点子树内叶子个数，$l_i,wl_i$ 分别表示 $i$ 的左儿子及其 $w$ 值，$r_i,wr_i$ 同理。

显然 $\forall i\in P,w_i=wl_i+wr_i$。

复杂度为 $\sum_{i\in P}\min(wl_i,V)\times \min(wr_i,V)$。

按 $[w_i\le V]$ 将 $P$ 点集分类，满足条件的为 $S$，不满足的为 $B$。

复杂度不大于 $\sum_{i\in B}V^2+\sum_{i\in S}wl_iwr_i$。

由于 $|B|\le O(\frac{n}{V})$，所以前半部分 $\le O(nV)$。

将 $T$ 删除 $B$ 点集，剩下树大小都不超过 $V$ 的森林，结合 $n\le V$ 的证明，得到后半部分 $\le O(nV)$。

所以复杂度 $O(nV)$，得证。

P.S.

若合并复杂度为 $O(Vcnt_v)$ 或 $O(cnt_uV)$ 均会退化到 $O(nV^2)$。构造：根下连 $n/V$ 条长度为 $V$ 的链。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17409530.html</id>
    <title type="text">平面网格套路-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-17T09:44:00Z</published>
    <updated>2023-05-17T09:44:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17409530.html" />
    <content type="text">这类套路和平面最近点对有关系。

# P7883 平面最近点对（加强加强版）

我们先将点 shuffle。

我们先求出 $1,2$ 之间的距离 $ans$ 作为初始答案，将平面划分成 $ans\times ans$ 的无限网格。

$1\to n$ 枚举每一个点，通过 hash 得出所在格子的标号，然后用链式前向星查附近（类似扫雷区域）$3\times 3$ 格子中的点（可以证明点数为常数）是否与新加入的点构成更小的距离（$&lt;ans$）。

* 若没有，则直接将点加入链式前向星。

* 若有，则更新答案 $ans$，重构整个平面。

可以证明复杂度期望线性。

# 基础计算几何练习题

&lt;https://contest.xinyoudui.com/contest/93/problem/371&gt;

记 $S$ 为所有全局最近点对的并形成的点集。

容易发现，先手位置在 $S$ 内则先手必胜，因为走任意一条最近点对都让后手无路可走。

所以将这些点的答案设为 $1$。考虑从非 $S$ 点开始的博弈，无论哪一方都不会主动走到 $S$ 集合内。

所以我们将 $S$ 中的点删除。若没有点了，就做完了。若只剩一个点了，则这个点的答案为 $0$ 也做完了。

否则，我们重新求 $S$，递归做即可。

通过此做法，我们得到了答案为 $0$ 的点不会超过一个。

这样我们得到了 $O(n^2)$ 的做法，考虑优化。

先将平面划分成足够小的方形网格（设网格边长为 $l$），使得每个格子有至多一个点。

我们线性时间处理出距离 $&lt;2\sqrt 2 l$ 的所有点对，设这些点对覆盖的点集为 $T$。

若 $T$ 不为全集，则我们将 $T$ 删去。我们重构网格边长为 $l':=2l$。

因为不存在距离 $&lt;2\sqrt 2 l$ 的点对了，所以保证了每个格子至多一个点，递归做即可。

否则 $T$ 为全集，将点对按距离升序排序，不断按距离删点直到只剩不多于一个点。

复杂度 $O(n(\log V-\log\epsilon)+n\log n)$，$V$ 为坐标范围，$\epsilon$ 为坐标精度。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17420975.html</id>
    <title type="text">yzc川宝语录-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-22T08:21:00Z</published>
    <updated>2023-05-22T08:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17420975.html" />
    <content type="text">2023年5月21日APIO2023闭幕式结束的晚上睡觉前，川宝（当时和我住一起）真心碰真心和我讲了好多。

## 关于做题：

川宝几乎只做 cf 和 atc（和最近刚出的 ucup i.e. universal cup）。他 arc agc 都会认真打，cf 却不很。gym 中好题宝藏题很多，尤其是 opencup，这些 gym 的资料可以看 [jiangly 的博客](https://www.luogu.com.cn/blog/jiangly/suo-you-opencup-bi-sai-di-zi-liao)。

“OI 是一定要有计划的，不要学我，见到一道题想写就写，不写开摆，最好有系统性的学习。”

“要补模拟赛，向 cxy 看齐。”

## 关于机房：

从之前 whk 讲起，发现同行人氛围很重要，而且机房尽量保持在动态安静的环境。川宝不来机房的原因之一是不想写题的时候听别人大声说p话（而且不想长时间戴耳机），而且讨厌在机房打隔膜还很嚣张的人（声称：正确做法为自己安静偷偷水）。川宝提议来 APIO 线下的 6 人自己开一个机房，这样就能保持好的氛围。但是我觉得这样切割不太好，有待商榷。

## 关于川宝：

还有要自律，川宝也说为了高效所以选择不来机房，结果发现自己孤身一人时更难高效，有时候一整天都在看手机。他想到这些也是后悔不已，曾在他爸那里哭了三天。

还有他说了一句“恋爱关系对我的 OI 影响还是很大的。”然后就没说了，我也不好意思问下去。

他说建议我可以时不时学一学 whk，跟跟人家的努力，他声称自己水太多了，若之前每天一半时间去whk，可能训练的效果也差不多，甚至更好。

确实，很奇怪啊，之前 whk 的时候几乎不水的，为啥一步入 OI，就每天不是水群就是隔膜，最终成为了自己看不惯的人。

川宝也说，OI 确实比 whk 难，所以劳逸结合，张弛有度是很重要的，所以不要因为打球打太久劳累（这样有助于身心健康）回机房而自责，而是当你在看小视频，zhihu，bilibili，打隔膜的时候，可以想一想，这样真的是休息吗，还是反而更累了？</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17432671.html</id>
    <title type="text">gym104373 The 2021 ICPC Asia Macau Regional Contest 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-25T11:35:00Z</published>
    <updated>2023-05-25T11:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17432671.html" />
    <content type="text"># A

签到。

# B

# C

考虑怎样的三个镭射点构成的三角形包含原点，考虑**最终态**，能逃脱等价于所有镭射点都在一个过原点的半平面内。

极角排序 + 双指针。

long double + atan2 被卡精度了，用叉积和点积。

# D

这份代码相对失败，因为他写了一个 SPFA 和 Dijkstra 的缝合物，但是最坏复杂度是指数级的（当然如果边权有上界，则复杂度与边权上界同阶）。

构造：

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230525194739031-1557210988.png)

其中边权 6 是 3 的两倍，7 比 6 大 1，14 是 7 的两倍，15 比 14 大 1...

这样每个梭形首次被遍历的时候 $3$ 倍数的点会卡在堆底，直到右边的所有梭形全都得到最短路没动静了，才会更新 $3$ 倍数的点。此时右边的所有步骤都将重新再来（由于边权足够，之后的所有“卡在堆底”事件都会重复）。这样复杂度就是指数级了。

# E

预处理每种长度的循环在模长度意义下每种时刻的贡献，之后由于不同的循环长度个数是 $O(\sqrt n)$ 的，就可以 $O(q\sqrt n)$ 处理询问。

考虑每个循环，稍加推导发现贡献是循环卷积的形式。于是拉来双模 NTT + CRT 合并（这里最终答案不超过 $10^{15}$，所以双模够了）就做完了。

总复杂度 $O(n\log n+q\sqrt n)$。

# F

结论：若执行 $n-1$ 次操作后还没停止，则必然 Recurrent。

证明：任意连续的 $n-1$ 次操作总有一个位置没被操作到，这样他加了 $n-1$，必然可以成为下一次操作的对象。

暴力用 priority_queue 模拟前 $n-1$ 次（我写了 $3n$ 次）即可。

# G

# H

# I

采用 Boruvka 算法求最大生成树。

每个步骤将字符串集合划分成多个连通块，我们可以线性求得每个连通块向外连出去的最大边，则总复杂度为线性对数。

将所有字符串首尾连接起来，中间加上**互不相同**的标识符。

然后跑 SA，求出 height，建 ST 表。

每个步骤前处理出每个后缀在 sa 中不同连通块的前后继。

然后 ST 表查询。

最后同步用并查集进行合并操作。

* * *

Upd

可以采用类似 [P8207 [THUPC2022 初赛] 最小公倍树](https://www.luogu.com.cn/problem/P8207) 的做法，最小生成树可以边集划分分别的最小生成森林归并 Kruskal 这样求得。

发现有用的边只有 sa 中相邻后缀两者之间的边，跑 Kruskal 即可。

# J

先离线把整棵树建出来，这样就可以 ST 表 $O(1)$ lca 了。

定义一个点集在树上的直径为两端点在点集中的最大长度路径。

考虑如何动态维护每种颜色的直径。

结论：两个点集并的直径的两个端点属于两个点集分别的直径的共计四个端点。

这样套上一个平衡树/动态开点线段树，对于每种颜色来说，支持加点、删点、查直径两端点。

再对所有颜色开线段树，pushup 的时候合并直径时更新答案（即不同颜色之间的最大距离）。

# K

签到。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17435734.html</id>
    <title type="text">qbxt字符串专题回放资料观看笔记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-26T12:19:00Z</published>
    <updated>2023-05-26T12:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17435734.html" />
    <content type="text">讲师：[黄子宽](https://oier.baoshuo.dev/oier/29430)

# D1 下午

## 矩阵版的字符串 hash

对每种字符预处理一个随机 $2\times 2$ 矩阵，字符串的 Hash 值就是矩阵按顺序乘起来的矩阵。

随一个矩阵为不可逆矩阵（不满秩）的概率为 $1/P$。

这样做的好处是可以方便处理字符串集的 hash（用普通多项式 hash 法的话 {"ab","cd"} 和 {"ad","cb"} hash 值相同）。

求子串的 hash 值时可以预处理出前缀连乘矩阵的逆。

这种方法的强度约等于四模 hash。

&gt; 对于每个字母c，随机一个低维矩阵Mc。
&gt;
&gt; 对于一个字符串，hash就是每一位对应的M按顺序乘积。
&gt;
&gt; 这样的hash具有非常强的安全性（不满足交换，且不按位独立，同时自然hash空间大），但是坏处就是计算常数大。

## Hash 生日悖论

设我们要判断 $n$ 个样本的等价类关系（两两之间），hash 时 hash 结果空间应当不小于 $n^2$ 规模。原因为生日悖论 $n$ 个人每个人选一个 $n^2$ 内的数，有 50% 的概率至少有两人相同。

## 凸包 hash

&lt;https://www.luogu.com.cn/problem/CF1017E&gt; The Supersonic Rocket

找到所有凸包上相邻两条边组成的三角形，逆时针方向将每个三角形三条边长（的平方）存入序列。两个凸包同构等价于数列循环同构。

## 【UNR #4】同构判定鸭

&lt;https://uoj.ac/problem/552&gt; 

若有，最短坏串长度不超过 $n_1+n_2$。

二分+DP+矩阵字符串 hash。

## [NOI2014] 动物园

KMP 倍增跳 fail 是单 log 的。

考虑跑正常 KMP 后跑魔改 KMP，每次维护最长的不交 border，可类似正常 KMP 转移，复杂度线性。

&lt;https://www.luogu.com.cn/record/111306597&gt;

## exKMP

&lt;https://www.luogu.com.cn/problem/P5410&gt; 【模板】扩展 KMP（Z 函数）

&gt; 不太常用，求一个串S每个后缀和T的最长公共前缀。
&gt;
&gt; 因为功能被后缀自动机完爆，方便性被hash完爆。
&gt;
&gt; 唯一的用处是O(n)卡常数（x

[NOIP2020] 字符串匹配 用到了。

如果说 KMP 的算法流程类似于 DFA，那 exKMP 类似于 manacher。

和 KMP 类似，先做模式串自己，再去匹配文本串。

咕。

## manacher

&gt; 求回文串的重要算法，虽然功能被回文自动机完爆，但是一般人谁写回文自动机啊（x
&gt;
&gt; 还是挺有用的。
&gt;
&gt; 只是说一般的回文串问题重点都不在manacher上。

咕。

## [BJOI2017]魔法咒语

咕。

# D1 晚上

## CF86C Genetic engineering

## CF1110H Modest Substrings

## 线性代数

设 $a_1,\dots,a_n$ 是 $n$ 个 $n$ 维列向量，
$$
M=[a_1a_2\dots a_n]
$$
则 $\text{det}(M)\ne 0\iff M$ 可逆 $\iff M$ 满秩 $\iff a_1,\dots,a_n$ 张成的线性空间是 $\mathbb R^n$。

### 拉普拉斯展开

$$
\text{det}(A)=\sum_{\sigma}(-1)^{\text{inv}(\sigma)}\prod_{i=1}^n a_{i,\sigma(i)}
$$
可证明 LGV 引理。

### 初等行变换

通过 $A_i+=k\cdot A_j$ 初等行变换后 $\text{det}(A)$ 不变，相当于高维的等积变形。

### 伴随矩阵

伴随矩阵是每个对应位置代数余子式构成矩阵的**转置**。
$$
A\times A^*=\text{det}(A)\cdot I
$$
证明：设矩阵乘积为 $B$，$A$ 的代数余子式是 $A_{i,j}$，
$$
B_{i,j}=\sum_{k=1}^{n}a_{i,k}a^*_{k,j}
=\sum_{k=1}^{n}a_{i,k}A_{j,k}
$$
当 $i=j$ 时，$B_{i,j}=\text{det}(A)$（行列式的求法），否则，$B_{i,j}=$ 将 $A$ 中第 $j$ 行赋值为第 $i$ 行后的行列式，由于线性相关，$\text{det}=0$。

# D2 上午

讲了 SAM 基础内容。

# D2 下午
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17441839.html</id>
    <title type="text">gym100500 2014 Syrian Collegiate Programming Contest (SCPC 14) AK记录-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-29T14:15:00Z</published>
    <updated>2023-05-29T14:15:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17441839.html" />
    <content type="text"># A

状压 DP 两个人剩余可用的字串集合。

注意 `getline(cin,str);` 上一行换行符的坑。

# B

通过求和预处理出最后对应项的和 $s$。

处理出前两个串间的循环移位（$n$ 种）和后两个的（$n$ 种）。

将后 $n$ 个串每个位置 $s-x\to x$，接下来判断两个大小为 $n$ 的数组集合是否有一对循环同构。

将 $2n$ 个串跑最小表示法后整串 Hash，之后 $n^2$ 暴力匹配即可。

总复杂度 $O(n^2)$。

# C

读懂题意比做这道题难。

# D

简单排序题。

# E

简单博弈 SG 函数题。

# F

简单二分数数题。

# G

让你 All Clear 一个类似 Emacs 自带 Bubble 游戏，总大小 $5\times 6$。

记忆化爆搜，复杂度玄学。

# H

经典弱智 DP 题。

# I

放了一首 Hall of Fame，读懂题意比做这道题难。

# J

签到题。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17442639.html</id>
    <title type="text">MessageBox-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-30T02:50:00Z</published>
    <updated>2023-05-30T02:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17442639.html" />
    <content type="text">![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530104602776-1712424994.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530104625451-1449848127.png)

函数返回值：

```text
1:确定
2:取消
3:放弃
4:重试
5:跳过
6:是
7:否
```

类型：

```text
MB_OK 默认值。有一个确定。
MB_YESNO 有是和否。
MB_ABORTRETRYIGNORE 有放弃，重试和跳过
MB_YESNOCANCEL 有是，否和取消
MB_RETRYCANCEL 有重试和取消
MB_OKCANCEL 有确定和取消
```

上述类型其实都是值，将其或上一个值后会有图标（如 `MessageBox(NULL,"text","title",16|MB_OK);`）

```text
16 叉叉
32 问号
48 感叹号
64 小写字母i
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17444660.html</id>
    <title type="text">PKUCPC 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-30T14:12:00Z</published>
    <updated>2023-05-30T14:12:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17444660.html" />
    <content type="text">队名：cxy fan club

队友：zhouershan cxny

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530215308866-54605241.png)

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530215430897-2072672966.png)

我写的：A、D、I 和半个 H。

最后在搞 J，很抽象一个博弈题。

A：

给你一个正整数数字三角形（第 $i$ 列高度为 $n-i+1$），AB 博弈，A 可以取一个非空列顶，B 可以取一个非空列底，最后比谁的和更大，问你最优决策下两人最终分别的和。

* * *

数据范围很诈骗。结论：每一列两人会尽量对半分，将长度为奇数的列剩下的数 sort 一下两人会从大到小轮流取。

D：

简单最短路题，细节有点多。

I：

长度为 $m\le 10^6$ 的环形道路上有 $n\le 10^6$ 个床位（两个床位可以重叠），$n$ 个人每个人有一个心仪床位 $a_i$，设其最终睡到的床位为 $b_i$，则代价为 $a_i,b_i$ 两个床位在环上的最短距离。求最小代价和。

* * *

经典结论（场上没证明直接当作是对的了）：人在环上的相对位置和心仪床位在环上的相对位置相同，即位置关系循环同构。

接下来就是枚举错位取答案最小值即可，显然暴力过不去。

每个床 / 人对答案的贡献可以拆成相同的 $O(1)\le 4$ 段对连续的错位下标的相同贡献值（稍微推一下，好求）。

所以我们维护答案的差分数组，最后前缀和即得答案。

复杂度线性。

* * *

最终获得二等奖，一等奖分数线为 rk10，非常可惜，最后半分钟的时候我们还是 rk10，结果两个队突然各过一题。

但是奖品应该还不错的，每个人价值 300r 的东西，比隔壁 thupc 好多了（主要是dalao都去那边了 题又难 所以remakers他们甚至都没拿到啥奖品）。

* * *

Upd：[官方题解](https://mp.weixin.qq.com/s?__biz=MzA4MTAzMzQ5NA==&amp;mid=2650884697&amp;idx=3&amp;sn=c4d15db0719accf90d0872bcc5916734) 出了，快去看看吧！</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17444681.html</id>
    <title type="text">第一届粉兔杯游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-05-30T14:19:00Z</published>
    <updated>2023-05-30T14:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17444681.html" />
    <content type="text"># -inf

VP 群学会了 flower bot CF duel 决斗。

# 2023年5月27日

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530223302765-1158927398.jpg)

看到 LA 群里 EA 宣传粉兔杯，赶紧报名了。

32 人马上凑齐了。

[比赛link](https://challonge.com/zh_CN/e00nhpel)

```text
注册的选手共 32 人：
EternalAlexander qq = 2496097294, rating = 2738
swiftc qq = 1149395947, rating = 2433
_chroneZ qq = 209752953, rating = 1537
Sugar0612 qq = 3332538139, rating = 2486
hhoppitree qq = 7145069, rating = 2464
tatianyi qq = 2271015053, rating = 1008
Heltion qq = 2924690115, rating = 3023
PinkieRabbit qq = 3507898808, rating = 2921
Kevin114514 qq = 2133986387, rating = 2715
_rqy qq = 1458814497, rating = 2709
Nanani qq = 3405401873, rating = 1734
CrossFire2hard4me qq = 921975239, rating = 0
jiangly qq = 1902235419, rating = 3741
Mine_King qq = 1395354790, rating = 2195
syf2008 qq = 203981192, rating = 2235
_zzh qq = 1513054585, rating = 1661
misono_mika qq = 854725206, rating = 2291
RootMirzayanov qq = 1841729054, rating = 453
weishenwoaini qq = 3111782049, rating = 1075
ethan_enhe qq = 2607284668, rating = 2296
369Pai qq = 1942085982, rating = 1873
wsc2008qwq qq = 1364479974, rating = 1968
nosajuil qq = 3434037620, rating = 1513
ix35 qq = 2757336405, rating = 2552
installb qq = 3567362900, rating = 2458
xjrjyy qq = 1479412322, rating = 1709
tiger2005 qq = 3478556308, rating = 2178
LXH-cat qq = 1960740186, rating = 2618
RegenFallen qq = 854349038, rating = 2176
Wangxueyi qq = 2716790565, rating = 2153
psoet qq = 3179211762, rating = 2614
-skyline- qq = 1872518274, rating = 2729
```

# 2023年5月28日

和 [chroneZ](https://codeforces.com/profile/_chroneZ) 约好晚上打，赢了。

# 2023年5月29日

粉兔和 ix35 一起开播，垒球 ix35 被打爆。

[题目（建议改为：粉兔和垒球的故事）](https://www.luogu.com.cn/problem/CF256D)

# 2023年5月30日

换季，突然升温，昨晚着凉了。

13:00 粉兔找我打，当时在机房里清水鼻涕不断打地答应了。

[对战的题目](https://www.luogu.com.cn/problem/CF827D)

[我的题解](https://www.luogu.com.cn/blog/ShaoJia/solution-cf827d)

果然不敌对手，沦为 16 强。

打完就润回家了，泡感冒药卧病在床。

**粉兔杯被粉兔打爆，是不是合情合理（**

和陈亮舟交手，感觉好荣幸（

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530223823933-752906823.png)

我止步于此。

![](https://img2023.cnblogs.com/blog/2213867/202305/2213867-20230530223853723-1740343898.png)

↑获奖证书

据说第二轮在暑假比，期待。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17494944.html</id>
    <title type="text">手搓二进制加法电路-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-06-20T13:52:00Z</published>
    <updated>2023-06-20T13:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17494944.html" />
    <content type="text">前景提要：APIO2023 T3 考手搓门电路和通信 只拿了 8pts。

2023年6月15日 我在油管看到了[真理元素的视频](https://www.youtube.com/watch?v=FU_YFpfDqqA)，感觉那个二进制加法器很酷炫（虽然好像不炫），打算自己做一个。

然后就找到了[原 up 主 UsagiElectric](https://www.youtube.com/@UsagiElectric)，翻看了视频。

顺便把我积压了五年（真实时间）的单片机相关工具像收废品一样找了一些，坏的买了一些。

打算做一个八位无符号（有无符号好像没区别）加减法器。

淘宝上看到继电器（带焊好板子和端子的那种）大概三元一个，有点小贵（因为门电路要用的太多了），打算用晶体管。但是用晶体管就没有声了，一点都不酷，而且这样下去想要 CMOS 了，遂改回继电器。

搞了两三天嘉立创 PCB 制作啥的，有点繁琐，而且至少 5 片开做。另一种选择是买板上的继电器然后铜柱搭上然后用端子暴力连线。但是这样好像太草率了。

理论基础真的搞了好久。

还有我不知道 UsagiElectric 为啥要 latch 和 delay。

而且提到二极管压降很厉害，注意避免。

用立创 eda 编辑，引脚孔间隔 100mil。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17516065.html</id>
    <title type="text">吉司机 吉如一 吉老师 历史最值 历史和 兔队 楼房重建 Segment Tree Beats 线段树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-06-30T02:52:00Z</published>
    <updated>2023-06-30T02:52:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17516065.html" />
    <content type="text">CF793F Julia the snail</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17520174.html</id>
    <title type="text">拉格朗日乘数法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-01T15:23:00Z</published>
    <updated>2023-07-01T15:23:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17520174.html" />
    <content type="text">[百度百科](https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95/8550443)

[wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier)

偷个图：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230701232049274-1710716068.png)

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230701232115271-1135774066.png)

简单举个例子：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230701232157793-2060066431.jpg)

~~妹子来问我的题目~~

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230701232227031-1685196422.jpg)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17528190.html</id>
    <title type="text">保序回归-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-05T04:00:00Z</published>
    <updated>2023-07-05T04:00:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17528190.html" />
    <content type="text">[日报](https://www.luogu.com.cn/blog/Graygoo/qian-tan-bao-xu-hui-gui-wen-ti-ji-ji-te-shu-tiao-jian-xia-di-geng-you-post)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17529640.html</id>
    <title type="text">2023夏hdu多校游只因-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-05T11:42:00Z</published>
    <updated>2023-07-05T11:42:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17529640.html" />
    <content type="text"># def

| 队员1  | 队员2  | 队员3  | 用户名  |  密码  |
| :----: | :----: | :----: | :-----: | :----: |
| 汪苏轶 | 徐司丞 | 章绍嘉 | team943 | 956334 |
| 吴到时 | 陈玉彬 | 张君游 | team944 | 219724 |
| 周以山 | 陈铭凯 | 章启莘 | team945 | 950100 |
|  周宽  | 姜宇辰 | 唐天行 | team946 | 155065 |
| 吴林瑄 | 桂阳熠 | 张泽铠 | team947 | 307307 |
| 陈昕阳 | 孙恒喆 | 吴泽岳 | team948 | 132360 |
| 叶子川 |  王宁  |  N/A   | team949 | 589704 |
| 朱哲贤 | 解奕楷 |  武悦  | team950 | 292157 |

战绩：shaojia-wsyear-chengcheng567

# 2023年7月18日

## def

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718174455724-1077842902.png)

Upd:重测了，如下

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230724184545235-236419984.png)

4-4-2

## Easy problem II

可以分块+平衡树做，完全过不去，使用 hdu 高超的评测机配合火车头和快读 $n^2$ 过 $10^5$。

## Mr. Liang play Card Game

高复杂度区间 DP。

## Play on Tree &amp; [AGC017D] Game on Tree

有根树上两人轮流删子树，谁删到根谁输
$$
sg(i)=\underset{j\in son_i}{\text{xor}}(sg(j)+1)
$$

# 2023年7月20日

## def

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230720182543719-782825941.png)

4.5-5.5-2

## Binary Number

傻逼细节题。

## Counter Strike

圆方树毒瘤题，细节很多，题面有锅（比赛不到 1h 时才说），我题数 .5 的由来。

## Or

傻逼 HDU，不要再出暴力能艹过去的题了！！！！！！！！！！

## Fencing the cows

傻逼 HDU，不要再出错解能艹过去的题了！！！！！！！！！！

写了一个在栅栏凸包上线性 DP 的 $n^2$ 做法，hack：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230720215119847-947065399.png)

最优解（三角形）一定不全在凸包上。

正解是预处理出 $n^2$ 条边是否合法，然后 Floyd 跑最小环。

## SPY finding NPY

前置芝士：恋爱 $37\%$ 法则。

后面忘了。

## Coin

网络流好题。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230720220424877-413304377.png)

# 2023年7月25日

## def

放暑假，鸽了，只有 wsy 和半个 xsc 打。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230725210541568-1015978534.png)

得知尺子 rui_er 队号 1027。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230726082211431-683487240.png)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17533201.html</id>
    <title type="text">从子串构造到一类有向图-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-06T11:50:00Z</published>
    <updated>2023-07-06T11:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17533201.html" />
    <content type="text"># 写在前面

我的参考资料只有三道题和其中两道的题解，不知道有无先人研究，或者说这玩意太显然了。

# 从子串构造引入

首先看一道模拟赛题的弱化版：

&gt; 给你正整数 $n$，让你构造一个长度为 $2^n$ 的循环 01 串使得所有长度不超过 $2^n$ 的本质不同非空子串个数最大。

首先给出上界：$2^{2n}+2^{n+1}-n2^n-2$。原因是所有长度 $\le n$ 的本质不同子串均出现，长度 $\ge n$ 的所有子串（这里的“所有”指 $2^n$ 个）均本质不同。

接着考虑构造达到上界的串：
* 如果所有长度 $=n$ 的本质不同子串均出现，则长度 $&lt;n$ 的也是。
* 如果所有长度 $=n$ 的所有子串均本质不同，则长度 $&gt;n$ 的也是。

所以接下来只要考虑长度为 $n$ 的子串即可。

考虑建图：共 $2^n$ 个点编号 $0,\dots,2^n-1$，每个点 $x$ 向 $2x$ 和 $2x+1$ 号点（以下点编号默认模 $2^n$）连有向边，这个图的哈密顿回路与达到上界的 01 串一一对应。

原因：把点编号看作长度为 $n$ 的 01 串，边看作类似自动机的转移边，相当于在当前匹配之后追加一个比特。

但是哈密顿回路不好求，考虑这种图的性质。

# 定义

定义 $G_m(m\in\mathbb N^+)$ 为点编号 $0,\dots,m-1$ 的有向图，每个点 $x$ 连出去两条边，指向 $2x\bmod m$ 和 $(2x+1)\bmod m$。

# 性质

## 〇

### statement

$G_m$ 中每个点都恰好有两个入度。

### 证明

当 $m$ 为奇数时模 $m$ 意义下有 $2$ 的逆元，所以每个点 $x$ 的入度来源为模意义下的 $x/2$ 和 $(x-1)/2$。

当 $m$ 为偶数时，奇数编号的点只能被 $2x+1$ 得到，偶数的只能 $2x$，而在模 $m$ 意义下知道 $2x$ 后可能的 $x$ 恰有两个，所以点 $x$ 的入度来源为模意义下的 $\lfloor x/2\rfloor$ 和 $\lfloor x/2\rfloor+m/2$。

### tips

上面入度来源点很重要。

从这里开始我们就发现要对 $m$ 的奇偶分类讨论。

## 一

### statement

$G_m$ 都有欧拉回路。

### 证明

我们已经证明了每个点出入度均为 $2$，接下来只要证连通。

* $m$ 为奇数时模意义下 $x\leftrightarrow x/2\leftrightarrow x+1$，所以整张图连通。
* $m$ 为偶数时模意义下 $x\leftrightarrow 2x\leftrightarrow x+m/2$，对峙点之间连通，将 $m\to m/2$ 不断将同余系减半直到变为奇数的情况。

所以 $G_m$ 连通，得证。

## 二

### statement

当 $m$ 为 $&gt;1$ 的奇数时 $G_m$ 没有哈密顿回路。

### 证明

点 $0$ 和 $m-1$ 都只有一条不是自环的入边，且都来自 $(m-1)/2\bmod m$，遂无哈密顿回路。

### tips

那 $m$ 为偶数的时候呢？往下看。

## 三

### statement

$G_m$ 的欧拉回路与 $G_{2m}$ 的哈密顿回路一一对应。

### 证明

将 $G_m$ 中的边如下编号：点 $x$ 连向 $2x\bmod m$ 的边编号为 $2x$（注意这里没有 $\bmod$），连向 $(2x+1)\bmod m$ 的边编号 $2x+1$。

这样我们将 $G_m$ 中 $2m$ 条边标上了互不相同的 $[0,2m)$ 中的整数。

新建一个图 $H$，每个点代表 $G_m$ 中一条边，一条边 $(x,y)$ 代表走完 $G_m$ 中 $x$ 号边后能紧接着走 $y$ 号边。

不难证明 $H$ 和 $G_{2m}$ 是同构的（甚至点标号也相同），证毕。

### tips

其实 $G_{2m}$ 的哈密顿回路也可以直接无脑跑+在 $0,m-1$ 点小特判即可求，但是这样不够优雅。

# 题

## 开头提到的子串构造

将 $G_{2^n}$ 的哈密顿回路转成 $G_{2^{n-1}}$ 的欧拉回路即可。

## CF325E The Red Button

$n$ 为奇数无解，否则转成 $G_{n/2}$ 的欧拉回路。

[我的远古题解（可能没啥参考价值）](https://www.luogu.com.cn/blog/ShaoJia/solution-cf325e)

## 蒜头君组序列

[题目 Link](https://www.jisuanke.com/problem/T3860)

就是 $m\le 512$，统计 $G_m$ 的不同哈密顿回路个数。

$m$ 为奇数时答案为 $0$，否则统计 $G_{m/2}$ 的欧拉回路个数，用 Best 定理计数即可。

因为 Best 定理中要用 Matrix-tree，所以复杂度 $O(m^3)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17541322.html</id>
    <title type="text">圆的反演变换-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-10T07:34:00Z</published>
    <updated>2023-07-10T07:34:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17541322.html" />
    <content type="text">[反演变换 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/inverse/)

[圆的反演变换_圆反演_ACdreamers的博客-CSDN博客](https://blog.csdn.net/acdreamers/article/details/16966369)

[Inversive geometry - Wikipedia](https://en.wikipedia.org/wiki/Inversive_geometry)

[Problem - 6158 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=6158)

[Problem - 4773 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=4773)

[Finding the Radius for an Inserted Circle - 计蒜客 (jisuanke.com)](https://www.jisuanke.com/problem/A1283)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17541735.html</id>
    <title type="text">2023sol2-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-10T09:19:00Z</published>
    <updated>2023-07-10T09:19:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17541735.html" />
    <content type="text"># CF813D Two Melodies &amp; CF818G Four Melodies

建费用流，每个位置拆点，流量和代价均为 $1$，位置之间的边数 $O(n^2)$ 吃不消，使用同值/同余系前缀优化建图，边数 $O(n)$，跑最大费用最大流，由于费用流复杂度 $O(nmf)$，复杂度 $O(n^2k)$，其中 $k=2/4$ 为 Melodies 数量。

# 计蒜客信息学 10 月 CSP-S 组复赛模拟赛 T3 计算

特判 $b=a^2$，由于 $(a-1)^2\le b&lt;a^2$，关键式子：
$$
\left\lfloor(a+\sqrt b)^i\right\rfloor
=(a+\sqrt b)^i+(a-\sqrt b)^i-1
$$

问题转化为求
$$
\left(\sum_{i=1}^n(x^i+y^i-1)\right)^2
\\
x=a+\sqrt b,y=a-\sqrt b
$$

到这里二次剩余魔改复数类就可以快速幂了，但是这不够优雅。

由于 $x+y,xy$ 都是整数，然后
$$
x^k+y^k=(x+y)(x^{k-1}+y^{k-1})-xy(x^{k-2}+y^{k-2})
$$
三阶矩阵快速幂加速递推即可。

# CF1835C Twin Clusters

（一）

由于生日悖论，随就完了。

[Code](https://codeforces.com/contest/1835/submission/226509597)

（二）

首先发现区间不交是没用的，只要两个区间左右端点分别不相同即可。接下来做前缀，并存下 $lst_i$ 表示上一个前缀 xor 和的高 $k$ 位值为 $i$ 的位置。

顺序扫到一个位置的时候，若存在，取出 $(lst_{a_i&gt;&gt;k},i]$ 这个区间的 xor 和。

发现这玩意非常巧妙，因为一共有 $2^{k+1}+1$ 个前缀（包含 $0$ 位置），而前 $k$ 位只有 $2^k$ 种值，由抽屉原理至少有 $2^k+1$ 个上述区间存在，而后 $k$ 位也只有 $2^k$ 种值，因此必然有两个区间 xor 和一样。

做完了。顺便证明了必然有解。

[Code](https://codeforces.com/contest/1835/submission/226534362)

# LOJ2399. 「JOISC 2017 Day 4」绑架 2 AT_joisc2017_j 誘拐 2 (Abduction 2)

考虑全局值最大的路，显然车不可能跨越这条路，所以考虑车在哪半边，递归成子问题。

发现子问题都是一个矩形的形式，且到达四边上后的答案可以表示为定值（原图的边框）或者一次分段函数。

找最大值可以用 ST 表等手段。

有一些细节，具体看代码，复杂度 $O(Q(H+W))$。

比你想象的要好写。

# P5443 [APIO2019] 桥梁

将时间轴分块，处理出块之前每条边的权值（以及按权值排序的结果）以及块内涉及到哪些边。

按值扫描块内询问，并用并查集（非撤销部分）维护连通性。

到一个询问时，扫描出每个块内涉及的边边权，用并查集（撤销部分）维护连通性。

过了这个块改变涉及的边权，将这些边排序后归并其他边。

复杂度 $O(\frac{q}{B}(m+B^2\log+n\alpha))$。

# P3260 [JLOI2014] 镜面通道

**结论：** 在本题中从左端到右端如果连通（能透空气），则能透光。

$n$ 个仪器两两判有没有交后拆点建图，从通道上方到通道下方求最小割即可。

但是该结论不好证明。

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230922200910870-1441807938.png)

# CF838D Airplane Arrangements &amp; CF1528F AmShZ Farm

序列转等概率环模型。

AmShZ Farm 在此模型之后还要卷积求 第二类斯特林数·行，所以我们拿 Airplane Arrangements 举例。

登机合法方案数等价于：新增一个位置之后 $n+1$ 个位置接成一个环，每个人选择 $[1,n+1]$ 中的一个位置和左右中的一个方向，然后从此位置沿着该方向走直到空位置后坐下，$m$ 个人坐完后 $n+1$ 号位置空着的方案数。

发现我们通过增加新位置并接成环，构造了循环对称性。在本题中，代表 $n+1$ 个位置最后被空着的方案数相同。

所以本题的答案为 $\frac{n+1-m}{n+1}2^m(n+1)^m$。

# P8990 [北大集训 2021] 小明的树

考虑如何快速计算一种树的一个时刻的权值，记目前亮了 $i(\in[1,n-1])$ 盏灯，当前两端灯都暗的边数为 $x$，两端一暗一亮的边数为 $y$，此时刻权值为：
$$\begin{cases}
y &amp; ,x=n-i-1
\\
0 &amp; ,\text{otherwise.}
\end{cases}$$
原因是暗的灯要形成连通块，边数 $=$ 点数 $-1$。

所以当树变动的时候，我们动态维护长度为 $n-1$ 的两种值的数组，通过记录目前的树中每个点的邻居有多少在其之前/之后点亮来维护。

注意到 $x\le n-i-1$，所以问题就变成：
* 第一种/第二种值区间加。
* 全局查询第一种值的最大值。
* 全局查询第一种值取到最大值的位置的第二种值之和。

线段树维护即可。

# CF1553I Stairs

原序列中极长颜色段长度一定是该颜色值的倍数，否则答案为 $0$。

我们就将每颜色值个该颜色缩在一起，表示这是一个值域连续单调的段。

比如说原序列为 `2 2 2 2 2 2 3 3 3 1 1`，变换后为 `2 2 2 3 1 1`。

由于之后发现值只有是否是 $1$ 有用，将所有非 $1$ 的值变为 $0$：`0 0 0 0 1 1`。

设目前序列为 $a_1,\dots,a_n$。

接着就考虑容斥，枚举 $n-1$ 个缝分别是否合并，设合并了 $x$ 次，合并后剩下 $y$ 个 $1$（任意两个合并之后都是 $0$）。

则其贡献为 $(-1)^x(n-x)!2^{n-x-y}=(-1)^x(n-x)!2^{n-x}2^{-y}$。

枚举 $2^{n-1}$ 种情况不现实，考虑 DP，一个 $1$ 最后能被保留当且仅当其两边均没有合并。

设 $[x^k]f_{i,0/1}$ 表示处理完前 $i$ 个缝，第 $i$ 个缝是否合并，目前合并了 $k$ 次的所有方案的 $\sum 2^{-y}$（$y$ 表示当前确定能保留的 $1$ 的个数）。

$a_i=0/1$ 是两种不同的转移，但是都是简单地乘一个项数 $\le 2$ 的多项式。

自然地将转移写成 $2\times 2$ 的多项式矩阵的形式，由于结合律我们分治维护连乘即可，多项式乘法使用 NTT。

最后答案为 $\sum_{i=0}^{n-1}(-1)^i(n-i)!2^{n-i}[x^i]f_{n,0}$。

复杂度双 $\log$。

# CF1553H XOR and Distance

直接做就好了。

接下来我们只考虑值域序列，即一个位置值为 $1$ 表示存在这种值（若 $&gt;1$ 则所有答案均输出 $0$ 即可）。

将值域序列建满二叉树，$f_{i,j}$ 表示高几位为 $[2^j\sim 2^{n-1}]i$ 的那些值经过 xor $[2^0\sim 2^{j-1}]i$ 变换后的序列。

答案即为 $f_{*,n}$ 这些序列分别的最小相邻差。

我们有 $f_{i,j+1}=f_{i,j}+f_{i\text{ xor }2^j,j}$（表示拼接）。

维护所有 $f_{*,*}$ 的最小、最大位置和目前的最小相邻差即可，类似最大子段和那样合并。

# LOJ2390. 「JOISC 2017 Day 1」开荒者 AT_joisc2017_a 開拓 (Cultivation)

每个草最后蔓延到的位置都是相同的矩形，矩形四边扩展长度取决于四种风各吹了几年，最后有草的地方就是这些矩形的并。

设矩形大小为 $X\times Y$（$X$ 轴竖直向下，$Y$ 轴水平向右），设四个方向的风各吹了 $U,D,L,R$ 年，考虑 $U+D$ 有几种可能最优取值：

* 一个草向上到顶 $+$ 一个草向下到底。

* 两个草蔓延到两者 $X$ 轴差一。

共 $O(n^2)$ 种取值，枚举。

现在把草看作一条宽度为 $1$、长度为 $U+D+1$ 的竖线。

对于地图的一行，存在对 $L,R$ 的三种限制：$L\ge l,R\ge r,L+R\ge lr$。

对于这样的限制，横向部分答案为 $\max(l+r,lr)$。

转化视角变成地图上下平移，就变成了滑动窗口、三个值分别取 $\max$ 的问题。

由于本质不同（即三个限制不同）的行数 $O(n)$，真就滑动窗口即可，注意预先处理（不管 $U+D$ 是多少）最多 $O(n^2)$ 种行的状态（三个限制的值）。

使用三个单调队列即可做到 $O(n^3)$，但是我鸽了，写 ST 表 $O(n^3\log n)$。

# CF1774G Segment Covering

先将所有包含别人的线段去掉，因为选了她之后被包含的可以选或不选，奇偶抵消。

如果三个线段满足 $l_1&lt;l_2&lt;l_3&lt;r_1(&lt;r_2&lt;r_3)$，且必选 $1$ 号线段，则可以将 $3$ 号线段去掉，原因也是奇偶抵消。

这样 $2$ 号线段就必选了，递推下去。

按照上面的方式删除线段后，剩下的所有线段都必须选择。所以如果剩下 $k$ 条线段，且满足并为询问区间，那么答案是 $(-1)^k$ 否则答案是 $0$。线段如下图所示：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230919105617863-1682530540.png)

若询问 $[l_1,r_5]$，按上图的答案就是 $0$，因为并集不是询问区间。

每条线段向在她右边且与她不交且左端点最小的线段连父亲边，转化成求树上 $c$ 级祖先。

复杂度线性对数。

# P8340 [AHOI2022] 山河重整

tag：互异分拆数，倍增。

[推荐这篇题解](https://www.luogu.com.cn/blog/CXY07/solution-p8340)

* * *

前置知识：如何 $O(n\sqrt n)$ 求出 $1\sim n$ 分别的互异分拆数。

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230914104411658-923508917.png)

👆 $12=5+4+2+1$ 一种 $12$ 的互异分拆方案。

我们一列一列看上面的图，设我们总共分拆出来的数的个数是 $c$，则 $n$ 的分拆数就是体积分别为 $1,2,\dots,c$ 的完全背包，体积之和恰好为 $n$ 的方案数，且每种体积的物品至少取一项。

由于 $c\le 2\sqrt n$，所以可以 $O(n\sqrt n)$ 背包。

👇请看代码

```cpp
f[0]=1;
int lim=sqrt(2*n);
per(i,lim,1){
	per(j,n,i+1) f[j]=f[j-i];
	per(j,i,1) f[j]=0;
	rep(j,i,n) f[j]+=f[j-i];
}
```

* * *

回到本题。**不合法**当且仅当存在一个值 $x\in [1,n]$ 使得 $x$ 不存在于原集合 $S$ 中且 $x&gt;\sum_{y\in S,y\le x}y$。我们统计不合法的个数，最后用 $2^n$ 减去其即为答案。

找到**最小**的符合上述式子的 $x$，当且仅当：

* $x\notin S$
* $\sum_{z\in S,z&lt;x}=x-1\quad \dagger$
* $\nexists y&lt;x,y\notin S\land \sum_{z\in S,z&lt;y}=y-1\quad \ddagger$

$\dagger$：原因是对于**合法**的集合 $S$，$\forall t,T=\{x|x\in S,x\le t\}$ 能 01 背包表示出来的值一定是一个正整数列的前缀。

记 $f_x$ 表示满足上面三项的最大值 $&lt;x$ 的 $S$ 集合个数。

观察 $\dagger$ 式，发现就是 $x-1$ 的互异分拆，记为 $d_x$。

考虑容斥掉 $y$。

结合 $\ddagger$ 式，将 $\dagger$ 式改写为 $\sum_{z\in S,y&lt;z&lt;x}=y-x$，记此方案数为 $e_{x,y}$。

得到递推式 $f_x=d_x-\sum_{y=1}^{x-1} e_{x,y}f_y$。

发现为了让 $e_{x,y}&gt;0$，$(y-1)+(y+1)=2y&lt;x$，所以 $y$ 有上界 $(x-1)/2$，就可以倍增求 $f$ 了。

👇$\sum_{y=1}^{(x-1)/2}e_{x,y}f_y$ 的求法也十分类似 $d_x$

```cpp
rep(i,0,n) g[i]=0;
int lim=sqrt(2*n);
per(i,lim,1){
	per(j,n,i) g[j]=g[j-i];
	per(j,i-1,0) g[j]=0;
	for(int j=0;j+(j+2)*i&lt;=n;j++) g[j+(j+2)*i]+=f[j];
	rep(j,i,n) g[j]+=g[j-i];
}
```

复杂度 $T(n)=T(n/2)+O(n\sqrt n)=O(n\sqrt n)$。

[代码](https://www.luogu.com.cn/record/124651395)

# CF1152F2 Neko Rules the Catniverse (Large Version)

首先转化一下条件：找到每个位置 $x$ 之前第一个比他值小的位置 $y$（若有），要有 $a_y+m\ge a_x$，不难发现这是充要条件。

有了这个转化就好做了，按值域从小往大 DP，$f_{i,j,k}$ 表示已经放完了所有值 $\le i$ 的位置，共有 $j$ 个（注意这里 $j$ 个值之间不放占位符，也就是说加入一个元素是在相邻两个之间的缝里插入），值 $\in(i-m,i]\cap\mathbb Z$ 的存在情况状压为 $k$ 的方案数。

按 $i+1$ 这种值是否存在分类（设 $M=2^m-1$）：

* 不存在 $f_{i,j,k}\to f_{i+1,j,2k\&amp;M}$。

* 存在 $f_{i,j,k}\times(1+\text{popcount}(k))\to f_{i+1,j+1,(2k+1)\&amp;M}$，这个系数表示插入的位置只能是开头或者值 $\in(i-m,i]$ 的位置之后的缝。

复杂度 $O(nK2^m)$，通过 Small Version。矩阵快速幂优化 $O((K2^m)^3\log n)$ 通过 Large Version。

# 「JOISC 2019 Day1」考试 AT_joisc2019_a 試験 (Examination)

等腰直角三角形数点模板题，即统计 $x\ge X,y\ge Y,x+y\le Z$ 的点数。

一种无脑的做法是将 $x+y$ 看作点的第三维，跑三维数点。

发现二维数点可以在非直角坐标系中进行，所以我们容斥：

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230911112337279-1597460892.png)

三个二维数点即可，基变换可能需要一点线性代数的知识。

# AT_wtf22_day1_b Non-Overlapping Swaps

我们对每个长度为 $k$ 的置换环用 $k-1$ 步排序即可，每两个环之间加一个 $(1,1)$ 操作保证 non-overlapping，接下来不妨设整个排列是一个置换环。

对一个置换环，将任意两个位置的出边交换，一定会裂成两个置换环。

设 $\{b_1,\dots,b_k\}=\{1,a_1,a_{a_1},\dots\}$，即环上从 $1$ 开始的遍历顺序。

对 $b$ 作小根笛卡尔树，设下标 $i$ 的父亲为 $f_i$，下标 $i:k\to 2$ 操作 $(b_{f_i},b_i)$，这样就是对的。

non-overlapping：操作后要么操作 $(b_{f_{f_i}},b_{f_i})$，要么操作 $i$ 的左子树（值一定都大于 $b_i$）。

最后 sorted：这次操作拆分成 $i$ 子树和剩余节点两个点集分别置换环，分别为子问题，最后一定是 $k$ 个自环。

# P6157 有趣的游戏

$\max_{x,y\in S}(x\bmod y)=S$ 中的严格次大值，如果只有一种值则为 $0$。

# cxy 推荐的题

题意：长度为 $n$ 的序列 $a_1,\dots,a_n$，$q$ 次询问每次给 $x$ 求 $\prod_{i=1}^n(x+a_i)\bmod 2^{32}$，强制在线。

对于 $x$ 为偶数，我们将连乘的多项式的低 $32$ 项算出来即可，因为更大的 $x$ 的幂在模意义下为 $0$。

$x$ 为奇数将式子改写为 $\prod_{i=1}^n((x-1)+a_i+1)\bmod 2^{32}$ 转化成偶数的情况。

设 $k=32$，复杂度 $O((n+q)k)$。

# P3766 核心密码B

$B$ 为参数 $=5\times 10^6$，下面式子约定 $n\ge B^2$。
$$\begin{aligned}
&amp;f(n)
=\sum_{i=2}^n\frac{g(i)}{i}
=\sum_{k\ge 2}\sum_{i=2}^{\lfloor\sqrt[k]{n}\rfloor}\frac{1}{i^k}
\\=&amp;\sum_{i=2}^{\lfloor\sqrt{n}\rfloor}\frac{1}{i^2}
+\sum_{k\ge 3}\sum_{i=2}^{\lfloor\sqrt[k]{n}\rfloor}\frac{1}{i^k}
\\ \approx &amp;\sum_{i=2}^{B}\frac{1}{i^2}
+\int_{i=B+.5}^{\lfloor\sqrt{n}\rfloor+.5}\frac{1}{i^2}
+\sum_{k\ge 3}\sum_{i=2}^{\lfloor\sqrt[k]{n}\rfloor}\frac{1}{i^k}
\\=&amp; \sum_{i=2}^{B}\frac{1}{i^2}
+\frac{1}{B+.5}+\frac{1}{\lfloor\sqrt{n}\rfloor+.5}
+\sum_{k\ge 3}\sum_{i=2}^{\lfloor\sqrt[k]{n}\rfloor}\frac{1}{i^k}
\end{aligned}$$

将所有询问离线排序扫指针。

复杂度 $O(n\log+B)$。

# CF283E Cow Tennis Tournament

思维：三元环转化。

发现三元环个数不好求，由于取消定向后是完全图，所以答案就是 $\binom{n}{3}-$ 非三元环个数。

非三元环个数 $=\sum_{i=1}^n \binom{\text{in}_i}{2}=\sum_{i=1}^n \binom{\text{out}_i}{2}$。

所以我们只要统计每个点最后的入度个数即可。

扫描线+值域 $\{0,1\}$ 区间异或 $1$ 区间求和线段树即可。

复杂度线性对数。

# CF1838E Count Supersequences

duel 被爆了。

发现答案和 $\{a\}$ 中的值无关。

考虑子序列自动机匹配，每个匹配上的位置到上一个位置之间不能有和她相同的值。

正着想很难，因为匹配结束前非匹配位置可选 $k-1$ 种，匹配完后 $k$ 种值随便选，这样式子会带 $\sum_{i=0}^m$。

所以反着考虑，计算没匹配完的序列个数，发现答案就是
$$
k^m-\sum_{i=0}^{n-1}(k-1)^{m-i}\binom{m}{i}
$$
就做完了，复杂度 $O(n)$。

# CF1187F Expected Square Beauty

设 $x_0\equiv 0$，则 $B(x)=\sum_{i=1}^n[x_{i-1}\ne x_i]$，设 $X_i$ 为 $[x_{i-1}\ne x_i]$ 事件。

则
$$
E(B^2(x))=E(\sum_{i=1}^n\sum_{j=1}^nX_iX_j)
=\sum_{i=1}^n\sum_{j=1}^nE(X_iX_j)
$$

当 $i=j$ 时 $E(X_iX_j)=E(X_i)$。

当 $|i-j|&gt;1$ 时 $E(X_iX_j)=E(X_i)E(X_j)$，即相互独立。

当 $|i-j|=1$ 时，不妨设 $j=i+1$，则
$$
E(X_iX_j)=E(X_iX_{i+1})=1-(1-E(X_i))-(1-E(X_{i+1}))+E([x_{i-1}=x_i=x_{i+1}])
$$
相邻两者或三者相等的概率可以通过线段交求得，剩下就好算了，复杂度线性对数（要求模意义下逆元）。

# CF1510I Is It Rated?

&lt;https://en.wikipedia.org/wiki/Randomized_weighted_majority_algorithm&gt;

# [AGC017D] Game on Tree

对于有根树 $T$，将 $root$ 复制 $|son_{root}|$ 份，每个拷贝下接一个 $root$ 的儿子子树。

显然这样变换后游戏是等价的，$\text{SG}$ 不变。

考虑根的一个儿子子树 $S$，根的一个拷贝下接 $S$ 的树设为 $S'$，则有 $\text{SG}(S')=\text{SG}(S)+1$。

证明可以考虑归纳：将每个状态都增加根节点，状态之间的转移边不变，而所有状态增加了一个直接切掉根的转移至 $\text{SG}=0$ 的只有根的状态，所以 $\text{SG}$ 整体 $+1$。

所以
$$
\text{SG}_i=\underset{j\in son_i}{\text{xor}}(\text{SG}_j+1)
$$

# CF427D Match &amp; Catch

将两个串分别与自己做 LCS（$f_{i,j}$ 表示右端点分别为 $i,j$ 的最长公共子串长度），求出每个右端点最小的子串长度 $a_i/b_i$ 使得这段子串在这个字符串里只出现一次。

然后做两个串的 LCS，判断每个 $f_{i,j}\overset{?}\ge \max(a_i,b_j)$，若是，则 $\text{ckmn}(ans,\max(a_i,b_j))$。

复杂度 $O((n+m)^2)$。

# CF799E Aquarium decoratio &amp; CF1374E2 Reading Books (hard version)

之前和 cyb duel 遇到了第一题，之后 vp 碰到了第二题。

分成四个集合：$AB,A,B,E$ 分别表示都喜欢、A 喜欢、B 喜欢、没有人喜欢的装饰花费集合。

将每个集合升序排序，最终答案一定是每个集合一段前缀。

枚举 $AB$ 集合中选的个数，推出 $A,B$ 分别至少要选几个，以及剩下还要选几个。

将 $E$ 和 $A,B$ 中没选上的装饰排序，最终会选一段定长的前缀，可用对顶堆实现。

复杂度线性对数，写起来很狗屎，而且第二题要输出方案。

# CF1468I Plane Tiling

这题 duel 打败了 cxy，他声称他不会线性代数。

将 $[dx_1,dy_1]^T,[dx_2,dy_2]^T$ 看作列向量 $A,B$。

首先 $|A\ B|$ 两个列向量的行列式（的绝对值）要 $=n$，这样 $A,B$ 张成的格点才占全部整点的 $1/n$，才会刚好要 $n$ 个起点。

$n$ 个起点可以这样取：找到 $A,B$ 两向量围成的平行四边形里的所有整点。

注意这些整点不包括下图碰到红色向量的整点（类似于左闭右开）：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230710220838920-1819836500.png)

由于坐标范围 $10^6$，所以可以对于每一行的整点二分找到左右边界。

这里为了方便可以将 $A,B$ 都倍长到第一、二象限。

[code](https://codeforces.com/contest/1468/submission/212509604)

官方题解更牛：

首先取 $gx=\gcd(x_1,x_2),gy=\gcd(y_1,y_2)$，设新向量 $A'(x_1/gx,y_1/gy),B'(x_2/gx,y_2/gy)$。

设 $A',B'$ 的子问题我们的构造点集为 $S$，则原问题我们的答案可以是 $\{(gx\cdot x+dx,gy\cdot y+dy)|(x,y)\in S,dx\in[0,gx)\cap\mathbb Z,dy\in[0,gy)\cap\mathbb Z\}$。

接下来构造 $S$，设 $|A'\ B'|$ 的绝对值为 $m$（$=n/gx/gy=|S|$），我们声称 $(0,0),(0,1),\dots,(0,m-1)$ 可以为答案。

证明：

$(0,0)$ 是格点，我们找到最小的正整数 $x$ 使得 $(0,x)$ 是 $A',B'$ 的格点，不妨设 $A',B'$ 前的系数分别是 $a,b$。

由于 $y$ 坐标不变，所以 $ay_1/gy+by_2/gy=0$，由于 $y_1/gy,y_2/gy$ 互质，所以 $a=ky_2/gy,b=-ky_1/gy$（$k$ 为整数）。带入 $x$ 坐标得到
$$\Delta x=ax_1/gx+bx_2/gx=\frac{k}{gxgy}(x_1y_2-x_2y_1)=\pm km$$
所以 $x=m$，得证。

[code](https://codeforces.com/contest/1468/submission/213136977)

# SP687 REPEATS - Repeats

枚举循环节长度 $L$，每 $L$ 个位置设一个关键点。显然若循环超过一次则必然会覆盖两个相邻的关键点。

枚举相邻的关键点，用 SA 求出 LCP 和 LCS，可以推出这两个关键点之间的序列不断向两边匹配能到的边界，更新答案即可。

复杂度 $O(n\log)$，原因是 SA + 调和级数。

# P3546 [POI2012] PRE-Prefixuffix &amp; CF961F k-substrings

设一个字符串 $S$ 最长 border 长度为 $k$，删掉两头各一个字符后的字符串为 $T$。若 $k&gt;1$，则 $T$ 存在长度为 $k-2$ 的border。

# CF1439C Greedy Shopping

重要性质：2 操作这个人买的东西一定不超过 $\log V$ 个区间。

原因是一段全买后如果买不起后一个了，那剩的钱一定小于这一段开头时的一半。

然后线段树上二分即可。

# CF1209F Koala and Notebook

先拆边，让每条边均为一个十进制位。

记最短路为那个超大的数字，考虑如何比较两个点 $x,y$ 的最短路：

* 如果数字位数不一样，则较短的更优。
* 否则，找到分别上一步的点 $x',y'$。
  * 如果 $x',y'$ 的最短路不同，则比较。
  * 否则，比较 $x'\to x,y'\to y$ 的边权。

所以维护 queue，每个元素是一个 vector，记录所有最短路相同的点。对于每个队首 vector，遍历出边边权 $0\to 9$，分别开新 vector 入队。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17546066.html</id>
    <title type="text">第二届粉兔杯游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-11T13:57:00Z</published>
    <updated>2023-07-11T13:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17546066.html" />
    <content type="text"># 预选赛

## 信息

[比赛link](https://codeforces.com/gym/451154)

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230711215629877-405625312.png)

## CF154A Hometask

简单题。

## CF144E Competition

首先有最后到达的格子不相撞则必然存在路线不相撞。

每个运动员能到达的最终位置是一个区间。

扫描线 + 堆，做完了。

## CF83E Two Subsequences

首先每个串长度相同，所以拼接有结合律。

考虑经典 DP：$f_{i,j}$ 表示当前拼接了前 $i$ 个串，第 $j$ 个串是最后一个和 $i$ 串不在同一个子序列中的串，的最小长度和。

转移时可以将第一维滚掉，只剩下 $f_j$。

考虑新加入串 $i$ 后的数组 $f$ 会如何变化。

记 $w(x,y)$ 表示在 $x$ 串后拼接 $y$ 串至少要增加多少字符。

一方面若 $i$ 串和 $i-1$ 串不在同一个子序列，遍历 $x:0\to i-2$，$\text{ckmn}(f_{i-1},f_x+w(x,i))$。

另一面若 $i$ 串和 $i-1$ 串在同一个子序列，遍历 $x:0\to i-2$，$f_x+=w(i-1,i)$。

通过记录全局 $f$ 值的 Delta 和串的每种后缀的 $\min f$ 即可 $O(nm^2)$ 通过（$m$ 为每个串串长）。

# 2023年7月16日

[榜单](https://challonge.com/zh_CN/4o58txko)

第一轮遇到 sjy，毫无疑问 lose 了。

## CF1841F Monocarp and a Strategic Game

题解：

若最终每种个数分别为 $a,b,c,d$，则推式子得到得分为 $(a-b)^2+(c-d)^2$，转化为：给定 $n$ 个向量，选出一些向量使得它们和的模长最大。

这是经典题，[ABC139F] Engines 或 P5955 [POI2018] Pionek

&lt;details&gt;
&lt;summary&gt;聊天记录&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230716204204158-1000347186.png)
&lt;/details&gt;

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230716202856019-1333452236.png)

# 2023年7月18日

打败了 feecle6418！啊？！

## CF989D A Shade of Moonlight

考虑 $w$ 的速度不是加在区间上而是在原点上，这样（纵轴是时间）：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718212617878-781881031.png)

由于 $w\ge 1$，两区间合法当且仅当相交矩形最上方的点在黄色区域。

发现固定向右上的区间，合法的向左上的区间排序后一定是一段后缀，用指针扫即可。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230718213405039-9499694.png)

~~聊天记录不放了，太高调了。~~ 算了还是放一下粉兔名言：

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230719084227084-1803650907.png)

# 2023年7月19日

被 sooke 打败了，三轮游了。

## CF1486F Pairs of Paths

经典结论：指定一个根，则两条路径的交一定过 lca 较深路径的 lca。

按两条路径 lca 是否相同分类。

相同：每个点作为 lca 开 map 简单容斥一下即可。

不同：由浅至深枚举较深路径的 lca，在 dfn 序上开 fenwick 简单容斥统计答案。

复杂度线性对数。

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230719171923401-761768294.png)

接下来就坐等收钱！期望 10r+15.4r。

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231103180015104-1409659732.png)

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231103180023510-1320267450.png)

结束了，发现自己不太想参加第三轮。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17547092.html</id>
    <title type="text">卡掉自然溢出哈希-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-12T03:30:00Z</published>
    <updated>2023-07-12T03:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17547092.html" />
    <content type="text">若当前哈希基底 $b$ 为偶数，则构造 $64$ 个 $\texttt{a}$ 前分别加 $\texttt{a},\texttt{b}$ 即可。

若 $b$ 为奇数。

设
$$
s_0=\texttt{"a"}
\\
t_0=\texttt{"b"}
\\
s_i=s_{i-1}+t_{i-1}
\\
t_i=t_{i-1}+s_{i-1}
$$
容易发现 $s_i,t_i$ 互为每个对应字符 flip。

举些例子：
$$
s_0=\texttt{"a"}
\\
s_1=\texttt{"ab"}
\\
s_2=\texttt{"abba"}
\\
s_3=\texttt{"abbabaab"}
\\
s_4=\texttt{"abbabaabbaababba"}
$$
设 $h(s)$ 表示 $s$ 串的哈希值。
$$
h(s_i)=h(s_{i-1})b^{2^{i-1}}+h(t_{i-1})
\\
h(t_i)=h(t_{i-1})b^{2^{i-1}}+h(s_{i-1})
$$
设 $H_i=h(t_i)-h(s_i)$，则
$$
H_0=1
\\
H_i=H_{i-1}(b^{2^{i-1}}-1)
$$
得
$$
\begin{aligned}
H_i&amp;=\prod_{j=0}^{i-1}(b^{2^j}-1)
\\
H_i&amp;=\prod_{j=0}^{i-1}(b-1)\prod_{k=0}^{j-1}(b^{2^k}+1)
\end{aligned}
$$
由于这些连乘项的值均为偶数，所以
$$
2^{i(i+1)/2}\mid H_i
$$
当 $i\ge 11$ 时即可卡掉 ull 自然溢出 hash。

[bzoj3097. Hash Killer I](https://hydro.ac/d/bzoj/p/3097)

[record](https://hydro.ac/d/bzoj/record/64ae1a02daa847aa41aedc6e)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17557099.html</id>
    <title type="text">【LGR-146-Div.2】洛谷 7 月月赛 III (dXqwq&amp;pigstd) Farewell Round-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-15T14:16:00Z</published>
    <updated>2023-07-15T14:16:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17557099.html" />
    <content type="text"># 前言

[比赛link](https://www.luogu.com.cn/contest/38434)

&gt; 出题人：dXqwq。
&gt;
&gt; 验题人：zhoukangyang，pigstd，zhiyangfan，Retired_kyEEcccccc，JohnVictor，wghyt1314，Kevin090228。
&gt;
&gt; 审题人：mrsrz。

神仙出的场当然要捧场。

# 题目

## P9459 浴眼盯真

一眼丁真题。

## P9460 众数 I

简单题，求出每个值都被消到某个值以下需要占掉几个位置即可。

## P9461 众数 II

结论：最小众数要么是 $1$ 要么是区间开头的数字。

然后先写个暴力。之后狂暴改写式子，最后发现是区间 cover，区间求 $\sum iv_i$ 和 $\sum i^2v_i$，线段树做即可。

线段树套 mod_int 跑了 989ms，机房伙伴全被卡常了！

[T3 AC Code](https://www.luogu.com.cn/record/115767789)

[dX 的题解](https://www.luogu.com.cn/blog/111055/solution-p9461)

枚举每个非 $1$ 众数计算贡献，用链表维护极长值 $\ge$ 当前枚举众数的段，计算答案即可，复杂度线性。

## P9462 终点

定根 $1$，根节点 $dep=0$，将每个点和根问一遍，若答案不为 $0$，当作返祖边。

会形成森林，高度最大的（若有多个任取一个）树的根一定 $dep=1$，设这个根为 $R$。

证明：考虑所有点最大的 $dep$ 为 $D$，$2^c\le D&lt;2^{c+1}$，则包含深度为 $2^c$ 的点的树高度（边的个数）为 $c$，不包含其的树高度一定小于这个值。

设 $R$ 为根的子树为 $S$。

我们再将森林所有树的根（不包括 $1$ 点）和 $R$ 问一遍。询问后可以顺次判断出每个点 $\overset{?}\in S$，随即通过询问与森林边确定出每个点的 $dep$。

这里我们的询问次数上界为 $2n-3$。

接着将每个点按深度升序排序，我们依次确定每个点的父亲边。设当前加入的点为 $x(\ne 1)$，我们将问题抽象成函数 $\text{slv}(y(=1),x)$，表示在 $y$ 子树中找一个和 $x$ 相邻且 $dep=dep_x-1$ 的点。

若 $dep_x-dep_y=1$，则答案为 $y$。

若 $2\mid dep_x-dep_y$，则询问 $x,y$，设回答为 $z$，则递归 $\text{slv}(z,x)$。

否则，任取一个 $x$ 的儿子 $x'$（必然存在），询问 $x',y$，设回答为 $z$，则递归 $\text{slv}(z,x)$。

这部分的询问次数为 $\sum_{i=1}^n \lceil\log_2 dep_i\rceil$。

这样感觉略超询问次数一点，但是卡不掉或者没卡。

[T4 AC code（赛后重制）](https://www.luogu.com.cn/record/115757148)

[dX 的题解](https://www.luogu.com.cn/blog/111055/solution-p9462)

↑ 将我前面的 $2n$ 次做到了 $n$ 次，省掉了求深度的步骤。

# 赛后

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230715225342374-143097818.png)

[赛后总结帖](https://www.luogu.com.cn/discuss/634365)

![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230715225753925-1929335540.png)

被 pigstd 点名了（激动

# Code Golf Challenge

&gt; 讲评之前的每题最短 AC 代码发 25 块钱，相同长度按最早的算，语言不限，直接在讲评开始之前按照【RID/题目编号/长度】的格式洛谷私信出题人即可。

[link](https://www.luogu.com.cn/blog/111055/code-golf-challenge)

[my code（818B）](https://www.luogu.com.cn/record/115766488)（由于完隐所以最后是小号供上去的）

由于 dX 新发的题解，我的最短可能不保。

7月16日下午我的最短被抢了（782B），7月17日上午鸽了模拟赛开始在 5ab 的帮助下加训缩代码。

[my code（726B）](https://www.luogu.com.cn/record/115766488)（好像完隐也能交）

但是我想当一回坏批，讲评前半小时再交给 dX。

被爆了，人家 495B。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17574542.html</id>
    <title type="text">CF1805-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-22T15:44:00Z</published>
    <updated>2023-07-22T15:44:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17574542.html" />
    <content type="text"># A. We Need the Zero

签到

# B. The String Has a Target

找到最小的字符中最靠后的一个拉到最前面来。

# C. Place for a Selfie

二次函数 $f(x)=ax^2+bx+c$ 在 $x=0$ 处的导数为 $b$，所以找到斜率为 $b$ 的前驱后继的正比函数判一下即可。

# D. A Wide, Wide Graph

和别的点距离最大值 $\ge k$ 的点集是一个连通块，其他点分别是孤立点。

由于到一个点距离最大的一定可以是树直径的端点，所以用类似的方法三遍 dfs 即可。

# E. There Should Be a Lot of Maximums

如果一种颜色至少有 $3$ 个，则删任何一条边肯定可以 double，如果至多有 $1$ 个，都不能 double。

对于恰好有 $2$ 个的颜色，不会 double 当且仅当断掉的是两点之间的任意一条边，平摊 dfs 序用 set 维护即可。

评论区有加强版：变成 $k-MAD$，即至少要 $k$ 个在同一个连通块内才能算。

我们仍然平摊 dfs 序，对于每条边，问题变为其子树在 dfs 序中区间的答案，和前缀 + 后缀的答案。

倍长数组，这样都变为区间问题。

然后是经典做法（类似于区间数颜色）：将询问离线挂在右端点，用线段树维护区间 $\max$，每次右端点 $+1$ 时改动这个位置向前跳 $k$ 次相同值后的位置。

# F2. Survival of the Weakest (hard version)

爵士好题。

两个有序序列维护和的前 k 小是经典问题，可以用堆做到线性对数，这里不再讨论。

首先发现 F1 的暴力都写不了，因为每次序列的值域可以倍增，会 overflow。

接下来所有序列默认是非降序排序的。

注意到 $[a_1,\dots,a_n]$ 变换一次后末项（注意这里长度减小了 $1$）$\le a_1+a_n$，首项 $=a_1+a_2$，差值 $\le a_n-a_2\le a_n-a-1$，所以每次变换序列极差不增。

那我们每次变换前可以将序列整体 shift 并记录位移，使得 $a_1=0$，变换后位移 $\times 2$。

恭喜你通过了 F1，复杂度 $O(n^2\log)$。

直觉告诉我们一开始的 $a_n$ 很难对最后的答案造成贡献。

结论是我们只要维护每个时刻序列前 $K=70$ 项，答案为最后序列的首项（加上位移），复杂度 $O(nK\log )$，通过 F2。

证明：

设 $[a_1(=0),\dots,a_n]$ 操作一次后变为 $[b_1(=0),\dots,b_{n-1}]$，再操作一次后变为 $[c_1(=0),\dots,c_{n-2}]$。

如果 $a_2+a_3\le a_{K+1}$，那么 $b_1,\dots,b_K$ 仍然是已知的。

否则，至少 $b_1,\dots,b_{K-1}$ 是已知的，再操作一次至少 $c_1,\dots,c_{K-2}$ 是已知的。

$b_K\le a_{K+1}-a_2,c_{K-1}\le a_{K+1}-a_3$ 由于 $a_2\le a_3,a_2+a_3&gt; a_{K+1}$，得到 $a_{K+1}-a_3&lt;a_{K+1}/2$。

所以每当 $K$ 减小 $2$，未维护最小的值（即 $a_{K+1}$）至少会减半，所以 $K$ 取 $2\log_2 V+O(1)$。

注意特判 $n=2$ 的情况，因为此时 $\binom{n}{2}&lt;n$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17578439.html</id>
    <title type="text">因数个数一个比较紧的上界-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-24T13:36:00Z</published>
    <updated>2023-07-24T13:36:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17578439.html" />
    <content type="text">![](https://img2023.cnblogs.com/blog/2213867/202307/2213867-20230724213038103-302510717.png)

$$
\log_n d(n)\le \frac{1.066018678\dots}{\ln\ln n}
$$
其中
$$\begin{aligned}
n&amp;=6\ 983\ 776\ 800
\\&amp;= 2^5\cdot 3^3\cdot 5^2\cdot 7\cdot 11\cdot 13\cdot 17\cdot 19
\end{aligned}$$
时取到等号，此时 $d(n)=2304$，定义了这个 $1.06\dots$ 的常数。

$n=10^{18}$ 时得到 $d(n)\le 1.4\times 10^5$，相比于 $2\sqrt n=2\times 10^9$ 还算紧的。

[论文链接](https://www.cambridge.org/core/services/aop-cambridge-core/content/view/D424A2915C0A748C93CF4962D0120B94/S0008439500065188a.pdf/majorations-explicites-pour-le-nombre-de-diviseurs-de-n.pdf)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17582633.html</id>
    <title type="text">竞赛图-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-07-26T07:35:00Z</published>
    <updated>2023-07-26T07:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17582633.html" />
    <content type="text">竞赛图缩点后是一个 DAG 竞赛图。

竞赛图一定有哈密顿路径，强连通竞赛图一定有哈密顿回路。

# [ARC163D] Sum of SCC

SCC 个数等于如下方案数之和：将 $n$ 个点分成两个集合 $S,T$，使得 $S$ 和 $T$ 之间只有 $S\to T$ 的边的方案数。其中 $1\le |S|\le n$。

原因是竞赛图缩点后是一个 DAG 竞赛图。

设 $f_{i,j,k}$ 为：前 $i$ 个点中，有 $j$ 个属于 $S$，$S\to T$ 中已经加入了 $k$ 条小编号到大编号的边。转移考虑每个点属于 $S$ 还是 $T$，更新 $j$ 和 $k$ 即可。

最后的答案即为：

$$
\sum _{i=1}^n\sum_{j=0}^m\binom{\binom{i}{2}+\binom{n-i}{2}}{m-j}f_{n,i,j}
$$

复杂度 $O(n^2m)$。

[code](https://atcoder.jp/contests/arc163/submissions/43242809)

# P9545 [湖北省选模拟 2023] 环山危路 / road

我和 little09 推了好久竞赛图 SCC 缩点，无果。

这种竞赛图边权全为 $1$ 的网络流状物，可以用竞赛图的性质优化。

首先将最大流转成最小割，变为分为两个点集 $S,T$，使得源点集合 $\subseteq S$，汇点 $\in T$，$S$ 向 $T$ 连的边数 $C$ 最少。

而一个 $k$ 个点竞赛图的边数是恒定的：$k(k-1)/2$。所以 $C=\sum_{x\in T}indeg_x-|T|(|T|-1)/2$。

所以除了源汇点我们优先将 $indeg$ 最小的那些点加入 $T$，最后将答案取 $\min$ 即可，复杂度 $O(n^2+nm)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17596178.html</id>
    <title type="text">出题 Ideas-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-08-01T04:59:00Z</published>
    <updated>2023-08-01T04:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17596178.html" />
    <content type="text"># 自然数幂和
$$
f_{a,b}(n)=\left(\sum_{i=1}^n i^a\right)^b
$$
问在一定条件内有多少本质不同的 $(a,b)$。

# Chess960

&gt; Chess960 是指菲舍尔制任意制国际象棋。它是由前国际象棋世界冠军鲍比·菲舍尔发明的一种新下法。棋子的初始排列顺序随机产生。但必须遵循下列原则：黑白双方的棋子呈对称排列，双象不得在同色格中，双车必须位于王的两侧，兵必须位于第二、第七横线。此种规则下，棋盘初始排列一共有960种（包括最传统的一种排列方式）。让棋手们从第一步就得从零开始思考，无谱招可循。

## Easy version

现在变为 $a$ 种马，$b$ 种车（每对车都要分居王两侧），$c$ 种象（每对象都不得在同色格中），问有多少种排布方案。

## Hard version(1)

现在变为 $a$ 种马，$b$ 种车，$c$ 种象，$d$ 对王&amp;后，$m$ 条限制分别是第 $i$ 对车要分居在第 $j$ 个王左右，问有多少种排布方案。

## Hard version(2)

现在变为 $a$ 种马，$b$ 种车，$c$ 种象，第 $i$ 种象要放 $f_i$ 个，位置编号模 $f_i$ 各不相同，问有多少种排布方案。

## Insane version

两个 Hard version 结合。

# 我的世界

给一个 $n\times m$ 的地图，初始每个位置高度均为 $0$，每次将一个位置的高度 $+1$，问起点能否到终点，走路的方式允许你跳一格高。

感觉没前途。

# 辛普森悖论

计数在一定范围内的个数：

四个两维都是非负整数的向量 $\vec a,\vec b,\vec c,\vec d$，使得：

* $\vec a&lt;\vec c$。
* $\vec b&lt;\vec d$。
* $\vec c+\vec d&lt;\vec a+\vec b$。

其中 $+$ 为向量加法，$\vec x&lt;\vec y$ 表示 $\vec x$ 与 $\vec y$ 的叉积 $&gt;0$。

unsolved.

# I wanna maker

构造一个 i wanna 地图（空、墙、存档点、设置重力为上、设置重力为下、单向门），kid 不能跳，下落不能左右移动，使得存档点之间可达性与给定图相同。

借鉴了 CF1089M Minegraphed 的 idea。

构造如下：
![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231207223316437-1115131980.png)

每个风洞（以及画作二极管的单向门）宽度为 $2$，有有向边则加装一个向上重力，注意中间加若干宽度为 $3$ 的选择器来选择到达一个接口时走不走这条边。

曾经在想能不能少一点道具，但是思考了很久不会 DAG 可达性同构的平面镶嵌（以及是否一定有解），问题主要出在 $K_{3,3}$ 的细分（每条边上挂很多点），不太好处理。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17611171.html</id>
    <title type="text">CF1854-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-08-07T04:59:00Z</published>
    <updated>2023-08-07T04:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17611171.html" />
    <content type="text"># CF1854A2 Dual (Hard Version)

如果整个序列没有同时出现正数和负数，则做一次前缀和或后缀和就可以单调不降。

则在之前我们还有 $12$ 步操作。

如果正负一方个数不超过 $7$ 个，则将一个数翻倍 $5$ 次后将那一方填平。

否则，双方都不超过 $12$ 个，这样找到绝对值最大的一个将另一方填平。

# CF1854B Earn or Unlock

当你想到这道题可以 bitset 后，就简单了。

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230807183753148-1763141354.png)

# CF1854C Expected Destruction

期望好题。

如果没有合并全走到 $m+1$ 处消亡，则答案为 $\sum (m+1-S_i)$。

考虑合并的过程构成一棵树的形态（类似 Kruskal 重构树），我们多算的答案就是合并时的位置到 $m+1$ 的距离。

注意到只有相邻两个 $S$ 可能合并，而且合并的贡献之间是独立的。

所以设 $f(x,y)$ 表示两个值为 $x,y$ 的概率。

初始时两个的位置的 $f=1$，剩下的可以 $O(m^2)$ 递推。

最后减掉的贡献为 $\sum (m+1-i)f(i,i)$。

将每一对 $(S_i,S_{i+1})$ 作为初始位置放进去 DP 即可，总复杂度 $O(nm^2)$。

当然也可以将所有 $(S_i,S_{i+1})$ 放进去一起 DP，这样复杂度 $O(m^2)$。

# CF1854D Michael and Hotel

发现通过二分可以 $9$ 步内知道任意点走特定步后到达的位置。

设 $K=73$，由 $1$ 开始走足够多步找到基环上的一个点 $P$，以及其 $K-1$ 阶内的所有后继（就是找到环上连续的 $K$ 个点），这样步数是 $9K$。

我们通过这样的方式将环上的点翻倍（设当前点数为 $k$）：对于每个未知的点，查询走 $k$ 步后能否到目前已知的点，然后 $k$ 翻倍。

这种方式同时可以确定非基环的点。

我们翻倍 $3$ 次，考虑 $P$ 子树内的点要被判断，则 $7K$ 至少要 $n+O(1)$，$73$ 满足条件。

这部分操作次数 $3(n-K)$。

加起来不超过 $1938&lt;2000$。

注意需要特判环长 $&lt;K$，即初始 $K$ 个是否有重复。

# CF1854E Game Bundles

看 [代码](https://codeforces.com/contest/1854/submission/217538411) 吧，我不好评价这种随机做法（甚至调参以至于不超时）。

# CF1854F Mark and Spaceship

官方题解说什么二维转四维反例数量很少，晕，自己看去。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17612568.html</id>
    <title type="text">CF1051-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-08-07T11:49:00Z</published>
    <updated>2023-08-07T11:49:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17612568.html" />
    <content type="text"># CF1051E Vasya and Big Integers

线性 DP，长度在 $(|l|,|r|)$ 的转移一定没问题（注意在前缀和的时候直接忽略前导零的转移）（特判值为 $0$ 的转移），长度为 $|l|$ 或 $|r|$ 用二分+hash 比大小即可，复杂度线性对数。

# CF1051F The Shortest Statement

将不超过 $40$ 个关键点（非生成树边的端点）拿出来跑 Floyd，询问 $x,y$ 可以直接走树边或者枚举一对关键点 $x',y'$ 使得 $x\to x'\to y'\to y$。

用 $O(1)$ lca 等方法可以做到 $O(n\log +(m-n)^3+q(m-n)^2)$。

接下来是 [这篇](https://www.luogu.com.cn/blog/Garyhuang1234567890/cf1051f-ti-xie) 的思路：

我们将关键点的所有虚树节点也变为关键点，这样再跑关键点两两最短路，询问 $x,y$ 时接口关键点只有可能与 $x,y$ 分别相邻（即之间没有关键点），由于虚树，接口关键点分别至多两个，询问复杂度线性。

总复杂度可以做到 $O(m+(m-n)^2\log +q)$。

# CF1051G Distinctification

发现两种操作互为逆操作。

最后目标是最小化 $\sum a_ib_i$。

我们一定会将一个 $a$ 的值域连续段左端点不变，右端点扩充直至每个 $a$ 的值有一个元素，且随着 $a$ 增大元素的 $b$ 减小，这样 $\sum a_ib_i$ 最小。

用并查集维护值域连续段，每个连续段用动态开点线段树维护 $b$ 的值。

插入一个元素后会最多执行两次合并两个连续段的操作，我们在线段树合并的同时统计对答案的贡献即可。

具体地，线段树合并之前先将两个值域左端点对齐，然后增加的对答案的贡献就是：A 树左子树的和 $\times$ B 树右子树的个数，以及将 A B 交换后再算一遍。

↑其实就是考虑归并的时候每个元素会被位移多少。

复杂度线性对数。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17642217.html</id>
    <title type="text">[SDCPC2023] 第十三届山东省 ICPC 大学生程序设计竞赛 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-08-19T03:17:00Z</published>
    <updated>2023-08-19T03:17:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17642217.html" />
    <content type="text">Luogu 题号：P9556~P9568

[luogu重现赛](https://www.luogu.com.cn/contest/126525)

&lt;details&gt;
&lt;summary&gt;一些图片&lt;/summary&gt;

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230819111537172-1090075648.png)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230819111945063-1304176066.png)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230819112010053-1905819329.png)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230819112032547-862662568.png)
&lt;/details&gt;

（hez机房八人八机）（rk1 是交 std 老哥）

傻逼题略过。

# L. Puzzle: Sashigane

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230819112156570-1863257223.png)

# E. Math Problem

肯定先除再乘，操作次数不超过 $O(\log)$ 暴力枚举判断即可，可能要开 `__int128`。

# B. Building Company

每项工程维护还有几类员工个数指标没有达成，然后像拓扑序一样做即可。

# J. Not Another Path Query Problem

数位 DP+判断连通性。

# M. Computational Geometry

如果确定了连续凸包边的段，那么对面的点一定会取到离“弦”所在直线最远的点。

顺序扫连续凸包边的段，那么对面的点一定是单调的，指针扫即可，复杂度线性。

# K. Difficult Constructive Problem

# F. Colorful Segments

# C. Trie

# H. Be Careful 2
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17659498.html</id>
    <title type="text">2023夏qbxt-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-08-26T13:38:00Z</published>
    <updated>2023-08-26T13:38:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17659498.html" />
    <content type="text"># 2023年7月24日

## 艾莎

长度 $\ge 4$ 的区间可以分为两个更小的且必定有一个不劣，所以答案区间长度 $\in\{2,3\}$。

然后用线段树维护每个长度为 $2$ 的区间和长度为 $3$ 的区间的最大值即可。

## 沙奈朵

分块题。

我们称一个 gap 为两个相邻的值不同元素之间的缝隙。

先考虑线性扫描询问区间咋做。维护前缀的 $x$ 值个数、所有 $x$ 值位置到此位置的 gap 数之和、目前的答案。

将上述方式分块维护信息即可（注意此时要维护的信息不止上述三个），复杂度 $O((n+m)\sqrt n)$。

## 绒绒鸹

将基环树的子树树剖，每个鸹只会改变 $\log$ 个链，维护这个即可（可用优先队列等），按将跳出该链的时间入桶，查询时直接查桶对应位置，复杂度双 $\log$。

# 2023年7月25日

No comment.

# 2023年7月26日

## 7.26 包围(besiege)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230826215715309-1048553969.png)

假如存在一个点只有一个前驱，那么显然题目条件不可能满足，否则一定可以，证明考虑调整法。

## 7.26 武器(weapon)

![](https://img2023.cnblogs.com/blog/2213867/202308/2213867-20230826215909530-813907074.png)

考虑将右侧点按点权倒序排序，然后依次使用匈牙利尝试加入匹配，能加就加。

证明：显然，对于每个前缀，我们以任意顺序把点加入匹配不会改变最大匹配，当每次最大匹配数改变时，我们加入的都是最大的那个点，所以一定最优。

但是这样太慢了。考虑匹配只会增加 $O(n)$ 次，而且 $n&lt;&lt;m$。考虑未匹配的左部点反向匈牙利搜索，那么加入一个右侧点时，只需要判定其能到达的左侧点中是否有点被搜索到过。如果有，那么更新匹配，否则无事发生。

用前缀和帮助判定，总复杂度 $O(n^3 + m\log m)$，复杂度瓶颈在排序。

# 2023年7月27日

## 7.27 病毒(virus)

对于每个点 $x$ 从 $[1,x-1]$ 中等概率选取一个点作为 father 的随机树，$y$ 在 $x$ 子树中（$x&lt;y$）的概率为 $\frac{1}{x}$。

原因是考虑从 $y$ 不断跳 father 的过程，在跳到点的编号 $\le x$ 之前前 $x$ 个点是等价的，所以概率就是 $\frac{1}{x}$。

## 7.27 合作(cooperate)

有解当且仅当每个连通块边数都是偶数，构造考虑 DFS 树。

## 7.27 激光炮(jgp)

对每个位置 $i$ 求出激光扫过位置 $i$ 的区间的右端点最小值 $R_i$。

对于每个位置，不被摧毁当且仅当 $[i,R_i]$ 中至少有一个防护罩。

对于任意 $i&lt;j\le R_i$，有 $R_j\le R_i$，所以 $[i,R_i]$ 形成树的结构。

每次加一个防护罩，相当于保住了一条从叶子到根的链。

长链剖分后找前 $k$ 长的带权链长求和即可。

# 2023年7月28日

## 酒馆

如果我们已经确定了所有酒馆档次，建大根笛卡尔树，则每个人去的酒吧就是其区间内深度最小的节点。

设 $f_{i,j}$ 表示被 $[i,j]$ 包含的所有人的最大收益，经典的区间 DP 转移：
$$
f_{i,j}=\max(f_{i, k - 1} + f_{k + 1,j} + g_{k, t})
$$
其中 $t$ 为这部分人能到达 $k$ 酒吧的人数，$g_{k,t}$ 表示第 $k$ 个酒吧共来 $t$ 个人的最大收益。

$g$ 的预处理可以用斜率优化。

复杂度 $O(n^3+nk)$。

# 2023年7月29日

No comment.

# 2023年7月30日

## 博得

两个字符串等价当且仅当【记录每个字符和这个字符上次出现位置（没上次要特判）的距离】的数组相同。

用这个性质魔改 KMP 即可。

## 字符串谷

将字符串抽象成点构建完全图，点权 $v_i$ 为字符串的权值，边权 $e_{i,j}$ 为两者 lcp 长度。

设 Alice 拿了集合 $S$，Bob 拿了其补集 $T$，最终局面评分
$$
\begin{aligned}
&amp;\sum_{i\in S}v_i+\sum_{i\in S,j\in S,i&lt;j}e_{i,j}-\sum_{i\in T}v_i-\sum_{i\in T,j\in T,i&lt;j}e_{i,j}
\\=&amp;
\sum_{i\in S}(v_i+\frac{1}{2}\sum_{j\in S,j\ne i}e_{i,j})-\sum_{i\in T}(v_i+\frac{1}{2}\sum_{j\in T,j\ne i}e_{i,j})
\\=&amp;
\sum_{i\in S}(v_i+\frac{1}{2}\sum_{j\ne i}e_{i,j})-\sum_{i\in T}(v_i+\frac{1}{2}\sum_{j\ne i}e_{i,j})
\end{aligned}
$$
最后一步是由于 $[S,T]$ 中的边加减抵消。

把括号内看作权值，两人轮流选最大即可。

# 2023年7月31日

No comment.

# 2023年8月1日</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17692293.html</id>
    <title type="text">一些东西-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-10T15:34:00Z</published>
    <updated>2023-09-10T15:34:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17692293.html" />
    <content type="text">音名：ABCDEFG

唱名：do re mi fa sol la si

乐名：主音 属音 下属音

口诀：大调 全全半全全全半 小调 全半全全半全全

小调可以理解为从 A 开始的调，写法上来讲是 1 2 b3 4 5 b6 b7（写法是相对于大调的升降关系）。

在一个调式里 ABCDEFG 每个字母都要出现，所以从黑键开始的调一般都称为降 X 调，这样不会出现重升降。

X Y 度：

Y 为这两个音（先去掉升降）在该调式中之间有几个音（闭区间内关键点个数）。

X：

从 C 开始到不低于其的音都有 $X\in\{\text{纯},\text{大}\}$。

口诀：一四五八无大小，二三六七不称纯。

即有：纯一度，纯四度，纯五度，纯八度，大二度，大三度，大六度，大七度。

小 $=$ 大 $-1$。

减 $=$ 纯 $\text{or}$ 小 $-1$。

增 $=$ 纯 $\text{or}$ 大 $+1$。

三和弦：根音、三音（根+三度）、五音（根+五度）

大三和弦：大三度+小三度 写法如：C

小三和弦：小三度+大三度 写法如：Cm

减三和弦：小三度+小三度 写法如：Cdim

增三和弦：大三度+大三度 写法如：Caug

本调和弦：在某个调中所有音都非升降。（C大调中 D 的本调三和弦是小三和弦 Dm=D+F+A）

C大调本调三和弦：

C（主和弦）Dm Em F（下属和弦） G（属和弦） Am Bdim

七和弦有四个音（在三和弦的基础上加了七音所以叫七和弦）

以下三行省略“三度”二字。

大七和弦：大+小+大 写法如：Cmaj7

大小七和弦：大+小+小 写法如：C7（作为属音和弦时可叫做属七和弦）

小七和弦：小+大+小 写法如：Cmin7

挂二和弦：将三和弦中的三音从三度变为二度。Csus2=C+D+G

挂四和弦：将三和弦中的三音从三度变为四度。Csus2=C+F+G

上两个挂留和弦经常用在主音和属音上。

转位和弦：原位和弦的循环移位（根音不是最低音）。如 G/B=B+D+G，G/D=D+G+B。

中古调式👇

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230911202849872-1430977516.png)

编号为 1,6 的调分别就是自然大调、自然小调。

这些调式都在某个调上使得都是白键👈对应标号，如多利亚 D 调的情况下是 DEFGABC，

而自然大调 D 调应该是 D E #F G A B #C，所以多利亚的写法就是 1 2 b3 4 5 6 b7。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17698851.html</id>
    <title type="text">后缀排序 后缀数组 SA-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-13T02:22:00Z</published>
    <updated>2023-09-13T02:22:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17698851.html" />
    <content type="text">之前写的什么狗吧，借鉴 little09 写了份好看的。

[record](https://www.luogu.com.cn/record/124566310)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17713731.html</id>
    <title type="text">基于状压的线性 RMQ 算法-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-19T01:13:00Z</published>
    <updated>2023-09-19T01:13:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17713731.html" />
    <content type="text">接下来设 $B$ 为块长 $\sim\log n$。

序列将被分为 $n/B$ 块，求出每个块内的最大值，并在块间建立 ST 表。并且对于每个块内，处理出前缀和后缀最大值。

这样跨块的询问就可以 $O(1)$ 处理了，接下来只要考虑一个块内的询问即可。

块内跑单调栈，每个时刻用状压记录目前在单调栈中的位置集合，这个状压的值域是 $O(2^B)=O(n)$ 的。询问 $[l,r]$ 时直接读 $r$ 位置的状压中位置 $\ge l$ 的第一个位置的值即可，这里用了一下二进制技巧。

[record](https://www.luogu.com.cn/record/125163629)

此题随机数据，所以被 $B\sim\sqrt{\log n}$ 或者别的做法吊打。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17720107.html</id>
    <title type="text">我不会欧拉数。-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-21T07:42:00Z</published>
    <updated>2023-09-21T07:42:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17720107.html" />
    <content type="text">[Karry5307 的博客 浅谈欧拉数](https://www.luogu.com.cn/blog/Karry5307/eulerian-numbers)

[OI-wiki Eulerian Number](https://oi-wiki.org/math/combinatorics/eulerian/)

在 OI-wiki 等地方可以用 Eulerian Number 英文名搜。

为什么这东西叫欧拉数呢？因为这是欧拉提出的。

定义 $\left&lt;\begin{matrix}n\\k\end{matrix}\right&gt;$ 为 $n$ 阶排列恰好有 $k$ 个「上升」的数量，即：
$$
\sum_{\pi}[\sum_{i=1}^{n-1}[\pi_i&lt;\pi_{i+1}]=k]
$$
比如说 $\{1,2,3,4\}$ 有 $11$ 个排列恰有两个上升：
$$\begin{gathered}1324,1423,2314,2413,3412\\1243,1342,2341,2134,3124,4123\end{gathered}$$
所以 $\left&lt;\begin{matrix}4\\2\end{matrix}\right&gt;=11$。

特殊地 $\left&lt;\begin{matrix}0\\0\end{matrix}\right&gt;=1$。

![](https://img2023.cnblogs.com/blog/2213867/202309/2213867-20230921154806304-333773112.png)

考虑增量插入值为 $n$ 的元素，得到：
$$\boxed{
\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=(k+1)\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle+(n-k)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle
}$$
$O(n^2)$ 例题：P2401 不等数列

将值域反转，则有：
$$\boxed{
\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\left\langle\begin{matrix}n\\n-k-1\end{matrix}\right\rangle
}$$

通项：
$$\boxed{
\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\sum\limits_{i=0}^{k}(-1)^i\binom{n+1}{i}(k+1-i)^n
}$$
证明放在文末。

LOJ2834. 「JOISC 2018 Day 2」修行

Tips：在本题的官方题解中，讲述了欧拉数到值域为 $(0,1]$ 序列上的一个映射，也即如下问题：

$x_1,\cdots x_n$ 为一个长度为 $n$ 的实数序列，且 $0&lt;x_i\leq 1$。求 $k-1\leq\sum x_i&lt;k$ 的概率。

这个的概率其实就是 $\dfrac{1}{n!}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle$，具体证明可以参见 [EI 的题解](https://www.luogu.com.cn/blog/EntropyIncreaser/solution-p5825)（其实这个题解是隶属于 P5825 的）。

求一行：P5825 排列计数。

发现通项是两个多项式卷积，做完。

当然，我们尝试返璞归真，容斥来推这道题的式子：

* * *

贺自 Little09

考虑先对升高容斥，钦定 $k$ 个位置是升高，其他位置任意。这时将序列分为了 $n-k$ 段，每段需要满足单调递增。问题变成了把 $1\sim n$ 放入 $n-k$ 个有标号的集合，使得每个集合不为空的方案数。

再对空集合容斥。钦定这 $n-k$ 个集合中的 $p$ 个集合为空，其他集合任意。那么问题就变成把 $1\sim n$ 放入 $n-k-p$ 个有标号的集合的方案数，这个问题是小学数学题，答案就是 $(n-k-p)^n$，可以快速幂处理。

具体地，我们记 $f(k)$ 表示把 $1\sim n$ 放入 $k$ 个有标号的集合，使得每个集合不为空的方案数。根据第二个容斥，可以得到：

$$f(k)=\sum_{i=0}^k\dbinom ki(-1)^i(k-i)^n$$

这是经典卷积形式，做一次卷积即可得到 $f$。

从 $f$ 得到答案只需要再做一次二项式反演即可。这部分平凡。

* * *

对于这种容斥的理解，我们可以做 P10004 [集训队互测 2023] Permutation Counting 2，只需要将一维的两重容斥改为二维的四重容斥即可。

具体见 2024sol1。

试看看！

[CF1349F1 Slime and Sequences (Easy Version)](https://www.luogu.com.cn/problem/CF1349F1)

[CF1349F2 Slime and Sequences (Hard Version)](https://www.luogu.com.cn/problem/CF1349F2)

[UOJ 593 新年的军队](https://uoj.ac/problem/593)

[Luogu P7511 三到六](https://www.luogu.com.cn/problem/P7511)

通项的证明：

$n$ 固定，设 $f(m)=\left&lt;\begin{matrix}n\\m\end{matrix}\right&gt;$ 为恰有 $m$ 个上升。

设 $g(m)=\sum_{i=m}^{n-1}\binom{i}{m}f(i)$ 为钦定 $m$ 个为上升。

二项式反演
$$
f(m)=\sum_{i=m}^{n-1}(-1)^{i-m}\binom{i}{m}g(i)
$$
考虑 $g(m)$ 为 $n-m$ 个非空严格上升的子串拼接得来
$$\begin{aligned}
g(m)&amp;=n![x^n](e^x-1)^{n-m}
\\&amp;=n!\sum_{i=0}^{n-m}\binom{n-m}{i}[x^n]e^{ix}(-1)^{n-m-i}
\\&amp;=n!\sum_{i=0}^{n-m}\binom{n-m}{i}\frac{i^n}{n!}(-1)^{n-m-i}
\\&amp;=\sum_{i=0}^{n-m}\binom{n-m}{i}i^n(-1)^{n-m-i}
\end{aligned}$$
套入 $f(m)$ 的式子
$$\begin{aligned}
f(m)&amp;=\sum_{i=m}^{n-1}(-1)^{i-m}\binom{i}{m}\sum_{j=0}^{n-i}\binom{n-i}{j}j^n(-1)^{n-i-j}
\\&amp;=(-1)^{m+n}\sum_{j=0}^{n-m}j^n(-1)^{j}\sum_{i=m}^{n-j}\binom{i}{m}\binom{n-i}{j}
\\&amp;=(-1)^{m+n}\sum_{i=0}^{n-m}i^n(-1)^{i}\binom{n+1}{m+i+1}
\end{aligned}$$
由于曾经提到的值域反转式子
$$\begin{aligned}
f(m)&amp;=f(n-1-m)
\\&amp;=\sum_{i=0}^{m+1}i^n(-1)^{m+1-i}\binom{n+1}{m+1-i}
\\&amp;=\sum_{i=0}^{m}(m+1-i)^n(-1)^{i}\binom{n+1}{i}
\end{aligned}$$
证毕。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17721715.html</id>
    <title type="text">支配树-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-22T02:21:00Z</published>
    <updated>2023-09-22T02:21:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17721715.html" />
    <content type="text"># 贺自 Little09 博客


## 前言


萌新刚开始学图论入门，今天来学习一下支配树（灭绝树）这个东西。有问题请指出啊。


## 支配与支配点


在一张有向图 $G$ 中，对于任意两个点 $u$, $v$，若从起点 $s$ 出发到达顶点 $v$ 的所有路径都需要经过顶点 $u$，则称顶点 $u$ 支配顶点 $v$（$u$ 为 $v$ 的支配点）。特别地，每个顶点支配其自身。


另一种更形象的定义是，$u$ 被删除后，$s$ 无法到达 $v$，则称顶点 $u$ 支配顶点 $v$（$u$ 为 $v$ 的支配点）。


很显然这两种定义是等价的。


## 支配树


对于非根节点 $x$，设距离 $x$ 最近的支配点为 $y$，那么从 $y$ 向 $x$ 连一条有向边。形成的树叫做支配树。


支配树最明显的性质：在支配树上，从 $s$ 走向任意一点 $u$ 所路过的所有点就是 $u$ 的支配点。


## 树的支配树


对于一棵外向树来说，它本身就是自己的支配树。


## DAG 的支配树


我们需要做的，是对于任意非根节点 $u$，找到它的最近支配点。


由于是 DAG，考虑先对其进行拓扑排序。接下来按照拓扑序建树。


我们假设考虑到节点 $u$，即拓扑序在 $u$ 之前的节点已经建好了支配树。


我们找到所有存在边 $v\to u$ 的节点 $v$，我们的任务变成了从 $s$ 到达所有 $v$ 中的必经点。这个时候会发现，如果我们找到所有 $v$ 在支配树上的 $\text{LCA}$，这个点就是我们要求的 $u$ 的最近支配点。这一点可以画个图理解。


$\text{LCA}$ 可以用倍增求出。


注意，需要反向建边才能找到所有 $v\to u$。


* [P2597 [ZJOI2012]灾难](https://www.luogu.com.cn/problem/P2597)


模板题。先拓扑，把所有生产者连向一个超级源点 $s$，然后建出支配树，输出 $size$ 即可。
* [CF757F Team Rocket Rises Again](https://www.luogu.com.cn/problem/CF757F)


先跑最短路，建出最短路图。由于最短路图是个 DAG，然后和上题一样即可。


## 一般有向图的支配树


先咕着。

# My

## gym101741L. Increasing Costs

DAG 支配树模板题，跑出最短路 DAG 后求每个点支配树子树大小即可，注意这里不用边拆点，直接判断一个点最短路入边是否只有一条即可。

[Code](https://codeforces.com/gym/101741/submission/224594577)
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17732254.html</id>
    <title type="text">CF1878-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-27T03:15:00Z</published>
    <updated>2023-09-27T03:15:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17732254.html" />
    <content type="text"># E. Iva &amp; Pav

ST 表+二分。

# F. Vasilije Loves Number Theory

用 map 维护 $n$ 和 $d(n)$ 的质因数分解，判断是否有 $d(n)|n$ 即可。

复杂度 $O(\text{poly} \log)$。

# G. wxhtzdy ORO Tree

维护 $\log$ 个 $x\to z$ or 起来增加 $1$ 的位个数的那些 $z$，然后算答案即可。这里用倍增。

发现这样上行下行链不太好写，我们可以 $x\to y,y\to x$ 都做一遍上行的即可。

复杂度双 $\log$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17732460.html</id>
    <title type="text">CF1879-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-27T05:07:00Z</published>
    <updated>2023-09-27T05:07:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17732460.html" />
    <content type="text"># E. Interactive Game with Coloring

如果树的深度等于 $1$，那么只需要一种颜色。

如果深度大于 $1$，那么每个点父边的颜色必须是唯一的，因此至少需要 $2$ 种颜色。

如果有两个点，度数等于 $2$，但父边颜色不同，则无法区分。所以我们必须避免这种情况，而根的同一子树中如果有两个深度奇偶性不同的 $2$ 度点则无解。剩余的情况通过调整第一层的边的颜色一定有解。

对于无法做到 $2$ 种颜色的情况，$3$ 种颜色一定有解，只需要按照深度 $\bmod 3$ 来染色。

# F. Last Man Standing

我写了一个根号 $\log$，被爆了过不去。

首先一个人的存活轮数是 $h\cdot \lceil a/x\rceil $，所以只需要考虑 $x\le A:=\max a$ 的情况。枚举 $x$，然后再枚举 $\lceil a/x\rceil $，最大值一定是取 $a$ 的区间中最大的 $h$，而实际上区间变成后缀也是正确的，因为后面的只会让答案更大。找到最大值之后我们还要找到次大值，这可以通过预处理 $a\ge i$ 的 $h$ 最大的 $2$ 人之后用类似的方法求解。

时间复杂度 $O(A\log A+n\log n)$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17737752.html</id>
    <title type="text">浅浅谈 Barrett Reduction 的精度和字长分析-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-09-30T05:12:00Z</published>
    <updated>2023-09-30T05:12:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17737752.html" />
    <content type="text">我们多次求
$$
\left\lfloor\frac{N}{M}\right\rfloor
$$
的值，其中 $M\in\mathbb N^+$ 为定值，$N\in\mathbb N$ 每次不一定相同。要求每次求值的时候不希望出现除法和取模（可以有位运算）。

预处理出
$$
X=\left\lceil\frac{2^k}{M}\right\rceil
$$
其中 $k$ 的取值之后会讨论。设
$$
\hat X=\frac{2^k}{M},\Delta=X-\hat X
$$
此时
$$
\left\lfloor\frac{NX}{2^k}\right\rfloor
=\left\lfloor\frac{N(\hat X+\Delta)}{2^k}\right\rfloor
=\left\lfloor\frac{N}{M}+\frac{N\Delta}{2^k}\right\rfloor
\overset{?}=\left\lfloor\frac{N}{M}\right\rfloor
$$
若要 $\overset{?}=$ 成立，则有
$$
0\le \frac{N\Delta}{2^k}&lt;\frac{1}{M}
$$
由于 $0\le \Delta&lt;1$，只需要满足
$$
2^k\ge MN
$$
接下来考虑值域，我们取 $k$ 同时使得 $2^k&lt;2MN$，则
$$
NX
=N\left\lceil\frac{2^k}{M}\right\rceil
&lt;2N^2
$$
在 $M\le 2^{30}$ 的模意义下乘法 $N&lt;2^{60},2N^2&lt;2^{121}$，显然是 C++  中 `__int128` 能存的下的。

```cpp
struct red{
	int k,m;using big=__int128;ll x;
	void init(const int&amp;n){m=n,k=3*__lg(m-1+m),x=((big(1)&lt;&lt;k)-1)/m+1;}// 1&lt;=n&lt;=2^30
	inline int operator()(const ll&amp;v)const{return v-(big(v)*x&gt;&gt;k)*m;}// 0&lt;=v&lt;n^2
};
```</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17741942.html</id>
    <title type="text">Prüfer Prufer prüfer prufer 序列-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-04T00:51:00Z</published>
    <updated>2023-10-04T00:51:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17741942.html" />
    <content type="text">[OI Wiki Prüfer 序列](https://oi-wiki.org/graph/prufer/)

结论是 $n$ 阶带标号无根树和长度为 $n-2$ 值域为 $[1,n]\cap\mathbb Z$ 的序列一一对应。

所以个数是 $n^{n-2}$。

但是这还不够：

&gt; 一个 $n$ 阶带标号无向图有 $k$ 个连通块。我们希望添加 $k-1$ 条边使得整个图连通，求方案数。

考虑 prüfer 代表什么，就是每次删叶子时父亲的编号。在这里我们存每次删叶子连通块时父亲节点的编号，这样序列个数就是 $n^{k-2}$。

再考虑每个连通块都会被删掉一次或者最后作为留下的两个，发现计数都要乘上 $siz$，所以总方案数就是：
$$
n^{k-2}\prod_{i=1}^k siz_i
$$

例题：CF156D Clues</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17747667.html</id>
    <title type="text">羽毛球规则硝基-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-07T14:31:00Z</published>
    <updated>2023-10-07T14:31:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17747667.html" />
    <content type="text">队友碰拍不违规，但是不能被同一方队员多次击中。

发球擦网不用重发。

发球时击球点不能高过握拍手的手腕、不能二次动作、击球点不能高过1.15米。

球碰到选手的身体或衣服或被击时停滞在球拍上一段时间输。

选手的球拍、身体或衣服，触及球网或其支撑物输。

发球方每得一分后，原发球员则变换发球区再发球。

被击时停滞在球拍上，紧接着被拖带抛出输。

被同一运动员两次挥拍连续两次击中（但一次击球动作中，球被拍框和拍弦面击中，不属违例。）

球拍或身体，从网上侵入对方场区（击球时，球拍与球的最初接触点在击球者网这一方，而后球拍随球过网的情况除外。）

球拍或身体，从网下侵入对方场区，导致妨碍对方或分散对方的注意力；

司线员未能看清，裁判员也不能做出裁决时“重发球”
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17750668.html</id>
    <title type="text">三角函数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-09T00:56:00Z</published>
    <updated>2023-10-09T00:56:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17750668.html" />
    <content type="text">$$
\begin{aligned}
&amp;
\begin{cases}
e^{(\alpha+\beta)i}=e^{\alpha i}e^{\beta i}
\\
e^{\theta i}=i\sin\theta+\cos\theta
\end{cases}
\\ \implies&amp;
i\sin(\alpha+\beta)+\cos(\alpha+\beta)=(i\sin \alpha+\cos \alpha)(i\sin \beta+\cos \beta)
\\ \implies&amp;
\begin{cases}
\sin(\alpha+\beta)=\sin \alpha\cos \beta +\cos \alpha\sin \beta
\\
\cos(\alpha+\beta)=\cos \alpha\cos \beta-\sin \alpha \sin \beta
\end{cases}
\end{aligned}
$$

$$
\cos(\alpha+\beta)+\cos(\alpha-\beta)=2\cos\alpha\cos\beta
$$</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17752889.html</id>
    <title type="text">2023sol3-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-09T10:48:00Z</published>
    <updated>2023-10-09T10:48:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17752889.html" />
    <content type="text"># CF1163F Indecisive Taxi Fee

无向带权图删边最短路模板。

求出从 $1$ 出发和到 $n$ 结束的最短路树 $T^1,T^n$ 以及一条最短路 $P$。

首先删的边不在 $P$ 上则答案就是原最短路，接下来考虑在 $P$ 上。

设 $T^{*}_x$ 表示该树上 $x$ 到根的链，设 $P$ 的正方向（向右）指离 $1$ 更远的方向。

枚举一条不在 $P$ 上的边 $(u,v)$（两个方向均要枚举一遍），找到 $T^1_u\cap P$ 最右的点 $L$ 以及 $T^n_v\cap P$ 最左的点 $R$，当 $L$ 在 $R$ 左边时，将 $P$ 上 $L\sim R$ 之间的边的答案对经过 $(u,v)$ 的路径长度 ckmn。

正确性证明：

对一条 $P$ 上的边 $(u,v)$，删边最短路一定是 $P$ 的前后缀中间接上一段不经过 $P$ 的简单路径 $E$ 不劣，只要 $E$ 中存在一条边 $(x,y)$ 使得 $T^1_x\cap P$ 最右的点在 $u$ 及左边，$T^n_y\cap P$ 最左的点在 $v$ 及右边。

每条边只有四种分类：左左，左右，右左，右右。

假设 $E$ 中不存在左右的边，则 $E$ 最左的边是左左，最右的边是右右，考察所有 $E$ 上相邻的一对边，发现左左不可能接右右，左左不可能接右左，右左不可能接右右：

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240105114445140-753710015.png)
（其实本质是相邻的两个边的区间一定有交（可以交在点上））

所以中间一定有左右，证毕。

有向的版本不太行：

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240105101709699-675878692.png)
大概像上图删掉边 $2\to 3$，我们会以为 $1\to 2\to 3\to 4\to 2\to 3\to 5$ 绕一圈可行。

[P3238 [HNOI2014] 道路堵塞 目前被判定为假题](https://www.luogu.com.cn/problem/P3238)

[EI 有向无权图删边最短路 论文做到根号下log（cxy神在研究了，说不定practical的）](https://www.cnblogs.com/Elegia/p/16461398.html)

# CF575E Spectator Riots

可以证明如下结论：**平面上一个面积为正的凸包，要作一个半径尽量大的圆，使得该圆包含凸包，并经过至少三个凸包顶点，一定可以经过凸包上三个相邻的顶点，且半径最大的那个一定合法。**

由于每个人能够到达的点的凸包是一个点，或一个 $3 \sim 6$ 边形，只要求出每个人对应的凸包的顶点，这可以通过简单的讨论求出，再合并求一次大凸包即可。

求出凸包后，枚举凸包上相邻三点计算半径并更新答案即可。

三角形 $\triangle ABC$ 外接圆半径公式：
$$
\frac{|AB|\cdot |BC|\cdot |CA|}{4S_{\triangle ABC}}
$$ 

# P6106 [Ynoi2010] Self Adjusting Top Tree

前面的做法是平凡的：对斜率正负的线段分别做、询问差分成四个左下矩形询问。

我们只剩斜率为正的线段了，将有贡献的线段分类：与询问右边界有交、与询问上边界有交但与右边无交、与边界无交且被询问左下矩形包含。

对于第三类直接将线段看作只有右上方的端点即可，二维数点。一二类很相似，我们不妨只考虑第一类。

一个朴素的想法是维护 $x=?$ 的竖的扫描线，维护目前与扫描线有交的线段按交点 $y$ 坐标排序，询问即为查询一个前缀的一次函数和，但是这样要手写平衡树（要维护前缀和）。

一种不用手写的方法：第一次用 set 扫描线时记录线段之间偏序关系（插入时向前驱连边、被后继连边），由于线段不交所以一定是 DAG，跑拓扑序后再做一次扫描线，这样就是拓扑序的前缀了，用树状数组维护前缀和即可。

# CF1906B Button Pressing

场上写这道题自闭了，一直在想 atc 曾经见过类似的题目。

有的时候 01 序列不能在原序列上分析问题，考虑差分数组或者前缀和数组。

这道题来说就是前缀和数组可以邻项交换，包括第一项和第零项之间。

所以枚举第零项是 0/1，判断两个串前缀和 1 的个数是否相同即可。

# [ARC168D] Maximize Update

为什么我想不到。

将操作倒过来，最后一个区间撤销一定会露出一个白色，这样白色块两边是互不干扰的子问题了，区间 DP $O(n^3)$。

# P1640 [SCOI2010] 连续攻击游戏

一种不基于值域的做法。

首先将 $a_i,b_i$ 对 $n+1$ 取 $\min$，然后看成点 $a_i,b_i$ 之间的无向边。

如果连通块是一棵树，则我们一定只能且可以空出连通块内最大的值，否则，一定有基环树生成子图，一定能把所有值覆盖。

将每棵树的最大值求最小值后即为答案。

# [ABC321F] #(subset sum = K) with Add and Erase

带删背包板子。

带删背包只能做计数而不是最优化问题，可以理解为乘多项式 $kx+1$ 的逆。

具体实现时只要做背包的逆操作就行。

为什么是可以实现的？因为背包 $f_i$ 在任意时刻的取值只会被 $f_0,\dots,f_{i-1}$ 影响，所以每个 $f$ 的前缀都是可以独立完成添加、删除操作的。

由这个原理，可以做 $O(n^2)$ 插值。

考虑插值的式子（要求所有 $x_i\ne 0$，即在模意义下存在逆元）

$$
\sum y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}=\sum y_i\prod_{j\ne i}\frac{-x_j}{x_i-x_j}\prod_{j\ne i}(-\frac{x}{x_j}+1)
$$
最后的连乘部分就是去掉一项的背包计数，带删背包即可。

# pjudge21795. 【NOIP Round #6】排序

[【NOIP Round #6】排序](https://pjudge.ac/contest/1390/problem/21795)

非常好题！

操作等价于整个串分成若干子串后每个子串分别 reverse 后整个串 reverse。

发现整个串 reverse 可以忽略，只要最后操作数量为偶数即可。

如果我们会做 01 序列排序，那我们按值的从高到低二进制位依次**同步**做 01 序列排序即可，也就是说，总的操作次数不超过 01 序列操作次数的 $\lceil\log_2 n\rceil$ 倍，也就是线段树同一层的节点同步做。

对于 01 序列的问题，发现把极长颜色段缩起来是等价的，所以只考虑 1010... 和 0101... 两种情况，以下的划分 reverse 操作能让颜色段个数减小到原来的 $1/3$ 左右，于是操作次数 $=O(\log_3 n)$：

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231103171101759-1477197528.png)

就做完了，实测操作次数不超过 $76$，注意实现逻辑，以及同层节点操作序列短的向长的补齐。

关键点：这个高妙的减少颜色段数量的构造。

# [APIO2023] QOJ6529. Alice, Bob and Circuit

[APIO2023官网](http://www.apio2023.org/tasks)

强烈建议去看官网里的官方 sol（虽然是生肉，但是绝对牛逼）（中文题面、std 等也在上面链接里）。

大战两天（代码逻辑复杂、双调序列没懂透、细节较多），接下来几乎直接介绍正解做法。

## 概述

首先将人名变成 $19$ 位（以下均指二进制）数字。

Alice 要给 Circuit 这些信息：
* $n$ 的值。
* **按输入顺序**的人名 $Ar_i$ 和对应数字 $An_i$。

Bob 要给 Circuit 这些信息：
* $m$ 的值。
* 每封信的发送、接收的人名 $Bf_i,Bt_i$。

Circuit 总体思路是先将发送人数字对应到信上，再将信上的数字加到接收者头上。

两部分 Circuit 都不能平方复杂度去比较和赋值，这样门个数爆表了。

将人和信一起按 $Ar_i$ 和 $Bf_i$ 排序，值相同的**人在前面**。这样我们存一个变量 $T$ 顺序扫描（称以下过程为 $\dagger$）：
* 遇到人时：$T\leftarrow An_i$。
* 遇到信时：$W_i\leftarrow T$，其中 $W_i$ 是每封信记录的发送人的数字。

然后对 $\{W\}$ 执行排序的逆操作（通过记录排序每次交换条件的门位置），得到按 $Bf_i$ 顺序的 $W_i$。

后半部分同理，将人和信一起按 $Ar_i$ 和 $Bt_i$ 排序，值相同的**信在前面**。这样我们存一个变量 $T$（**初始为 $0$**）顺序扫描（称以下过程为 $\ddagger$）：
* 遇到人时：$Ans_i\leftarrow T,T\leftarrow 0$，其中 $Ans_i$ 是接受人得到的数字之和。
* 遇到信时：$T\leftarrow T+W_i$。

还是执行排序逆操作，将 $\{Ans\}$ 挂在输出即可。

总体思路就是这样，但是细看发现问题多多：

## 如何排序

发现要做的都是将 Alice 和 Bob 分别给的序列合并后排序，我们将 Alice 和 Bob 的序列分别排序再给 Circuit 这样只要做归并即可（当然，Alice 和 Bob 还要给 Circuit 排序的逆排列让其能以正确的顺序输出）。

由于这种 DAG 电路我们没法造出锁存器等东西，所以归并排序、快速排序、堆排序已经被出题人证明是凉凉的了。

我们使用双调排序解决归并，复杂度 $O(n\log n)$。普通的双调排序是双 $\log$ 的，我们将两个序列头对头接起来就是双调序列了（注意长度补成 $2$ 的幂时注意占位值的取值，要满足占位之后还是双调序列），双调序列双调排序是单 $\log$ 的，而且操作只有将某两个值上升/下降排序，非常适合这道题的电路设计以及执行逆排序，具体见 [wikipedia - Bitonic sorter](https://en.wikipedia.org/wiki/Bitonic_sorter)（吐槽：国内好多教程双调序列的定义是错的，没提到循环同构），也可以看我的 [普通序列双调排序代码](https://www.luogu.com.cn/record/131852779)。

这又导致了一个新问题：Alice 和 Bob 分别要给 Circuit 传一个排列（按 $Ar\to$ 按原顺序、按 $Bf\to$ 按 $Bt$），使得 Circuit 能方便对一个序列作用上这个置换。

## 如何传输和作用置换

对于每种长度，我们尝试构造一个交换操作序列，使得每种这个长度的排列都可以通过一个操作序列的子序列来排序，由于我们让  Circuit 知道 $n,m$ 的值，所以 Alice 和 Bob 分别传输 $n,m$ 长度排列的操作序列长度个比特就行了。

以下一种构造让交换操作序列长度 $=O(n\log n)$。

考虑分治，将排列分成等长的左右两部分（对于长度为奇数的情况只是多了些小细节，读者自行考虑或者看我代码实现）。
1. 每对 $i$ 和 $i+\frac{n}{2}$ **位置**尝试交换，使得每对**值为** $i$ 和 $i+\frac{n}{2}$ 的位置分处于左右两半。
2. 左右两半分别做值 $\bmod\frac{n}{2}$ 的子问题。
3. 此时 $i$ 和 $i+\frac{n}{2}$ 位置上的值一定是 $\{i,i+\frac{n}{2}\}$，尝试交换这对位置即可。

## 代码流程和实现

### Alice

名字 $\to 19$ 个比特。

将 $(Ar_i,An_i,i)$ 按第一关键字排序。

传输排序后的 $\{Ar\},\{An\}$。

将第三关键字的排列变为交换操作序列的 01 串并传输。

### Bob

名字 $\to 19$ 个比特。

将 $(Bf_i,Bt_i)$ 按第**二**关键字排序，设得到的序列为 $(Bf'_i,Bt'_i)$。

将 $(Bf'_i,Bt'_i,i)$ 按第一关键字排序，传输前两项和第三项排列操作序列的 01 串。

### Circuit

通过 Alice 和 Bob 传来的长度找出 $n,m$ 的值（二分/暴力加/查表）。

特判 $n=0$，造出恒为高/低电平的门。

将人变成四元组 $(Ar_i,Ar_i,An_i,0)$，信变成 $(Bf_i,Bt_i,0,1)$。命名四元组每一项为 $(X_1,X_2,X_3,X_4)$。

将四元组按 $(X_1,X_4)$ 双关键字顺序归并，做 $(\dagger)$ 过程，使得信的 $X_3$ 为发送人数字。

撤销归并，将信的四元组按 Bob 给的排列置换为按 $Bt$ 升序。

将四元组按 $(X_2,\neg X_4)$ 双关键字顺序归并，做 $(\ddagger)$ 过程，使得人的 $X_3$ 为受到数字之和。

撤销归并，将人的四元组按 Alice 给的排列置换为原顺序（Alice 得到的顺序）。

将人的 $X_3$ 顺次挂到输出。

我实现时每次排序不带四元组某些项，大大减少四元组所用门的个数，也不知道必不必要。

### 代码

[Code](https://qoj.ac/submission/230513)，没去压行直接 QOJ 最短解。

# P9261 [PA 2022] Płótno

这个问题其实一般图也是可以做的，详见 [漏宝的题解](https://www.luogu.com.cn/blog/Lynkcat/solution-p9261)，主要思想是用 LCT 动态维护最大生成树。

但是这道题由于图是一条边和一个环的笛卡尔积，有更简单的做法。

考虑这个图是平面图（其所有诱导子图也是），由欧拉公式，【连通块数】等于【点数】减【边数】加【面数】（不包括无界的那个面）。

发现其所有诱导子图的所有面都是四边形，除非诱导子图形成了一个大环，这样会多一个边数非常多的面，这时连通块数一定是 $1$。

设诱导子图点数为 $V$，边数为 $E$，形成的 $2\times 2$ 块状个数为 $F$，则连通块数为 $\max(1,V-E+F)$。

顺序扫点编号区间的右端点，对每个左端点维护点编号区间诱导子图的 $V-E+F$，问题变成前缀加，前缀查值分别 $=0,\dots,k$ 的位置个数，由于值在任意时刻均为自然数，所以用线段树维护最小值和其值上方 $k$ 个值分别的个数即可。

复杂度 $O(nk\log)$。

# QOJ#5406. 随机游走（CTT 2020 Day 2）

概率与期望难题。

## Upd

也可以用高维体积（以下“体积”均指高维体积）来理解这个事情，设维度分别为 $x_1,\dots,x_n$，我们要求求出 $\forall i,x_i\in[0,1)$ 的立方体和 $\forall i,x_i\ge 0\land\sum x_i&lt;v$ 的物体（$n=3$ 时是四面体）的交的体积。

由 $(\dagger)$，我们其实证明了三维中棱锥的体积为对应棱柱体积的 $1/3$。

$(\ddagger)$ 式子考虑容斥有哪些维度 $x_i\ge 1$，设其集合为 $S$，于是要求
$$\forall i,x_i\ge[i\in S]\land\sum x_i&lt;v$$
的体积，设 $y_i=x_i-[i\in S]$，等于
$$\forall i,y_i\ge 0\land\sum y_i&lt;v-|S|$$
的体积。

由 $(\dagger)$ 并缩放，其体积为 $\frac{(v-|S|)^n}{n!}$，所以得出了 $(\ddagger)$ 式子。

## 前置知识

[EI](https://www.luogu.com.cn/blog/EntropyIncreaser/solution-p5825)

### 前置前置知识

$n$ 个随机变量 $X_i\sim U(0,1)$：
$$P(\sum_{i=1}^n X_i&lt; 1)=\frac{1}{n!}\quad(\dagger)$$
原因可以考虑 EI 的 $\bmod 1$ 差分，也可以说：

对于所有的线段 $[0,1]$ 撒上有标号点的方案，都代表着一种 $X_1,\dots,X_n$ 的取值，而其中有 $\frac{1}{n!}$ 的方案满足标号从左到右升序，这些方案与和 $&lt;1$ 的方案一一对应，因为设在数轴上的位置依次为 $p_1,\dots,p_n$，则代表 $X_1=p_1,X_2=p_2-p_1,\dots,X_n=p_n-p_{n-1}$ 这种方案，可以形象为柱状图叠高楼。

### 回归前置

$n$ 个随机变量 $X_i\sim U(0,1)$，对于任意实数 $v\in[0,n)$：
$$
P(\sum_{i=1}^n X_i&lt; v)=
\sum_{i=0}^{\lfloor v\rfloor}\binom{n}{i}(-1)^i\frac{(v-i)^n}{n!}\quad(\ddagger)
$$
EI 介绍了一种基于“测度”容斥转化到 $v=1$ 的情形，但是太抽象了，我还是用不高明的微元法推导了。

设一个变量 $m\to\infty$，将 $X_i\sim U(0,1)$ 离散成基于 $\{\frac{x}{m}\ |\ x\in[0,m)\cap\mathbb Z\}$ 的随机变量（这样就可以用古典概型推导了）。不妨将 $v$ 近似到 $\frac{1}{m}$ 的整数倍。

有上界不好搞，去掉后考虑容斥，有 $i$ 个随机变量的值 $\ge 1$，这样我们要解决没上界的和 $&lt;v-i$ 的问题。
$$
\begin{aligned}
&amp;P(\sum_{i=1}^n X_i&lt; v)
\\=&amp;
\lim_{m\to\infty}\frac{1}{m^n}\sum_{i=0}^{\lfloor v\rfloor}\binom{n}{i}(-1)^i\binom{m(v-i)-1+n}{n}
\\=&amp;
\lim_{m\to\infty}\frac{1}{m^n}\sum_{i=0}^{\lfloor v\rfloor}\binom{n}{i}(-1)^i\frac{(m(v-i)-1+n)^{\underline n}}{n!}
\\=&amp;
\lim_{m\to\infty}\frac{1}{m^n}\sum_{i=0}^{\lfloor v\rfloor}\binom{n}{i}(-1)^i\frac{m^n(v-i)^n}{n!}
\\=&amp;
\sum_{i=0}^{\lfloor v\rfloor}\binom{n}{i}(-1)^i\frac{(v-i)^n}{n!}
\end{aligned}
$$

## 回归本题

一次游走的区域是曼哈顿距离 $\le 1$，将其转成切比雪夫距离（旋转坐标轴 $45^{\circ}$），$\Delta x,\Delta y\sim U(-\frac{\sqrt 2}{2},\frac{\sqrt 2}{2})$，最后与原来 $y$ 轴的距离为 $\frac{\sqrt 2}{2}|x+y|$。

发现最终 $x,y$ 分别是 $n$ 个随机变量的和，不难转化成 $X_1,\dots,X_{2n}\sim U(0,1)$，求 $E(|\sum_{i=1}^{2n}X_i-n|)$。

发现这东西关于值 $n$ 对称，所以
$$
E(|\sum_{i=1}^{2n}X_i-n|)=2\int_0^nP(\sum_{i=1}^{2n} X_i&lt; v)\text{ d}v
$$
式子内的 $P(\dots)$ 用前置知识解决，对每个相同的 $\lfloor v\rfloor$ 分别作定积分，整理一下式子之后可以做到复杂度 $O(n\log)$。

[Code](https://qoj.ac/submission/226233)

# CF1089M Minegraphed

题意：物理引擎为我的世界，但是人只有一格高（可以跳一格高）（跌落时不能水平移动），障碍只有草方块，给你一个 $n\le 9$ 有向图，要求构造一个体积不超过 $10^6$ 的地图标记 $n$ 个地点使得地点之间的可达性和有向图一致，可以证明一定有解。

接下来是一个 $(3n-1)\times(3n-1)\times 3$ 的构造方案：

初始：上层每隔 $2$ 行放一行草方块，中层全放草方块，下层每隔 $2$ 列放一列草方块。

上层第 $i$ 个东西走向隧道和下层第 $i$ 个南北走向隧道都代表第 $i$ 个节点。

在 $i$ 节点的两个隧道相交的 $2\times 2\times 3$ 区块造一个楼梯使得上下都可以穿行，而且不会堵塞两个隧道。

对于有向边 $i\to j$，在上层 $i$ 和下层 $j$ 相交的地方开一个窟窿（不影响上层隧道的通行）使得单向通行。

做完了，非常高妙。

# P5905 【模板】全源最短路（Johnson）

先将每个点距离设为 $0$ 后跑 Bellman-Ford（或 spfa），先判掉有负环的情况，将当前距离设为势能 $h_i$。

对于每一条原来的边 $u\overset w\to v$，我们将边权重新设为 $w+h_u-h_v$。

由于第一次跑最短路带来的差分约束，我们有 $h_v\le w+h_u$，所以新的边权非负。

现在对于任意一条从 $x$ 到 $y$ 的路径，设原先的权值和为 $z$，则新边权和为 $z+h_x-h_y$，所以规定起点终点后，新图的最短路与原图等价。

直接对每个点为起点用新边权跑 dijkstra 即可，最后答案加上 $h_y-h_x$。

复杂度 $O(nm\log)$。

# CF331E1 Deja Vu &amp; CF331E2 Deja Vu

E1 写了一个可能死循环的代码过了哈哈，改过来了。

* * *

以下“路径”均可重复经过边。

如果一条边 $x\to y$ 上的点序列包含 $x,y$ 作为子串：

* 如果包含至少两次，则我们不可能经过这条边，因为幻想中会比现实中经过更多次。

* 只包含一次，则我们称这样的边为**自指边**。

自指边 $x\to y$ 有性质：其幻想中 $x\to y$ 这条边正好是现实中经过 $x\to y$ 这次，也就是一一顺次对应。

以下称似曾相识路径为**好路径**。

* * *

**引理Ⅰ：** 好路径一定存在自指边。

**证明：** 考虑折线（纵坐标是幻想点序列，横坐标是现实边序列）

![](https://img2023.cnblogs.com/blog/2213867/202310/2213867-20231017145322330-1744066703.png)

只要折线经过了同一**列**的两个红圈，则存在一条自指边，考虑折线何时穿过蓝色虚线，必然经过了同一列的两个红圈（图中 C 边为自指边）。

* * *

对于 E1，我们枚举一条被经过的自指边，这条边前驱后继不断通过幻想确定现实路径，直到现实中找不到（不合法）或者找到一条好路径，判断路径长度是否 $\le 2n$ 即可。可以见得，我们找出了所有极短好路径。

复杂度 $O(n^3)$。

但对于 E2，我们需要更多的观察来计数好路径。

* * *

**引理Ⅱ：** 定义**胶水边**为好路径一条幻想空序列的边，使得删掉后路径断成两条好路径。好路径上（按路径顺序排序）任意两个相邻的自指边之间一定**恰**存在一个胶水边。

**证明：** 若出现两个或以上，则胶水边之间是好路径，其上必然会存在自指边，有悖引理中“相邻”二字，接下来证明一定存在即可。

还是考虑折线

![](https://img2023.cnblogs.com/blog/2213867/202310/2213867-20231017145332482-1872733992.png)

只要折线经过了同一**行**的两个红圈，则存在一条胶水边，考虑折线何时穿过蓝色虚线，必然经过了同一行的两个红圈（图中经过了 $y=6$ 的两个红圈，即 F 边是胶水边）。

* * *

我们称没有胶水边的好路径为**本原好路径**。

只要我们求出所有从 $x$ 到 $y$ 长度为 $z$ 的本原好路径个数，则通过 DP 胶水边拼接即可得到最终答案。

定义**前插头**是一个路径 $x\to\dots\to y$ 使得幻想路径顺次包含了除 $y$ 外所有路径上的点，且不存在一种将边的序列划分成 $\ge 2$ 个非空子串的方案使得每段都是前插头（类似本原）。

（为什么我们前插头的定义要是本原的：对于一个终点，其合法的非本原前插头形成内向树结构，导致我们不好计数或者复杂度过高，所以我们只考虑每一条树边，同时没有前插头的数量限制）

我们同样定义**后插头**，即不包含路径起点。

我们枚举路径最后一条边向前扩展即可得到所有前插头，后插头同理。

任意一个本原好路径存在**唯一分解**：若干个【前插头】接上【E1 扩展出的极短好路径】接上若干个【后插头】。

![](https://img2023.cnblogs.com/blog/2213867/202310/2213867-20231017145339122-1525888572.png)

DP 即可，发现是一条胶水边、若干前插头、一条极端路径、若干后插头的循环，建立自动机：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231229090220048-1351844444.png)

即可做到复杂度 $O(n^3)$。

# CF1343F Restore the Permutation by Sorted Segments

挺牛的构造题，枚举第一个元素的值，之后都可以推出来了，check 一下即可。

# CF241E Flights &amp; P5590 赛车游戏

remake 差分约束。

先将不可能在 $1\to n$ 路径上的点砍掉，之后对于每个点有一个变量 $dis_i$ 表示 $1\to i$ 所有路径的统一长度，一条边 $u\to v$ 边权在 $1\sim k$ 之间约束为：
$$\begin{cases}
dis_v\le dis_u+k
\\
dis_u\le dis_v-1
\end{cases}$$
跑 Bellman-Ford 即可，复杂度 $O(nm)$。

# CF472G Design Tutorial: Increase the Constraints

bitset 能过/oh。

答案 $=$ 两子串 1 的个数之和 $-2\times$ 对应位置均为 1 的位置个数。

发现我们只要处理出后面的东西，发现是卷积的形式，所以将 $a$ 序列分块，每块和 $b$ 的 reverse 卷积即可。

$n,q$ 同阶，复杂度 $O(n\sqrt{n\log n})$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17753038.html</id>
    <title type="text">线性代数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-09T12:04:00Z</published>
    <updated>2023-10-09T12:04:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17753038.html" />
    <content type="text">## P7776 【模板】特征多项式

$O(n^3)$ 求给定 $A_{n\times n}$ 在模质数意义下
$$
p_A(x)=\det(xI-A)
$$

引理：

相似矩阵 $PAP^{-1}$ 和 $A$ 的特征多项式相同

证明：
$$\begin{aligned}
&amp;\det(xI-PAP^{-1})
\\=&amp;\det(xIPP^{-1}-PAP^{-1})
\\=&amp;\det(PxIP^{-1}-PAP^{-1})
\\=&amp;\det(P(xI-A)P^{-1})
\\=&amp;\det(P)\det(xI-A)\det(P^{-1})
\\=&amp;\det(xI-A)
\end{aligned}$$

我们取 $P$ 使得 $B=PAP^{-1}$ 是上海森堡矩阵，可以说取 $P$ 的方式是高斯消元的变体：

我们普通的初等行变换高斯消元其实是构造 $P$ 使得 $PA=X$，$X$ 为上三角矩阵。

**将第 $j$ 行加上 $k$ 倍的第 $i$ 行**：

其 $P$ 为（$i=2,j=4$）
$$
\begin{bmatrix}
1&amp; &amp; &amp; &amp;
\\
 &amp;1&amp; &amp; &amp;
\\
 &amp; &amp;1&amp; &amp;
\\
 &amp;k&amp; &amp;1&amp;
\\
 &amp; &amp; &amp; &amp;1
\end{bmatrix}
$$
其逆 $P^{-1}$ 为（考虑为将第 $j$ 行减掉 $k$ 倍的 $i$ 行）
$$
\begin{bmatrix}
1&amp; &amp; &amp; &amp;
\\
 &amp;1&amp; &amp; &amp;
\\
 &amp; &amp;1&amp; &amp;
\\
 &amp;-k&amp; &amp;1&amp;
\\
 &amp; &amp; &amp; &amp;1
\end{bmatrix}
$$
在 $PA$ 右边乘 $P^{-1}$ 的意义为初等列变换，手推发现意义是**将第 $i$ 列减去 $k$ 倍的第 $j$ 列**。

这两个操作是**同时进行的**，其实矩阵结果与操作顺序无关，可以理解为矩乘有结合律，也可以手模发现，也可以理解为行列两维是独立的。

用同样的方法推**交换第 $i$ 行和第 $j$ 行**：
$$P=P^{-1}=
\begin{bmatrix}
1&amp; &amp; &amp; &amp;
\\
 &amp; &amp; &amp;1&amp;
\\
 &amp; &amp;1&amp; &amp;
\\
 &amp;1&amp; &amp; &amp;
\\
 &amp; &amp; &amp; &amp;1
\end{bmatrix}$$
右乘的意义是**交换第 $i$ 列和第 $j$ 列**，同样也是**同时**进行。

枚举 $i:2\to n$，行交换使得 $a_{i,i-1}\ne 0$，将 $\forall j&gt;i,a_{j,i-1}$ 消为 $0$。

发现行变换带来的列变换不会影响之前和目前的值，做完了。

这也说明了所有矩阵都可以消成上海森堡矩阵，不一定能消成上三角矩阵。

设 $C=xI-B$，设 $f_i$ 为 $C$ 左上角 $i\times i$ 子矩阵的行列式，$f_0=1$ 是良定义的。

算 $f_i$ 时行列式按第 $i$ 列（即最后一列）展开，由于 $C$ 是上海森堡矩阵，容易得递推式：
$$
f_i=c_{i,i}f_{i-1}-\sum_{j=1}^{i-1}c_{j,i}\prod_{k=j}^{i-1}c_{k+1,k}f_{j-1}
$$
复杂度 $O(n^3)$。

[Code](https://www.luogu.com.cn/record/128452429)

## QOJ 59. Determinant of A+Bz

[Qiuly - Determinant of A+Bz](https://www.cnblogs.com/qiulyqwq/p/17724333.html)

发现形式很像特征多项式，考虑转化到这个问题。

我们尝试将 $B$ 消成单位矩阵，对 $B$ 行列一起消元（即在 $t$ 时刻，$\forall \min(i,j)\le t\land i\ne j,B_{i,j}=0$ 以及 $\forall i\le t,B_{i,i}=1$），变换同时附加在 $A$ 上。

由于 $\det(B)\overset{?}=0$，当存在时刻 $t$ 使得 $\forall i,B_{t,i}=0$，我们把 $A+Bz$ 整体的第 $t$ 列乘上 $z$，实现时将第 $t$ 列的 $B$ 赋值为 $A$，这一列的 $A$ 清零，继续消元即可。

当存在时刻 $t$ 使得 $\forall i,A_{t,i}B_{t,i}=0$，那没救了，$\det(A+Bz)=0$。

否则，转化成了特征多项式问题。

复杂度 $O(n^3)$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
template&lt;int P&gt;
struct mod_int{
	using Z=mod_int;
	static signed mo(signed x){return x&lt;0?x+P:x;}
	signed x;
	signed val()const{return x;}
	mod_int():x(0){}
	template&lt;class T&gt;mod_int(const T&amp;x_):x(x_&gt;=0&amp;&amp;x_&lt;P?static_cast&lt;signed&gt;(x_):mo(static_cast&lt;signed&gt;(x_%P))){}
	bool operator==(const Z&amp;rhs)const{return x==rhs.x;}
	bool operator!=(const Z&amp;rhs)const{return x!=rhs.x;}
	Z operator-()const{return Z(x?P-x:0);}
	Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&amp;1)res*=t;if(k&gt;&gt;=1)t*=t;}return res;}
	Z&amp;operator++(){x&lt;P-1?++x:x=0;return *this;}
	Z&amp;operator--(){x?--x:x=P-1;return *this;}
	Z operator++(signed){Z ret=x;x&lt;P-1?++x:x=0;return ret;}
	Z operator--(signed){Z ret=x;x?--x:x=P-1;return ret;}
	Z inv()const{assert(x);return pow(P-2);}
	Z&amp;operator+=(const Z&amp;rhs){(x+=rhs.x)&gt;=P&amp;&amp;(x-=P);return *this;}
	Z&amp;operator-=(const Z&amp;rhs){(x-=rhs.x)&lt;0&amp;&amp;(x+=P);return *this;}
	Z&amp;operator*=(const Z&amp;rhs){x=1ULL*x*rhs.x%P;return *this;}
	Z&amp;operator/=(const Z&amp;rhs){return *this*=rhs.inv();}
#define setO(o) friend Z operator o(const Z&amp;lhs,const Z&amp;rhs){Z res=lhs;return res o##=rhs;}
	setO(+)setO(-)setO(*)setO(/)
#undef setO
	friend istream&amp; operator&gt;&gt;(istream&amp;is,Z&amp;x){long long y;is&gt;&gt;y;x=Z(y);return is;}
	friend ostream&amp; operator&lt;&lt;(ostream&amp;os,const Z&amp;x){return os&lt;&lt;x.val();}
};
const int P=119&lt;&lt;23|1;
using Z=mod_int&lt;P&gt;;
const int N=502;
int n;
Z a[N][N];
void swa(int x,int y){// swap(row x,row y),swap(col x,col y)
	rep(i,1,n) swap(a[x][i],a[y][i]);
	rep(i,1,n) swap(a[i][x],a[i][y]);
}
void add(int x,int y,Z k){// row y+=row x*k,col x-=col y*k
	rep(i,1,n) a[y][i]+=a[x][i]*k;
	rep(i,1,n) a[i][x]-=a[i][y]*k;
}
// row&amp;col order can flip
Z f[N][N];// f[i][j]:[x^j]f^{(i)}
void character(){
	rep(i,2,n){
		int j=i;
		while(j&lt;=n &amp;&amp; a[j][i-1]==0) j++;
		if(j&gt;n) continue;
		if(j!=i) swa(i,j);
		Z coe=a[i][i-1].inv();
		rep(k,i+1,n){
			add(i,k,-coe*a[k][i-1]);
		}
	}
	// rep(i,1,n) rep(j,1,n) cout&lt;&lt;a[i][j]&lt;&lt;" \n"[j==j_];
	f[0][0]=1;
	rep(i,1,n){
		rep(j,0,n){
			f[i][j]-=a[i][i]*f[i-1][j];
			if(j+1&lt;=n) f[i][j+1]+=f[i-1][j];
		}
		rep(j,1,i-1){
			Z coe=-a[j][i];
			rep(k,j,i-1) coe*=a[k+1][k];
			rep(k,0,n) f[i][k]+=coe*f[j-1][k];
		}
	}
}
Z A[N][N],B[N][N],coe=1;
int shift=0;
void addc(int x,int y,Z k){// col y+=col x*k
	rep(i,1,n) A[i][y]+=A[i][x]*k;
	rep(i,1,n) B[i][y]+=B[i][x]*k;
}
void addr(int x,int y,Z k){// row y+=row x*k
	rep(i,1,n) A[y][i]+=A[x][i]*k;
	rep(i,1,n) B[y][i]+=B[x][i]*k;
}
void swb(int x,int y){// swap(row x,row y)
	coe*=-1;
	rep(i,1,n) swap(A[x][i],A[y][i]);
	rep(i,1,n) swap(B[x][i],B[y][i]);
}
void shi(int x){// col x*=z
	shift++;
	rep(i,1,n) assert(B[i][x]==0);
	rep(i,1,n) B[i][x]=A[i][x];
	rep(i,1,n) A[i][x]=0;
}
void mul(int x,Z k){// row x*=k
	coe*=k.inv();
	rep(i,1,n) A[x][i]*=k;
	rep(i,1,n) B[x][i]*=k;
}
Z ans[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n;
	rep(i,1,n) rep(j,1,n) cin&gt;&gt;A[i][j];
	rep(i,1,n) rep(j,1,n) cin&gt;&gt;B[i][j];
	rep(i,1,n){
		rep(w,0,1){
			rep(j,1,i-1){
				addc(j,i,-B[j][i]);
			}
			int x=i;
			while(x&lt;=n &amp;&amp; B[x][i]==0) x++;
			if(x&lt;=n){
				if(x!=i) swb(x,i);
				break;
			}
			if(w==1){
				rep(k,0,n) cout&lt;&lt;0&lt;&lt;" \n"[k==k_];
				return 0;
			}
			shi(i);
		}
		rep(j,i+1,n) addr(i,j,-B[j][i]*B[i][i].inv());
		mul(i,B[i][i].inv());
		// cout&lt;&lt;i&lt;&lt;":\n";
		// rep(j,1,n) rep(k,1,n) cout&lt;&lt;A[j][k]&lt;&lt;" \n"[k==k_];
		// cout&lt;&lt;"\n";
		// rep(j,1,n) rep(k,1,n) cout&lt;&lt;B[j][k]&lt;&lt;" \n"[k==k_];
		// cout&lt;&lt;endl;
	}
	rep(i,1,n) rep(j,1,n) assert(B[i][j]==(i==j?1:0));
	rep(i,1,n) rep(j,1,n) a[i][j]=-A[i][j];
	character();
	rep(i,0,n-shift) ans[i]=f[n][i+shift]*coe;
	rep(i,0,n) cout&lt;&lt;ans[i]&lt;&lt;" \n"[i==i_];
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17755437.html</id>
    <title type="text">hez模拟赛日记2-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-10T10:33:00Z</published>
    <updated>2023-10-10T10:33:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17755437.html" />
    <content type="text">[TOC]

# 2024年1月11日

## ophelia &amp; [AGC046F] Forbidden Tournament

我放这里的意义不是记录怎么做，而是告诉自己不要做这种题了。

借cxy的话说：这种银牌难度一看题解是猜一堆结论就会了代码很短的题放模拟赛里要把组题人捅了，没有什么训练意义，cf*3000+ 或 atc红以上 的题对进集训队没啥帮助，浪费一个上午。

# 2024年1月10日

## paint &amp; QOJ7221. The Road Network

（别看模拟赛题解，看QOJ官方题解）

先将点分为两类：A 类为 $2w_i\ge d$，B 类为 $2w_i&lt; d$。

则 A 类点之间均有边，B 类点之间均没边。

也就是说，我们以一定顺序加入点，之前的状态只跟 A 类点有哪些被染成白色。

一般来说“哪些”这个东西是状压 DP，显然不行，我们尝试只记子集大小而不是子集。

那就要满足每次加入的点与已有的点之间有连边的集合能不用【加入点的点权】很好描述。

这道题只要满足每次加入点时保证已存在的 A 类点均与加入点有连边。

只要将点按：
```
[](int x,int y){
  if(min(x,d-x)!=min(y,d-y)) return min(x,d-x)&lt;min(y,d-y);
  else return x&gt;y;
}
```
排序即可，DP $f_{i,j}$ 表示加入前 $i$ 个点，加入的 A 类点有 $j$ 个为白的最大异色边数及其方案数。

复杂度 $O(n^2)$。

# 2024年1月8日

这场直接搬的 EGOI2023 d1t2 d1t3 d1t4。

[EGOI2023 我的博客](https://www.cnblogs.com/shaojia/p/17956329)

# 2024年1月5日

## tree &amp; [AGC050F] NAND Tree （经过加强）

原题是范围 $n\le 300$ 复杂度 $O(n^3)$ 的金牌题，模拟赛直接加强到 $n\le 10^6$ 复杂度 $O(n)$。。。

关键中的关键：模 $2$、双射、抵消。

&gt; 问题 O（原问题）：
&gt;
&gt; 每次选一条边收缩，最终只剩一个点权为 $1$ 的点的方案数。

假设我们最开始两次操作是收缩边 $e_1,e_2$，若她们没有公共点则 swap 顺序后结果相同，模 $2$ 抵消了，再递归用且考虑边数奇数的情况，得：

&gt; 问题 A：
&gt;
&gt; **若 $n$ 为偶数先选一条边收缩，之后进行 $\frac{n-1}{2}$ 轮：每次选三个点 $x,y,z$ 并依次收缩 $(x,y),(y,z)$ 两条边。**
&gt;
&gt; 最终只剩一个点权为 $1$ 的点的方案数。

考察收缩 $(x,y),(y,z)$ 点权发生了什么：若 $a_x\ne a_z$ 则最终点权为 $a_x$。

而对于 $a_x=a_z$ 的情况，这种收缩方式和 $(z,y),(y,x)$ 最终结果相同，抵消，所以将其最终点权设为 $a_x$ 也无妨（反正会抵消），得：

&gt; 问题 B：
&gt;
&gt; 若 $n$ 为偶数先选一条边收缩，之后进行 $\frac{n-1}{2}$ 轮：每次选三个点 $x,y,z$ **使得存在边 $(x,y),(y,z)$，$x$ 点“吃”掉 $y,z$ 两点。**
&gt;
&gt; 最终只剩一个点权为 $1$ 的点的方案数。

考虑最后存活的点是 $rt$，则除了 $rt$ 外的点权均无所谓，这种情况下对于三个均不是 $rt$ 的点 $x,y,z$ 操作，等价于 $z,y,x$ 操作（缩起来都一样，管你是啥方向/值），所以每次都要涉及 $rt$，而 $rt$ 存活，所以只能 $x=rt$。

&gt; 问题 C：
&gt;
&gt; 若 $n$ 为偶数先选一条边收缩，**选一个根 $rt$ 使得 $a_{rt}=1$**，之后进行 $\frac{n-1}{2}$ 轮：**每次选两个点 $y,z$ 使得存在边 $(rt,y),(y,z)$，$rt$ 点“吃”掉 $y,z$ 两点。**
&gt;
&gt; **求方案数。**

我们可以改成先缩 $(rt,y)$，再在新图上缩 $(rt,z)$。但是这样原图有可能是 $(rt,y),(rt,z)$ 两条边而不是 $(rt,y),(y,z)$。没关系，这样和 $y,z$ 互换的方案抵消了（两者都是 $rt$ 的儿子，交换等价）。这样 $\frac{n-1}{2}\times 2$ 个点的顺序就成 $rt$ 为根的拓扑序了。

&gt; 问题 D1：
&gt;
&gt; 若 $n$ 为偶数先选一条边收缩，选一个根 $rt$ 使得 $a_{rt}=1$，**找一个 $rt$ 为根的拓扑序。**
&gt;
&gt; 求方案数。

树的拓扑序个数：$n!/\prod_i sz_i$。换根 DP 即可，$O(n)$。

但是对于 $n$ 为偶数我们还要枚举第一条缩的边，这样朴素做就是 $O(n^2)$ 了，不能接受。

所以~~我们换一种刺杀方式~~重新回到问题 C。

发现 $\frac{n-1}{2}$ 轮每次其实就是在给之间连边的 $y,z$ 两个点做匹配，匹配之间再找拓扑序。

&gt; 问题 D2：
&gt;
&gt; 若 $n$ 为偶数先选一条边收缩，选一个根 $rt$ 使得 $a_{rt}=1$，**找一个除了 $rt$ 外的点的完美匹配，再找一个匹配边之间的拓扑序。**
&gt;
&gt; 求方案数。

当 $n$ 为偶数时，不妨设“先选一条边收缩”的边为 $(u,v)$，缩完后点设为 $uv$。

若 $uv\ne rt$，在一种方案中设和 $uv$ 匹配的点为 $w$，在这棵树上将 $(u,v)$ 展开，则 $w$ 必然和 $u,v$ 中的一个有连边，不妨是 $v$。

考虑另一种方案：先将 $(v,w)$ 缩了，称为点 $vw$，再和 $u$ 点匹配。

这两种方案构成双射，抵消。

所以只有 $uv=rt$ 需要计数，这只需要沿用拓扑序换根的做法最后枚举缩边即可。

[Submission](https://atcoder.jp/contests/agc050/submissions/49055728) 金牌题，双射题，可怕。

# 2024年1月3日

## perm

我发现我真是容斥小萌新，一开始想的是：在二维坐标下考虑，对每个长度为 $i$ 的环的方形区域求出放 $j$ 个合法的方案数，然后发现不仅这个东西求不出来，而且合并时那些全空的矩形难以计数。

wsy 一眼秒了，我没想到可以一起容斥，直接枚举钦定放了多少个不合法的计数后每个环的多项式乘起来即可。

发现环的棋盘多项式是 浅谈棋盘模型在计数问题中的应用-长郡中学-彭思进(Itst) 论文的 5.2 例题，cxy 一眼原。

其实长度为 $n$ 的环的障碍上放 $m$ 个车互不攻击的方案等价于长度为 $2n$ 的环的独立集，方案数即为
$$
\frac{2n\binom{2n-m}{m}}{2n-m}
$$
[oeis-A084534](https://oeis.org/A084534)
（考虑枚举 $2n-m$ 个空位断开转为链上独立集问题）

## gourds

虽然自己做出来的（感谢莘哥指引），感觉题很妙。

以下称吃瓜人分别为 A，B，C，$n$ 为原题中的 $n/3$。

首先要发现答案为 C 最后吃上瓜及其中的顺序的方案数乘上
$$
\frac{2^n(3n)!}{(3!)^nn!}
$$
（考虑 C 序列中自己拿到一个则 A，B 同一轮拿到的两个可以在其后面任意位置）

发现正着做是 A，B 两个序列上类似 **mex** 的东西，不好维护，所以**倒着做**。

$f_{i,j,k}$ 表示倒着放回去 $i$ 轮后，没还回去的瓜在 A 序列中的极长前缀长度为 $j$，同理在 B 序列中为 $k$ 的方案数。

$f_{i,j,k}$ 由 $f_{i-1,j',k'}$ 转移来，要求 $j\le j',k\le k',B^{-1}_{A_j}&gt;k,A^{-1}_{B_k}&gt;j$，系数为把 $(j,k)$ 偏序的 $(A^{-1}_v,B^{-1}_v)$ 对数（作为 C 的瓜编号）减去 $3(i-1)$（用过了这么多）。

复杂度 $O(n^3)$。

# 2023年12月27日

## eert &amp; P9469 [EGOI2023] Sopsug / 垃圾处理

[EGOI2023 我的博客](https://www.cnblogs.com/shaojia/p/17956329)

# 2023年11月29日

## challenge &amp; P6900 [ICPC2014 WF] Sensor Network

首先想不到的是枚举团在平面上的凸包直径 $x,y$，分别作圆心画半径为 $xy$ 的圆，交中的点才可能在团内。

以 $xy$ 边分成两半，发现两部分点的诱导子图分别是团，所以只要考虑中间的边（补图后）跑二分图最大独立集即可。

[如何构造一个二分图最大独立集方案](https://www.cnblogs.com/shaojia/p/15731380.html#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E7%9A%84%E6%9E%84%E9%80%A0)

# 2023年11月2日

## count &amp; CF1770D Koxia and Game

其实这两道题题意是不一样的：前者是排列 Bob 赢，后者是排列 Alice 赢。

共同结论：如果 $a_i,b_i,c_i$ 有主元素，则 Alice 能且只会让 Bob 选主元素。

对于前者，如果 Bob 确定得到的主元素集合 $\ne\{1,\dots,n\}$，则 Alice 一定可以强迫一个集合外的数让 Bob 永远选不到，所以 Bob 赢当且仅当主元素集合 $=\{1,\dots,n\}$。

对于后者，将序列从后往前推理，发现 Alice 要赢则每一个 $a_i,b_i,c_i$ 都要有主元素，进一步得到主元素集合 $=\{1,\dots,n\}$，充要条件。

对于两个问题，我们最后要计算的东西都一样。

若 $a_i\ne b_i$，在 $a_i,b_i$ 之间连一条边，那么 $c_i$ 相当于决定这条边会属于 $a_i$ 还是 $b_i$。

不难发现图必须是基环树，不在基环上的边有唯一方案，基环有两种方案。

特殊地，若基环是自环（$a_i=b_i$），则 $c_i$ 随便取（$n$ 种）。

# 2023年11月1日

## science &amp; CF1060G Balls and Pockets

模拟赛的时候想到做法一了，写到一半交卷交了暴力结果被子任务依赖爆了，赛后写出来了，然后被智慧做法二完爆。

### 做法一

考虑反着做，每次操作相当于在一些位置插入元素，转化为数轴正半轴上每个整点上有一个 $[0,n]$ 内的整数，而且沿正方向不降，对于一个棋子一次操作定义为向右跳【跳之前所在位置的整数】长度，$m$ 次问给定初始位置 $p$ 和操作次数 $k$ 问最后会到哪里。

设整数为 $i$ 的数轴区间为 $(a_i,a_{i+1}]$，特殊地 $a_{n+1}:=\infty$。

考虑离线，先处理掉 $p\le a_1\lor p&gt;a_n$ 的询问，和不会跳出区间（每次跳的整数相同）的询问，接下来的询问先操作到刚刚跳过原先区间的位置。

按初始位置从左往右扫描，对整数为 $i$ 的数轴区间维护 $i$ 个堆 $Q^{(i)}_0,\dots,Q^{(i)}_{i-1}$ 分别表示踩到位置 $a_{i+1}+1,\dots,a_{i+1}+i$ 的棋子集合（按剩余跳跃次数的小根堆）。

当我们从 $Q^{(i)}$ 扫到 $Q^{(i+1)}$ 的时候，先将所有 $Q^{(i)}$ 的堆的所有剩余跳跃不足以跳到 $&gt;a_{i+2}$ 位置的棋子 pop 并计算答案，然后 $Q^{(i+1)}$ 为 $Q^{(i)}$ 的 rotate（位移量取决于 $a_{i+2}-a_{i+1}$ 的大小）空掉一个堆，最后将所有 $i+1$ 区间内起始的询问插入 $Q^{(i+1)}$ 的对应堆中。

如何快速找到哪个堆堆顶要 pop 以及如何维护 rotate？fhq treap 即可。

复杂度单 $\log$。

[code（删减前，4.8K）](https://codeforces.com/contest/1060/submission/230908234)

[code](https://codeforces.com/contest/1060/submission/230912798)

### 做法二

抛弃反着做，直接正着来。

考察数轴充分远处的连续的 $n$ 个球（$n$ 是坑的数量），**顺次编号 $1\sim n$**，我们不断操作，发现 $n$ 个球到过的所有位置一定不重复，而且覆盖了所有从第一个坑到初始位置的所有位置（证明可看洛谷题解或模拟赛发的）。

我们找最后一个坑紧接的连续 $n$ 个，模拟上述过程，若一个询问位置是第 $t$ 次操作后被**编号为** $x$ 的球踩过，则其答案为编号为 $x$ 的球在 $t-k$（$k$ 是询问的操作次数）（$t-k&lt;0$ 的 case 是平凡的）次操作后的位置。

加速这个模拟的过程（数乘所有没有带编号球被坑杀的操作），用树状数组维护每个编号的球是否还在，要树状数组上倍增。

复杂度单 $\log$。

[code（2.5K）](https://codeforces.com/contest/1060/submission/231069940)

# 2023年10月31日

## build &amp; P7718 「EZEC-10」Equalization

咕。

# 2023年10月26日

## ball

非常好题目，让我学会排球。

咕。

## hamo

### 做法一

首先有个很好想的随机化做法，每个矩形随机 $k$ 个数，然后判断是否是绝对众数，时间复杂度 $O(nm+qk\log)$，应该被卡时间了。

### 做法二（赛时做法，被cxy教导了）

我说：要是有单 $\log$ 做法我去紫砂。然后cxy就说那你去紫砂吧。

考虑摩尔投票，然后发现这个不大能差分成前缀贡献形式，我们使用二区间合并。

二区间合并想到离线询问并对 $x$ 轴做猫树分治，而 $y$ 轴普通的线段树单点改区间查做法总共是双 $\log$ 的。

这里妙的一点是我们做的是**整个序列对应位置合并**，由于长度相同，**线段树结构完全相同**，所以将线段树对应节点的摩尔投票合并即可，总复杂度 $O((nm+q)\log)$ 的。

最后将求出来的候选绝对众数做一遍二维数点即可。

### 做法三

一个很厉害的做法，如果存在绝对众数，那么她二进制下每一位的出现次数一定是大于一半的，所以我们对每一个二进制位都做一遍前缀和，然后得到每一个询问答案二进制下的答案，再做二维数点即可，这个代替了做法二的二区间合并的部分，使得常数很小。

# 2023年10月24日

## allah &amp; [AGC004F] Namori

将题意转化成：给每条边设一个整数边权，使得每个点相邻的边权之和恰好为 $1$，让边权绝对值之和尽量小。

为什么转化是等价的呢？shz 说证明只需要考虑构造一种边（边权的绝对值看作重边）的操作顺序使得每个时刻每个点的值都 $\in\{0,1\}$。

所以每个点受到的操作序列一定得是 $+1,-1,\dots,-1,+1$。

参考 CSP 树上的数，给每个点相邻的边规定拓扑序即可，基环的情况调整使得拓扑序不存在环即可，没细想。

发现对于一棵树的情况，边权可以是从叶子到根唯一确定的，最后必须满足根的边权和恰好为 $1$。

而对于环的情况，根的边权和可以不是 $1$，我们先将非基环边确定好边权，扔掉。设环上一条边的边权后，接下来就是环上解方程问题：对于奇环，答案要么唯一要么无解；对于偶环，让边权绝对值之和尽量小，最后是一个类似中位数的东西。

做完了，复杂度可以做到线性。

# 2023年10月19日

## mod &amp; 基础循环结构练习题

[原题Link](https://contest.xinyoudui.com/contest/93/problem/370)

咕。

## rock &amp; P4481 [BJWC2018] 序列合并

原题不卡常模拟赛卡常，呜呜呜。

## glass &amp; P3488 [POI2009] LYZ-Ice Skates

模拟赛是原题加强版！牛牛牛。

咕。

# 2023年10月12日

## sum

组合意义保平安，$\binom{n+m-1}{2m-1}$。

## square

树链查询颜色是否互异，用 bitset 维护颜色，异或起来 popcount 是否等于链长即可。

也可以用树上莫队做。

## array &amp; [ARC117F] Gateau

以下 $A$ 和值的数组都是 1-index。

作前缀和 $s_0(=0),\dots,s_{2n}$，二分答案（为了容易处理被切开的区间限制）$s_{2n}=v$ 后所有限制为（稍微简化过后）：
$$
\forall i\in[1,2n-1],s_{i-1}\le s_i
\\
s_{2n-1}\le s_0+v
\\
\forall i\in[1,n],s_{i+n-1}-s_{i-1}\in[A_i,v-A_{i+n}]
$$
二分后差分约束 spfa 判负环，复杂度 $O(n^2\log)$。

考虑人工判负环，将 $s_0,\dots,s_{n-1}$ 画在第一行，$s_n,\dots,s_{2n-1}$ 画在第二行，则约束边看起来长这样：

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231103171500065-1731887829.png)

由于我们只要判断是否有不重复经过点的负环就行了，发现只有三种情况：中间 $n$ 个二元有向环、$s_0$ 走红 $v$ 边后走黑边回到 $s_0$、$s_n$ 走红 $0$ 边后走黑边回到 $s_n$。

第一种直接 $O(n)$ 判，后两种走黑边的情况显然可以 DP，所以整道题 $O(n\log)$ 做完。

# 2023年10月10日

## coin

巨难 T1。

![](https://img2023.cnblogs.com/blog/2213867/202310/2213867-20231010182507745-1885681776.png)

## holiday

2022年10月10日 T3 travel 的史诗弱化版，检验大家有没有补题。

## azusa &amp; CF1882E2 Two Permutations (Hard Version)

## alien &amp; P8380 Two Hypercubes</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17756389.html</id>
    <title type="text">Linux 乱用-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-11T02:06:00Z</published>
    <updated>2023-10-11T02:06:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17756389.html" />
    <content type="text">是谁想出来省选全要用 Linux 的？

以下内容仅 vscode，不过部分命令是通用的。

在某个目录下的终端输入 `code .` 进入 vscode，并且工作区即为此目录。

编译：写完代码后在 vscode 的对应文件夹下的终端输入 `g++ transfer.cpp -o transfer -Wall -O2 -std=c++14` 可以编译 `transfer.cpp`，生成文件 `transfer`。

终端 / vscode 下方栏终端 不会写的时候可以试试按 tab 补全，比如 `-fsanitize=address,undefined`（作用：产生 UB 时会被杀死，例如溢出、数组越界。但是会导致程序非常慢，测时间要关掉。）。

字号可以改（settings -&gt; text editor -&gt; font）。

`diff transfer1.out transfer1.ans -b` 等价于 "fc"。不过 vscode 有自带比较器，也可以使用。

ctrl+g 唤出顶部输入框。

打开文件 `./transfer`。

`ulimit -s unlimited` 开无限栈。其实可以等栈爆了再开。

`/usr/bin/time -f "%Us %MKB" ./transfer` 这个命令可以显示时间和内存，时间是 user time。`/usr/bin/time -v` 显示所有信息。

对拍和 windows 一样写就行，把 `system` 里的一些内容换成 Linux 下对应的就行，例如 `fc` 替换为 `diff`。

命令里的复制和粘贴不用 CTRL+C &amp; CTRL+V，需要再加一个 SHIFT。CTRL+C 用于终止命令，如对拍停止。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17773072.html</id>
    <title type="text">XYD CSP-S 2023 复赛模拟赛 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-18T10:33:00Z</published>
    <updated>2023-10-18T10:33:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17773072.html" />
    <content type="text">出题人：myee（叶开）

[比赛面板](https://contest.xinyoudui.com/contest/145#/ProblemList)

# First Snow

当你发现可以 $O(n^4/w)$ 过，就是 bitset 傻逼题。

# Paradise

将不优的套餐去掉，之后对于固定的总量就是能取大的就取大的，然后就是推式子了。

# nέο κόsmo

对每个关键节点为起点跑 dijkstra，然后状压即可，细节小多。

# Nirv lucE

将整串 reverse 后作 kmp 建出失配树（下标从 $1$ 开始），设 $a_x=a_{fail_x}+x$，则对于一个询问 $q$ 我们要求
$$
ans=\sum_{i=1}^{q-1}\sum_{j=i+1}^{q}(\max(a_i,a_j)-a_{\text{lca}(i,j)})
$$
考虑将两部分拆开计算并且增量法，计算 $q-1$ 询问到 $q$ 询问的增量
$$
\Delta ans=\sum_{i=1}^{q-1}\max(a_i,a_q)-\sum_{i=1}^{q-1}a_{\text{lca}(i,q)}
$$
前者可以使用两棵树状数组简易求得，设求后者的问题为 $Q_q$。

在失配树上作线段树合并，线段树的下标 $x$ 即为 $Q_x$。每次将 $v$ 的线段树合并到 $fail_v$ 上，此时两棵线段树的存在下标的笛卡尔积都要对下标更大的一方的 $Q$ 贡献 $a_{fail_v}$ 的值。

在线段树合并的同时作线段树子树加即可。

复杂度单 $\log$，但是被 cxy 的两 $\log$ 树剖爆踩。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17778626.html</id>
    <title type="text">2023 CSP-S-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-21T02:57:00Z</published>
    <updated>2023-10-21T02:57:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17778626.html" />
    <content type="text"># Day -114

初赛稳过，仅次于 shz，报名了，-￥480，选择了 Linux 机。

# Day 0

Open，被 zys 教导如何打块，感觉实力大幅上升。

然后水 bilibili，睡前突击了一下 Linux / vscode 用法啥的。

晚上弹唱了“话匣子头”的经典歌曲《爬》（B 站有视频），被群友评论抽象。

# Day 1

昨晚 12 点睡的，9 点起，有点太困了。

早上随便又看了些系统操作，随便吃了中饭出发，带了两瓶农夫山泉和一瓶红牛。

在杭师大恕园16 前和大家等了一会，发现好多退役的都来了，看到了漏宝和DX。

一开场不知道锁屏密码，还找不到我的子文件夹应该建哪里，发现旁边是 fsz，好心地教了我，然后压缩包打不开，重新发了一份。

发现考场 vscode 的快捷键编译的 .json 和我虚拟机的不太一样，弄不了。 

T1 傻逼题。

T2 我直接开始玩原神，一眼随机矩阵，之后想了一会有没有别的做法无果。

这时候发现代码里会时不时复制随机一段到随机的地方，以为中病毒了，但可能就是我按了神秘快捷键。

T3 题意理解了好久发现末尾有形式化，亏了，但是直接模拟就行了，我直接 `vector&lt;tuple&lt;int,string,ll&gt; &gt;` 各种 STL 魔鬼都上，非常好写。

T3 出题人原神几级了？

T4 还以为 $\max(b+cx,1)$ 应该是 $\min$，还坐等勘误，结果发现就是 $\max$ 啊，我精神恍惚。二分答案后求出每个点拓扑序上界就行了，计算上界有点麻烦（我二分的），复杂度双 $\log$。

以为会被卡时间，结果其实飞快。

16:30 了上厕所，发现cxy也在排队，看到我一脸坏笑，可能是嘲讽题目太简单了。

之后写了一个自动测样例程序，造了一个 T2 的极限数据，发现我 T2 的散列表巨慢，改成 `sort` 飞快了。

之后就是无意义时间了。

出来聊了一下都说简单，聊了一些题目。

cxy 说后半场他想到之前一道回文串题的做法有锅，考场上想了一会修好了，结果人太多了没来得及听做法。

吃了跷脚牛肉回家了。

晚上在 close day，bilibili 启动。

自测了中间洛谷测的挂了 5pts，结果是洛谷数据挂了。

听说 cxy 文件建错保单了，祝好，但是反正他能参加 noip。

群友说找到了 T2T4 的原题（CF1223F AT_abc304_h），我发现了我 T3 随机矩阵做法来源 QOJ6504. Flower's Land 2。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17791198.html</id>
    <title type="text">重修 Tarjan-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-10-27T02:24:00Z</published>
    <updated>2023-10-27T02:24:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17791198.html" />
    <content type="text">很久之前写的 [Tarjan（年早失修 漏洞百出）](https://www.cnblogs.com/shaojia/p/15380404.html) 非常混乱，好多说的都是错的，重新写一篇。

## 有向图 SCC（缩点）

结论：对于已经完整求出来的 SCC，将其点和所有相邻的边删去后对剩下的图继续求 SCC 是对的。

原因是 SCC 缩点后是 DAG，删掉一个后不影响强连通性。

在图中随便找一个点作为根，找出一棵外向 DFS 树，容易证明不可能有 SCC 的点集同时包含了 DFS 树上的点和之外的点，所以我们将 DFS 树求出 SCC 后将树上所有点删去递归做即可。

接下来只要考虑两端都在 DFS 树上的边即可，分为：
* 树边。字面意思。
* 返祖边。指向 DFS 树上自己祖先的边。
* 前向边。指向 DFS 树上自己子树内点的边。由于走树边也可以走到，所以这种边对连通性没有影响，只有在代码实现的时候我们才会考虑她。
* 横叉边。指向和自己没有祖孙关系的点的边。由于我们找的是 DFS 树，所以只会指向已经遍历过的点。

容易证明一个结论：任意 SCC 在树上是一个连通块。所以设 SCC 在树上深度最小的那个点为代表元。

按照某个顺序 DFS 这棵树，不断删掉已经确定的 SCC。

设当前遍历到点 $x$，她不是代表元当且仅当其子树内存在连到子树外的有向边（注意，此时我们已经将完整的 SCC 删去，所以连向这些点的边已被删去）。

所以就得到了经典的 SCC 代码，代码中 `if(!col[i])` 分支中（未被删去的横叉和返祖）对 $low_i$ 或 $dfn_i$ 取 $\min$ 均可。

也可以理解为将未被删去的其他分叉的点挂在 lca 上。

## 无向图边双连通分量（割边a.k.a.桥）

将求 SCC 的过程改一改。

首先改成无向边，这样横叉边没了（前向边也没了），然后一样做就好了。

## 无向图点双连通分量（割点）

这个问题的纯 tarjan 代码 corner cases 有点多，建议写圆方树。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17834504.html</id>
    <title type="text">建议改为：回来吧，牛逼联考题（EI,yjj）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-11-15T10:39:00Z</published>
    <updated>2023-11-15T10:39:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17834504.html" />
    <content type="text">## 模拟赛 20210329 山遥路远（distant） EI

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231115185756629-510289110.png)

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231115185837748-265269592.png)

首先模 $998244353$ 是来搞笑的。

设 $d_{x,y}$ 表示 $x\to y$ 的最短合法括号串路径长度，然后发现就有点无从下手了。

重要观察为边权均非负，所以 $d_{*,*}$ 中值最小的一定不会改变，所以可以扩展更新别的值（类似 dijkstra）：
* 套上一层括号。
* 之前**与**之后接上一段合法括号串路径，注意接上路径的 $d$ 不一定确定了，但是两段一定有一段的 $d$ 是较晚确定的，所以一定都要更新。

发现第一类转移要枚举两侧的点，复杂度 $O(n^4\log)$，考虑增设中间状态 $g_{x,y}$ 表示括号串前端多一个左括号的最短路径长度，这样复杂度就是 $O(n^3\log)$。

考虑如何去掉 $\log$，目前我们用堆在做这样的事情：
* $O(n^3)$ 次 decrease-key。
* $O(n^2)$ 次查询全局最小值位置。

发现两者次数非常不均衡！所以改成分 $n$ 块长度为 $n$ 的块，维护每个块的最小值，这样 decrease-key 的复杂度为 $O(1)$，查询全局最小值位置复杂度为 $O(n)$。

~~cxy：我终于又重新发明了分块算法。~~

总复杂度 $O(n^3)$。

P.S. 即使没有合法括号串的限制，做法也要 floyd 或 dijkstra 的 $O(n^3)$，为什么加了括号串限制复杂度没变呢？

P.P.S. 由 $d$ 的扩展方法，得到答案括号深度不超过 $O(n^2)$，再考虑每个点按到达时的括号高度拆成 $O(n^2)$ 个点跑最短路，得到这道题答案上界 $O(n^3w)$，所以不会爆 longlong。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
const int N=404;
const ll inf=1e18;
int n;
ll p[2][N][N],e[2][N][N],rp[2][N];
bool vis[2][N][N];
inline void ckm(int t,int x,int y,ll v){
	if(p[t][x][y]&gt;v){
		p[t][x][y]=v;
		ckmn(rp[t][x],v);
	}
}
void get(int&amp;t,int&amp;x,int&amp;y){
	ll now=inf;
	rep(i,0,1) rep(j,1,n) ckmn(now,rp[i][j]);
	rep(i,0,1) rep(j,1,n) if(rp[i][j]==now){
		t=i,x=j;
		goto qwq;
	}
	qwq:;
	rep(k,1,n) if(!vis[t][x][k] &amp;&amp; p[t][x][k]==now){
		y=k;
		break;
	}
	if(y!=-1){
		vis[t][x][y]=true;
		rp[t][x]=inf;
		rep(k,1,n) if(!vis[t][x][k]) ckmn(rp[t][x],p[t][x][k]);
	}
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int m,T;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;
	rep(i,0,1) rep(j,1,n) rep(k,1,n) p[i][j][k]=e[i][j][k]=inf;
	rep(i,0,1) rep(j,1,n) rp[i][j]=inf;
	while(m--){
		int x,y,yy;
		ll xx;
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;xx&gt;&gt;yy;
		ckmn(e[yy-1][x][y],xx);
	}
	rep(i,1,n) ckm(0,i,i,0);
	while(1){
		int t,x,y=-1;
		get(t,x,y);
		if(y==-1) break;
		if(t==0){
			rep(i,1,n){
				ckm(1,i,y,e[0][i][x]+p[0][x][y]);
				ckm(0,i,y,p[0][i][x]+p[0][x][y]);
				ckm(0,x,i,p[0][x][y]+p[0][y][i]);
			}
		}else{
			rep(i,1,n){
				ckm(0,x,i,p[1][x][y]+e[1][y][i]);
			}
		}
	}
	while(T--){
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		if(p[0][x][y]==inf) cout&lt;&lt;"-1\n";
		else cout&lt;&lt;p[0][x][y]%998244353&lt;&lt;"\n";
	}
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

## 模拟赛 20211006(?) 蝴蝶图 EI

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231115190201107-882844478.png)

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231115190414166-1643927908.png)

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231115190227779-894142817.png)

**题意补充：新蝴蝶图的 $L,R$ 要和原图相同。**

设 $S=L\cap R$。

一个简单的想法是，枚举 $S$ 中选取的边，然后分别对 $L,R$ 两边做 Kruskal 求 MST。

进一步，发现只有 $S$ 中的连通性才对 Kruskal 是重要的，所以枚举 $S$ 的连通情况，方案数是 Bell 数。

[oi-wiki Bell 数](https://oi-wiki.org/math/combinatorics/bell/)，$B_{11}=678570$，$B_{15}$ 就大于 $10^9$ 了。

对每个 $S$ 的子集用 Prim 预处理出 MST。

不妨只考虑 $L$ 这边。不论 $S$ 中的连通性如何，$L$ 中 MST 的边集只会变动不多于 $|S|-1$ 条。因为，考虑 Kruskal 的过程，若枚举到一条边两端连通则抛弃，否则若两端的连通块不是均有 $S$ 中的点，则必选入 MST 中，否则是否选入取决于这两部分是否已经通过 $S$ 内的边连通了。由于 $S$ 每次合二为一，所以这样的边数不超过 $|S|-1$。

先求出必定在 MST 上的边，之后等价于不多于 $|S|-1$ 个顺次的事件 $(x_i,y_i,z_i)$ 表示若 $S$ 中 $x_i,y_i$ 此时不连通则合并这两个连通块，并将 MST 边权加上 $z_i$，实现看代码（每个连通块找一个 $S$ 里的代表元）。

设 $c:=|S|$，复杂度 $O(m\log+c^2 2^c+B_c c\alpha(c))$。

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
const int N=100010,M=200010,C=11,inf=1e9;
const ll linf=1e18;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge&amp;t)const{
		return w&lt;t.w;
	}
}e[M];
int n,m,ma,g[C][C],dis[C],bl[N],k=0,p[C],ip[N],f[N],re[N];
ll tr[1&lt;&lt;C],base=0,ans=linf;
bool vis[C];
vector&lt;tuple&lt;int,int,int&gt;&gt; op[2];
int d[C],dt=0;
inline int gf(int x){
	return x==f[x]?x:f[x]=gf(f[x]);
}
void slv(bool ty){
	iota(f+1,f+1+n,1);
	fill(re+1,re+1+n,-1);
	rep(i,0,k-1) re[p[i]]=i;
	int ban=1&lt;&lt;(!ty);
	rep(i,1,m){
		int x=e[i].u,y=e[i].v,z=e[i].w;
		if(bl[x]!=ban &amp;&amp; bl[y]!=ban &amp;&amp; (bl[x]!=3 || bl[y]!=3)){
			x=gf(x),y=gf(y);
			if(x!=y){
				if(re[x]!=-1 &amp;&amp; re[y]!=-1){
					op[ty].eb(re[x],re[y],z);
				}else{
					base+=z;
				}
				f[y]=x;
				ckmx(re[x],re[y]);
			}
		}
	}
}
void dfs(int s){
	if(!s){
		ll now=0;
		rep(i,0,dt-1) now+=tr[d[i]];
		rep(ty,0,1){
			iota(f,f+k,0);
			rep(i,0,dt-1){
				int w=d[i];
				int x=__lg(w&amp;(-w));
				rep(j,0,k-1) if(w&amp;(1&lt;&lt;j)){
					f[gf(j)]=gf(x);
				}
			}
			for(const auto&amp;i:op[ty]){
				int x,y,z;
				tie(x,y,z)=i;
				x=gf(x),y=gf(y);
				if(x!=y){
					now+=z;
					f[y]=x;
				}
			}
		}
		ckmn(ans,now);
		return ;
	}
	int x=s&amp;(-s);
	d[dt++]=x;
	s^=x;
	for(int i=s;;i=(i-1)&amp;s){
		d[dt-1]^=i;
		dfs(s^i);
		d[dt-1]^=i;
		if(!i) break;
	}
	dt--;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	int t0,t1;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t0&gt;&gt;t1;
	rep(i,1,m) cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
	sort(e+1,e+1+m);
	while(t0--){
		int x;cin&gt;&gt;x;
		bl[x]|=1;
	}
	while(t1--){
		int x;cin&gt;&gt;x;
		bl[x]|=2;
	}
	rep(i,1,n) if(bl[i]==3){
		p[k++]=i;
	}
	rep(i,0,k-1) ip[p[i]]=i;
	// rep(i,0,k-1) cout&lt;&lt;p[i]&lt;&lt;" \n"[i==i_];
	rep(i,0,k-1) fill(g[i],g[i]+k,inf);
	rep(i,1,m){
		if(bl[e[i].u]==3 &amp;&amp; bl[e[i].v]==3){
			ckmn(g[ip[e[i].u]][ip[e[i].v]],e[i].w);
			ckmn(g[ip[e[i].v]][ip[e[i].u]],e[i].w);
		}
	}
	ma=(1&lt;&lt;k)-1;
	rep(s,1,ma){
		rep(i,0,k-1) vis[i]=(s&gt;&gt;i)&amp;1;
		fill(dis,dis+k,inf);
		dis[__lg(s&amp;(-s))]=0;
		while(1){
			int x=-1;
			rep(i,0,k-1) if(vis[i] &amp;&amp; (x==-1 || dis[i]&lt;dis[x])){
				x=i;
			}
			if(x==-1) break;
			vis[x]=false;
			tr[s]+=dis[x];
			rep(i,0,k-1) if(vis[i]) ckmn(dis[i],g[x][i]);
		}
		// cout&lt;&lt;s&lt;&lt;":"&lt;&lt;tr[s]&lt;&lt;"\n";
	}
	slv(0);
	slv(1);
	dfs(ma);
	cout&lt;&lt;ans+base&lt;&lt;"\n";
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;

## 模拟赛 20221003 color yjj

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231117210755994-335217545.png)

$n,q\le 10^5$，以下计算复杂度时不区分 $n,q$。

先考虑反向统计，统计每条路径不经过哪些颜色，以及把求和式子变为 $l\le i,j\le r$。

发现对于一种颜色相当于有许多集合，每个集合是一个子树扣掉一些子树，然后集合内的点两两有贡献。

我们设一个集合 $S$ 被表示成【子树扣掉一些子树】中子树数量为 $k_S$，容易发现 $k_S$ 的和是 $O(n)$（显然同时集合个数也是 $O(n)$ 的）。

我们对 $k_S$ 值的大小分治：

* $k_S\ge G$：这样的 $S$ 个数是 $O(\frac{n}{G})$，树上链求和可以求出 $S$ 内包含哪些点，对 $q$ 个询问分别求出该点编号区间中有 $x$ 个 $S$ 内的点，则贡献为 $x^2$。这部分复杂度为 $O(\frac{n^2}{G})$。

* $k_S&lt;G$：这部分的所有 $S$ 一起处理。将点按点编号块长 $B$ 分块，通过【树上链求和】与【树上子树求和】（详见代码）$O(\frac{n^2}{B})$ 复杂度处理出每个块与每个单点之间的 $B$ 对点的贡献之和。将单点的答案作前缀和就可以求出每个块与每个区间之间的贡献之和了，剩下只有 $O(B^2)$ 对散块点之间的贡献需要被统计了，详见下文。

一种朴素的想法是枚举集合以及其中的点对，将点对的贡献 $+1$，随后对 $O(qB^2)$ 个点对查贡献即可。

尝试将点对的贡献优化到形如“$u$ 子树点集和 $v$ 子树点集的笛卡尔积都有 $w$ 的贡献”，【$S$ 自身的笛卡尔积有为 $1$ 的贡献】可以通过 $k_S$ 项式平方展开转化为【$k_S^2$ 对子树之间有 $\pm 1$ 的贡献】，由于 $k_S&lt;G$，所以 $\sum k_S^2&lt;G\sum k_S=O(nG)$。

所以我们 DFS $u$ 这一维，$v$ 这一维变成 $O(nG)$ 次子树加，$O(qB^2)$ 次单点查，用一个 $k$ 叉线段树（a.k.a. $\log_k n$ 层分块）维护即可。

复杂度 $O(\frac{n^2}{G}+\frac{n^2}{B}+(nkG+nB^2)\log_k n)$，取 $G=B=k=n^{1/3}$ 即可做到复杂度 $O(n^{5/3})$，但是实测中取值偏得离谱。

这题时限 4s，yjj std 跑了 3.7s，我要跑 7.6s，估计是实现不够精细、调参不够优秀、手动循环展开懒得写，能不能算我赢了？？

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
#pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
// #define int ll
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; vi;
#define fir first
#define sec second
#define mkp make_pair
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define pb push_back
#define eb emplace_back
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))
const int N=100010,G=10,B=90;
#define C1 5
#define C2 5
#define Ct 10
int n,q,a[N],L[N],R[N],lb[N],rb[N],pt,f[N],dfn[N],id[N],sz[N],tot=0,cc[N],c[N];
vi e[N],lst[N],sma,dd[N],rg[N];
vector&lt;pi&gt; gx[N];// (to,coe)
ll ans[N],dc[N];
pair&lt;int,vi&gt; p[N&lt;&lt;1];
void dfs(int rt,int fa){
	dfn[rt]=++tot;
	id[tot]=rt;
	f[rt]=fa;
	sz[rt]=1;
	vi&amp;v=lst[a[rt]];
	p[v.back()].sec.eb(rt);
	for(int i:e[rt]) if(i!=fa){
		p[++pt].fir=i;
		v.eb(pt);
		dfs(i,rt);
		v.pop_back();
		sz[rt]+=sz[i];
	}
}
inline void lian(){
	rep(i,2,n){
		int rt=id[i];
		c[rt]+=c[f[rt]];
	}
}
inline void sub(){
	per(i,n,2){
		int rt=id[i];
		cc[f[rt]]+=cc[rt];
	}
}
inline ll pw(ll x){ return x*x; }
int lx[N],ly[(N&gt;&gt;C1)+5],lz[(N&gt;&gt;Ct)+5];
ll addcnt,quecnt;
inline void Add(int l,int r,int v){// nB times
#ifdef SuperAnton
	addcnt++;
#endif
	int dl=((l+(1&lt;&lt;C1)-2)&gt;&gt;C1&lt;&lt;C1)+1,dr=r&gt;&gt;C1&lt;&lt;C1;
	if(dl&gt;dr+1){
		#pragma GCC unroll(8)
		rep(i,l,r) lx[i]+=v;
		return ;
	}
	#pragma GCC unroll(8)
	rep(i,l,dl-1) lx[i]+=v;
	#pragma GCC unroll(8)
	rep(i,dr+1,r) lx[i]+=v;
	l=(dl&gt;&gt;C1)+1,r=(dr&gt;&gt;C1);
	dl=((l+(1&lt;&lt;C2)-2)&gt;&gt;C2&lt;&lt;C2)+1,dr=r&gt;&gt;C2&lt;&lt;C2;
	if(dl&gt;dr+1){
		#pragma GCC unroll(8)
		rep(i,l,r) ly[i]+=v;
		return ;
	}
	#pragma GCC unroll(8)
	rep(i,l,dl-1) ly[i]+=v;
	#pragma GCC unroll(8)
	rep(i,dr+1,r) ly[i]+=v;
	l=(dl&gt;&gt;C2)+1,r=(dr&gt;&gt;C2);
	#pragma GCC unroll(8)
	rep(i,l,r) lz[i]+=v;
}
#define Que(x) (lx[x]+ly[((x-1)&gt;&gt;C1)+1]+lz[((x-1)&gt;&gt;Ct)+1])// nB^2 times
void slv(int rt){
	for(auto i:gx[rt]){
		int to=i.fir,coe=i.sec;
		Add(dfn[to],dfn[to]+sz[to]-1,coe);
	}
	for(int i:dd[rt]){
		ll tmp=0;
		int x=dfn[rt];
#ifdef SuperAnton
		quecnt+=siz(rg[i])+1;
#endif
		for(int j:rg[i]) tmp+=Que(j);
		ans[i]+=(tmp&lt;&lt;1)+Que(x);
		rg[i].eb(x);
	}
	for(int i:e[rt]) if(i!=f[rt]) slv(i);
	for(auto i:gx[rt]){
		int to=i.fir,coe=i.sec;
		Add(dfn[to],dfn[to]+sz[to]-1,-coe);
	}
}
#ifdef SuperAnton
#define debcl cerr&lt;&lt;__LINE__&lt;&lt;"#"&lt;&lt;clock()&lt;&lt;endl
#else
#define debcl ((void)0)
#endif
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin&gt;&gt;n&gt;&gt;q;
	rep(i,1,n) cin&gt;&gt;a[i];
	rep(i,1,n-1){
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		e[x].eb(y);
		e[y].eb(x);
	}
	pt=0;
	rep(i,1,n){
		p[++pt].fir=1;
		lst[i].eb(pt);
	}
	dfs(1,0);
	rep(i,1,q) cin&gt;&gt;L[i]&gt;&gt;R[i];
	debcl;
	rep(i,1,pt){
		if(siz(p[i].sec)&gt;=G){
			fill(c+1,c+1+n,0);
			c[p[i].fir]++;
			for(int j:p[i].sec) c[j]--;
			lian();
			rep(j,1,n) c[j]+=c[j-1];
			rep(j,1,q) ans[j]+=pw(c[R[j]]-c[L[j]-1]);
		}else{
			sma.eb(i);
		}
	}
	rep(i,1,q){
		lb[i]=(L[i]+B-2)/B*B+1;
		rb[i]=R[i]/B*B;
	}
	debcl;
	for(int l=1,r;l&lt;=n;l=r+1){
		r=l+B-1;
		rep(i,1,n) cc[i]=(l&lt;=i &amp;&amp; i&lt;=r);
		sub();
		fill(c+1,c+1+n,0);
		for(int i:sma){
			int x=cc[p[i].fir];
			#pragma GCC unroll(8)
			for(int j:p[i].sec) x-=cc[j];
			c[p[i].fir]+=x;
			#pragma GCC unroll(8)
			for(int j:p[i].sec) c[j]-=x;
		}
		lian();
		rep(i,1,n) dc[i]=c[i]+dc[i-1];
		rep(i,1,q){
			if(L[i]&lt;=l &amp;&amp; r&lt;=R[i]){
				ans[i]+=((dc[R[i]]-dc[L[i]-1])&lt;&lt;1)-(dc[rb[i]]-dc[lb[i]-1]);
			}
		}
	}
	debcl;
	rep(i,1,q){
		if(lb[i]&gt;rb[i]+1){
			rep(j,L[i],R[i]) dd[j].eb(i);
		}else{
			rep(j,L[i],lb[i]-1) dd[j].eb(i);
			rep(j,rb[i]+1,R[i]) dd[j].eb(i);
		}
	}
	debcl;
	for(int i:sma){
		gx[p[i].fir].eb(p[i].fir,1);
		vi&amp;v=p[i].sec;
		for(int j:v){
			gx[p[i].fir].eb(j,-1);
			gx[j].eb(p[i].fir,-1);
		}
		for(int j:v) for(int k:v) gx[j].eb(k,1);
	}
	debcl;
	slv(1);
	debcl;
	rep(i,1,q) cout&lt;&lt;(pw(R[i]-L[i]+1)*n-ans[i]-(R[i]-L[i]+1))/2&lt;&lt;"\n";
#ifdef SuperAnton
	cerr&lt;&lt;addcnt&lt;&lt;" "&lt;&lt;quecnt&lt;&lt;endl;
#endif
return 0;}
/*
Super Anton 的笑容，都没你的甜。
凌晨一点的月光，都在看你演。
热爱深夜打比赛的你，场场破防把分掉没。
*/
```
&lt;/details&gt;</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17847451.html</id>
    <title type="text">2023-2024 ICPC NERC (NEERC), North-Western Russia Regional Contest (Northern Subregionals)-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-11-21T11:59:00Z</published>
    <updated>2023-11-21T11:59:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17847451.html" />
    <content type="text">&lt;https://codeforces.com/gym/104772/&gt;

官方题解是毛子文的，建议用 deepl 翻译或不看。

下文按题号排序。

# Colorful Village

先枚举 $1$ 号颜色选了哪个点并定此为根，剩下就是 2-sat 问题，限制为 父亲不选 $\implies$ 我不选 以及逆否命题。

# Divisibility Trick

场上写了一个 $O(d^2)$ 的建图 BFS：$(x,y)$ 表示不断向低位加 digit，目前值余数为 $x$，数位和余数为 $y$。

高情商：这样能解决最小化答案的问题。

低情商：这样就过了：

```cpp
int n;cin&gt;&gt;n;rep(i,1,n)cout&lt;&lt;n;
```

#  H-Shaped Figures

感觉是我见过比较棒的 geo 题了。

先把不可能合法的线段删掉，将剩余线段分为经过 $P,Q$ 两类，分别设为集合 $vp,vq$。

发现枚举 $vp$ 不太好统计 $vq$，考虑全集 $|vp|\cdot|vq|$ 减不合法，由于两条分别 $vp,vq$ 内的线段最多有一个交点（废话），分别计算交点在线段 $PQ$ 两侧的不合法数量，减去即可。由对称性我们只阐述一侧。

保留所有线段在 $PQ$ 这一侧的端点，转化为这样的问题：在直线 $PQ$ 的一侧有两个点集 $pv,qv$，求这样 $x,y$ 的数量：$x\in pv,y\in qv$，线段 $xP$ 与 $yQ$ 有交（有公共点）。

将两个点集均按到 $Q$ 的向量极角排序，扫描线，维护扫过所有 $qv$ 中的点到 $P$ 的向量，扫到 $pv$ 的点时查询在其到 $P$ 向量某一侧（e.g. 逆时针方向）的扫过的 $qv$ 点个数，离散化树状数组复杂度线性对数。

![](https://img2023.cnblogs.com/blog/2213867/202311/2213867-20231121201103614-1177757530.png)

其实后面的问题就是 [双角坐标系](https://baike.baidu.com/item/%E5%8F%8C%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/22801996?fr=ge_ala) 的离线二维数点问题，感觉是很新颖的组合。

# Jumping Frogs

如果要达成答案为 $x$，肯定让 $a$ 的前 $n-x$ 顺次和 $b$ 的对应长后缀匹配，让 $a$ 的后 $x$ 顺次和 $b$ 的对应长前缀匹配。

前者能成功的 $x$ 是一个后缀，后者成功的 $x$ 是前缀，分别二分即可，答案集合就是这个区间。

# Loops

好题，难题，好难题。

先考虑没有 type 3 咋做：依次确定每一行之间的大小关系</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17893231.html</id>
    <title type="text">第 48 届 ICPC 杭州站 游记 + 部分题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-12-10T13:09:00Z</published>
    <updated>2023-12-10T13:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17893231.html" />
    <content type="text"># before

报名费好像五百多。

队友：cmk，cyb。

赛前让 cyb 打印了几份板子。

不决定带词典。

# 12.09 热身

上午坐车到杭师大，到早了，衣服不错，自己衣服带多了，热热热，套圈只拿了冰箱贴，只有纸质饭票惨惨，差点弄丢，急死了。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210221835592-1876969117.png)

开幕式其他忘了，杭电刘春英🐬讲相声，乐乐乐，说坐地铁不要经过打铁关（剧透：这天晚上就经过了）。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210214739508-1383692099.jpg)

热身赛，给了四道 icpc 原题，我们键盘不灵，叫人换了，ABC 切切切，D 不会，猜结论，假假假还写错，赛后看原题题解发现结论差不多，神秘做法。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210214843146-1214306688.jpg)

华为座谈会没去，吃饭坐地铁回家，晚上开摆。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210214254658-1043271749.jpg)

# 12.10 正式

7:50 起床坐车，830 之前到了。

发了三个原神玩偶（opssw）和定胜糕。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210221346981-1103386978.png)

题目简评：

A：毒瘤大模拟，感谢 cmk 在封榜期间调完。

B：NTT+模棱两可好题，但是为什么他们都是 bitset 过的？火大。

C：平面图最短路啥的，不懂。

D：我想出来的，赛后听构造一模一样，赢！

E：我想出来的，赛后听做法一模一样，赢！

F：类似树上圆理论的东西被 cyb 一眼丁假，所以胡了树剖+线段树合并 2log 写写写，无果，正解说只要判虚树直径两端即可，cyb全责。

G：贪吃蛇题，我想到蛇初始位置最短路只要 ckmax 就行了，赢！

H：基环树期望题，没看过题，不是我写的。

I：带修循环网格图随机游走题，听题解说消元啥的，不懂。

J：听说是签到交互，反正cmk挂了挺多发的。

K：胡了一个 2log 做法（官方 1log）不过由于我在写 F 所以没时间实现这道题了，也不知道真不真。

L：应该是非常好 geo 题，一开始想了个错做法，还好憋着后发现是假的了，不过还是浪费了一点思考时间。

M：cmk写的签到题，wa了不少发，诋毁。

带的板子只用到了我的头文件和ntt板子。

打印代码的操作第一次用，感觉很新奇。

中饭在赛时吃的发的kfc，香。

比赛结束，鼓掌。

由于中学组前五颁奖，不出意外我们队和海上星亮晶晶队（海亮）争第五。

杭师大派了一些人跳舞，还行，但是我们在 poker 启动。（读博读的/cf）

浙大一个命题人讲题解，巨快。

滚榜时刻，奇葩队名大展光彩。

面到了 konata 带着海亮，其中一个一血气球（只有这种气球是飘的）飞天了/kx，也见到了杜教、xxy。

终于以 24min 罚时的优势战胜海上星亮晶晶。

~~我们是贯君！权求手痛！~~

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210214951500-1417013778.jpg)

膜膜膜 remakers。

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210220916118-579429718.png)

吃了晚饭坐地铁，结束了。

# after

[榜](https://board.xcpcio.com/icpc/48th/hangzhou)

[官方相册](https://y.camera360.com/photolivepc/?orderId=202311230817189988&amp;channel=h5&amp;origin=qrcode)

写题数：cmk：4，cyb：0，我：4

打捞的一些东西：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231210224527955-2056071924.jpg)

# 部分题解

## L

本文做法就是官方做法，但是官方做法细节没说清楚（还真是）。

由于想过好多种做法，最后还向出题组请教了一下做法，所以直接说最终做法好了。

* * *

用官方题解选基准线段（以下称为 base）的思路，当 base 被删除时选取目前线段集合内最晚被删除的线段作为新的 base 重构数据结构即可。

我们将每条边定向，使得（若形成凸包）逆时针旋转。

关于 base 定向的问题：对两种定向分别判断答案，最终答案就是对应位置的或。

非 base 线段的定向，我们一定可以通过 base 来唯一确定她的方向（或者直接判决加入这条边后不可能形成凸包，那我们随意定向即可）。

将线段极角排序后只需要判断每条边（按极角循环的）前驱后继是否都被该有向线段的左边闭集半平面完全包含即可，除了两条同方向共线的有向线段会出问题（下图绿色极角排序排在红色前就会被认为是合法的）：

![](https://img2023.cnblogs.com/blog/2213867/202312/2213867-20231212231809694-226226629.png)


将每条有向线段拆成两条，分别染红、蓝。极极角排序时若极角相同则红色在蓝色之前，同为红色则按线段起始位置升序，同为蓝色则按线段结束位置升序（正方向为该有向线段方向）。这样我们成功规避掉了上述的问题（保证每个共线的线段集合都以最小起点开头，最大结尾结束）（曾想过的两废案：对每个直线维护每个时刻的左右两个端点，把在这条直线上的所有线段等价于一条线段，由此重构操作序列；将被包含的线段忽略）。

由于开头所说的做法大杂烩，所以代码比较不好看，也懒得改。

复杂度大常数单 $\log$。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17930472.html</id>
    <title type="text">Top Tree 学习存档-ShaoJia</title>
    <summary type="html"></summary>
    <published>2023-12-27T06:26:00Z</published>
    <updated>2023-12-27T06:26:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17930472.html" />
    <content type="text">[Top Tree学习笔记 - zjy0001 的博客 - 洛谷博客](https://www.luogu.com.cn/blog/zjy0001/top-tree-xue-xi-bi-ji)

[P10012 [集训队互测 2023] 落日珊瑚 - 洛谷 ](https://www.luogu.com.cn/problem/P10012)

[[NOI2022] 树上邻域数点 题解 - Elegia - 洛谷博客 ](https://www.luogu.com.cn/blog/EntropyIncreaser/noi2022-count-analysis)

[Top Tree - OI Wiki ](https://oi-wiki.org/ds/top-tree/)

[noip退役选手的another扯淡Top tree 相关东西的理论、用法和实现 - negiizhao的博客](https://negiizhao.blog.uoj.ac/blog/4912)

2023 年集训队论文 - 浅谈静态 Top Tree 在树和广义串并联图上的应用 - 程思元

[P5649 Sone1](https://www.luogu.com.cn/problem/P5649)

[我的 Sone1 提交](https://www.luogu.com.cn/record/141120055)

我写的大抵是 SATT 吧，实现上其实就是将 LCT 一个点的所有虚儿子再用 Splay 树维护。但是这种结构似乎和簇收缩对应不上，目前我的看法是至多算相似（将虚儿子 Rake 后实链 Compress）。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17950024.html</id>
    <title type="text">[ABC335*] 题解-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-06T18:10:00Z</published>
    <updated>2024-01-06T18:10:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17950024.html" />
    <content type="text"># A

末位改成 `'4'`。

# B

dfs。

# C

记录每个时刻龙头的位置，查表。

# D

将龙盘起来即可。

# E

每个点记录 $1$ 到她的答案 $f_i$。

每种值同时转移，每个值相同连通块的 $f$ 全赋为块内 $\max f$，然后枚举出边转移到值更大的点。

# F

根号分治，典。

# G

想到离散对数不要直接觉得要用 HDU 的求离散对数科技，事实上，这道题只需要知道每个 $a_i$ 在模 $P$ 意义下的 $\text{ord}$ 即可。

这个也是典（但是我之前不太会）：求出 $P-1$ 的所有素因数，不断尝试将 $\text{ord}$ 除以每个素因数即可。（复杂度双 $\log$）

然后变成每个素因子开一维，非严格偏序对计数了。将 $P-1$ 的所有因子存入 map，然后在这上面做狄利克雷前缀和。

[Code](https://atcoder.jp/contests/abc335/submissions/49129894)</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17953654.html</id>
    <title type="text">2024sol1-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-09T01:30:00Z</published>
    <updated>2024-01-09T01:30:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17953654.html" />
    <content type="text"># CF1172C2 Nauuo and Pictures (hard version)

把笋便爆了，开心（

考虑计算最后 $\sum w$ 的期望，DP：在看了 $i+j$ 张照片时，喜欢的照片看了 $i$ 次，不喜欢的照片看了 $j$ 次的概率，可以 $O(m^2)$ 得出每个 $dp_{i,j}$。

关键的性质是：**喜欢照片的权值增量的期望与照片的原权值成正比，不喜欢照片的权值减少量同理。**

这样通过 DP 值得出【喜欢照片权值增量总和期望】和【不喜欢照片权值减少量总和期望】后每张照片直接算即可。

复杂度 $O(n+m^2)$，好像带逆元的 $\log$。

关键性质证明：

将每单位权值看作一个球，设共有 $n$ 个球，增量总和 / 减少量总和为 $m$。

* 减少：$\binom{n}{m}$ 种取 $m$ 个球的方式都是等概率的，每个球被取走的概率都是 $m/n$。
* 增加：给 $n$ 个球染上 $n$ 种不同的颜色，增量为 $m$ 等价于 $m$ 轮这样的过程：在现有的球中等概率随机选一个球，新增一个和选定球颜色相同的球。发现每种颜色都是等价的，所以每个照片最后期望和初始球数成正比。

# CF884F Anti-Palindromize

我是网络流&amp;贪心小师。

贪心：对称相同的取 $b_i$ 较小的剥离，若剥离的无主元素轮换一定可行，否则要找【主元素个数 $\times 2-$ 总剥离个数】个均不等于主元素的对称不相同 pair，分别取 $b_i$ 较小的再取前这么多小的剥离即可。

流：每对对称的点建点 $p_i$，从源点向其连边 $(2,0)$，每种字符建点 $c_i$，向汇点连边 $(cnt_i,0)$（$cnt$ 为该字符出现次数），$p_i\to c_j$ 连边 $(1,\Delta_{i,j})$，其中
$$
\Delta_{i,j}=\begin{cases}
\max(b_i,b_{n+1-i})&amp;,s_i=c_j=s_{n+1-i}
\\
b_i &amp;,s_i=c_j\ne s_{n+1-i}
\\
b_{n+1-i} &amp;,s_i\ne c_j= s_{n+1-i}
\\
0 &amp;,s_i\ne c_j\ne s_{n+1-i}
\end{cases}
$$
跑最大费用最大流，费用即为答案。

建图妙点：每对位置向每个字符连边容量为 $1$，保证每对位置的字符不同。

# CF1677D Tokitsukaze and Permutations

一次冒泡排序对排列 $a$ 的 $v_i=\sum_{j=1}^{i-1}[a_j&gt;a_i]$ 的影响是：
* 先将 $v$ 整体左移一位，最右的那个空补 $0$。
* 将所有 $v_i\leftarrow \max(v_i-1,0)$。

原因是前缀最大值的子序列整体往右移动一步，每个非前缀最大值的位置左边比她大的个数少 $1$。

# P10004 [集训队互测 2023] Permutation Counting 2

依照 P5825 排列计数 的容斥思路。

我们将排列画在二维平面上，容斥横坐标划分成 $i$ 个非空下降段、纵坐标划分成 $j$ 个。观察发现如果知道了 $i\times j$ 每个区域有多少点，则我们可以唯一构造出排列。

所以这部分方案数为 $\binom{ij-1+n}{n}$。

然后我们对两维分别做每行 / 列均非空的限制，复杂度 $O(n^3)$。

然后再容斥上升，这部分是二项式反演（做的时候式子反演不会，本质上是数组下标反转，但是我直接声称除了 $(-1)^{\dots}$ 的系数其他高度对称，直接凑出来了），复杂度也是 $O(n^3)$。

# CF1838F Stuck Conveyor

分别问下图黑色（蛇形）：

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240109103418047-154724811.png)

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240109102735530-975066274.png)
（可以观察此图的红色箭头思考：哪些位置、方向的卡住传送带是被排除的）

若两者中存在不是正常（位置）结束且不是环，则我们立马知道哪个传送带卡住（及方向）并抛出快递了。

否则，两者必然存在恰一个图是环，不妨设是第一个。

我们按蛇形依次存下 $n^2$ 个位置，最后形成的环的 dfn 最大点一定是卡住的传送带，直接在这个序列上二分出 dfn 最大的形成环的位置，就是答案位置。

然后通过一次询问得出其卡住的方向：

![](https://img2024.cnblogs.com/blog/2213867/202401/2213867-20240109103427674-1132086404.png)

# P10045 [CCPC 2023 北京市赛] 线段树

cxy 题（

这题大概可以扩展到加的数为 $p$ 的倍数（不是的话维护 $p$ 个多项式行不行啊）、区间乘积模 $p^k$ 的答案，复杂度 $O(n p k^2\log n)$。

线段树每个节点维护区间乘积关于加的数 $x$ 的函数 $f(x)$，我们只要保留低 $k$ 项的系数即可。

pushup 即多项式乘法，所以上述复杂度可以 $k^2\to k\log k$，但意义不大。

pushdown / tag 时将 $f(x)$ 变为 $g(x)=f(x+c)$，每项暴力二项式展开即可，大概也可以卷积优化？不懂。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17956329.html</id>
    <title type="text">[EGOI2023]-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-10T05:50:00Z</published>
    <updated>2024-01-10T05:50:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17956329.html" />
    <content type="text">[Luogu](https://www.luogu.com.cn/problem/list?tag=394%7C60&amp;page=1)

[KATTIS](https://open.kattis.com/problem-sources/European%20Girls%27%20Olympiad%20in%20Informatics%202023)

## D1

### Inflation / 通货膨胀

煎蛋。

### Padel Prize Pursuit / 追梦笼式网球

将抢奖牌的过程看作有根森林（有点 Kruskal 重构树的味道），从根出发 dfs 维护众数即可（注意每条边的权重为持有的时间长度），复杂度线性。

### Find the Box / 找箱子

模拟赛题解给的做法有点不高妙（左右位置分类啥的），直接看 [Hanghang 的题解](https://www.luogu.com.cn/blog/178992/P9465)，大概就是找到一种可以循环的操作使得已经撞到箱子的状态都会通过撞箱子限制移动，而没撞的可以移动。

AC代码：

&lt;details&gt;
&lt;summary&gt;点击查看代码&lt;/summary&gt;

```cpp
// Problem: Luogu P9465 [EGOI2023] Find the Box / 找箱子（暂无数据）
// Url: https://www.luogu.com.cn/problem/P9465
// T/M Limit: ms MB
// Time: 2024-01-10 13:24:44
// Author: ShaoJia

// #pragma GCC optimize("Ofast")
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&lt;=Ii##_;Ii++)
#define per(Ii,Jj,Kk) for(int Ii=(Jj),Ii##_=(Kk);Ii&gt;=Ii##_;Ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef long double db;
#define fir first
#define sec second
#define pb push_back
#define eb emplace_back
#define siz(Aa) ((int)(Aa).size())
#define all(Aa) (Aa).begin(),(Aa).end()
#define ckmx(Aa,Bb) (Aa=max(Aa,Bb))
#define ckmn(Aa,Bb) (Aa=min(Aa,Bb))

int n,m;
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
    cin&gt;&gt;n&gt;&gt;m;
    cout&lt;&lt;"? "&lt;&lt;string(n-1,'v')&lt;&lt;string(m-1,'&gt;')&lt;&lt;endl;
    int x,y;
    cin&gt;&gt;x&gt;&gt;y;
    if(x!=n-1){
    	cout&lt;&lt;"! "&lt;&lt;x+1&lt;&lt;" 0"&lt;&lt;endl;
    	return 0;
    }
    if(y!=m-1){
    	cout&lt;&lt;"! "&lt;&lt;n-1&lt;&lt;" "&lt;&lt;y+1&lt;&lt;endl;
    	return 0;
    }
    cout&lt;&lt;"? ";
    rep(i,1,m-1){
    	cout&lt;&lt;string(n-1,'v')&lt;&lt;"&gt;"&lt;&lt;string(n-1,'^')&lt;&lt;"&lt;^&gt;";
    }
    cout&lt;&lt;endl;
    cin&gt;&gt;x&gt;&gt;y;
    cout&lt;&lt;"! "&lt;&lt;x&lt;&lt;" "&lt;&lt;y+1&lt;&lt;endl;
return 0;}
/*
*/
```
&lt;/details&gt;

### Bikes vs Cars / 骑车与汽车

将 $c_{i,j}$ 的限制改为 $a_{i,j}:=W-c_{i,j}$，这样每条边权设为自行车宽度则构造要满足：
* $i,j$ 之间的最小瓶颈路 $=a_{i,j}$。
* $i,j$ 之间的最大瓶颈路 $=b_{i,j}$。

考虑我们最终求出来一个合法的图，在 $i,j$ 之间添加任意边权 $\in[a_{i,j},b_{i,j}]$ 的边不会让图不合法。

而且发现 $i,j$ 之间（若存在边）边权 $\notin[a_{i,j},b_{i,j}]$ 则直接不合法了。

所以每两个点之间就保留这个区间内的权值的边，若此图不合法原问题就无解。

但是边数爆表了，首先我们发现当 $a_{i,j}\le b_{i,j}$ 时保留 $a_{i,j},b_{i,j}$ 两条边即可。

此时边数还是 $O(n^2)$ 级别，将保留的 $a$ 边跑最小生成树、$b$ 边跑最大生成树即可，边数至多 $2n-2$。

由于复杂度无所谓，最后用 Floyd 判合法即可。

## D2

###	Carnival General / 狂欢节总管

顺序加入人，由于至少有一半存在的人是友好的，所以一定能找位置站，模拟即可。

### Candy / 糖果

###	Sopsug / 垃圾处理

### Guessing Game / 猜猜看</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17965407.html</id>
    <title type="text">2023 EC Final 游记（搬自wsy的blog）-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-15T07:09:00Z</published>
    <updated>2024-01-15T07:09:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17965407.html" />
    <content type="text">
12.27 LJ 给 ShaoJia 发 QQ 说让我们组个队去打 EC Final，真没想到这都能去。


前情提要：


* 队名 srekamer。
* 队友 ShaoJia，cmk666。
* 比赛地点上海大学。
* 杭二另一个队是 remakers（你猜为啥我们的队名是这个），队员是 cxy，5ab 和 Pointy。




---


其实在 EC Final 之前还没这样组过队啊，之前 ucup 队友是 cmk666 和 chengcheng，hdu 的队友是 ShaoJia 和 chengcheng，这样的组队还是第一次。


之前线下 ICPC 也只打过杭州站一次，当时队友是 lzytag 和 zjy，虽然对于赛制和 DOM Judge 还是比较熟悉的，但是磨合度确实没底，但是就觉得有可能 $1+1+1&lt;1$ 了，毕竟只有一台电脑，时间分配冲突很难受。


ICPC 杭州的时候是 ShaoJia，cmk666 和 cyb1010 组的队，但是由于 $4+4+0$，所以 cyb 被优化了（心疼 cyb 1.14s，感恩 cyb 5.14s）。


但反正就当图一乐了，也就没多准备（杭州站之前是不是还按队形 vp 了几场来着，这下就补了近两年的 EC Final 题）。




---


定了 1.12 上午的火车，早上提早了好久到站，15A 检票口好多到上海虹桥的火车，差点以为自己迟到了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240114233723212-1780268739.png)


50min 就到上海了，很快啊，但是地铁得做 1h，属实是逆天。上海地铁还不报站名，差点做过站了。地铁电视的像素极低，还是条状闪烁的，感觉在玩恐怖游戏。


地铁上点了六人份的 KFC，才 212RMB，感觉比杭州的 KFC 便宜不少，甚至吃饱了。某个姓笋的只给我转了 0.36RMB，素质非常不高，声称是微信支付自动给他加了个小数点（）。


酒店离地铁站不远，但是到酒店已经 12:50 左右了，由于约定好 13:00 要到学校去参观什么展览，所以没时间办理入住了，先寄存了个行李就跑去地铁站了，到上海大学差不多 13:20 了，迟到了 20min。


到了那边白嫖了一车免费物资，一件 EC Final 的羽绒黑马甲，一个 Jane Street 的布袋子，一个华为的超大号保温杯，一个小玩偶（你别说还挺可爱的），一本 Jane Street 的绿本子，一个键盘（真就一个键），一个华为的黄色背包，一车企业的宣传贴纸，还有一本参赛手册（感谢金主爸爸的无私馈赠）。每个人还发了一张价值 100RMB 的校内通用饭卡。


接下来本来是要去参观上海大学的一个三星堆 + 罗丹文物展览的，后来被几个计算机学院的老师抓住了，被迫去参观了一下他们的学院（感觉呵呵）。


志愿者：你们 cf rating 多少啊？我：（指着 cmk）这个人 *2700，这（没说完）……。志愿者：这么高，你这比我们学校最高的还高。


参观完他们学院就没什么时间了，15:00 还要去比赛场地热身赛，于是随便看了一圈就润了，比较有一个的是一个文物上的人物名字是 python（）。


15:00 匆忙赶到了体育馆，本来以为试机要迟到了，没想到里面竟然没什么人，一问才知道因为大家都还没到，所以开始时间延迟了半个小时，这下这下了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115121052864-1525916921.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115121216413-315388526.jpg)


↑ 从上图中找到杭州第二中学。


机位有点挤，不过勉强能坐下，开始之后不到半个小时 remakers 就穿了，我们一个小时也被队友切穿了，其他也没什么事，于是我们六个人提前离场，地铁回了宾馆，办了一下入住，室友是 ShaoJia。


这个酒店得好好吐槽一下：


1. 订酒店的时候标注了无窗，当时觉得住自闭室和普通房间差别不大，就没多关注。本以为只是看不到外面的风景了，结果中央空调是全酒店开的，根本关不掉，房间里和桑拿房一样，楼下几位甚至还要了电风扇（你家大冬天开电风扇是吧）。
2. 二楼可能是好的，但我们五楼的房间门口连灯的开关都没有，只有一个类似于电源控制屏的东西，按一下电源整个房间都黑了，和玩鬼屋似的。最后问了一下保洁阿姨，发现要喊小度来开灯，这种设计你前台也不和我说一下是吧。
3. 这个床头的阅读灯不能在其他灯打开的时候打开，一开始还以为这个灯坏了，ShaoJia 把灯拧了下来查看电线的连接情况，然后装不回去了，，。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115000450645-1829931432.png)


最后的结果是提前了一天退房（本来 1.16 中午回杭州的，为了少住一晚改签到了 1.15 晚上）。


晚上 5ab 找了一个旁边的本帮菜餐馆吃饭，吃的还可以，环境不太行，没有包厢所以大厅里全是烟味，有一点小贵，总价大概 750+，人均消费 128RMB，cxy：感觉不如食堂的 20RMB，5ab：都出来了不得吃点好的？


晚上本来要看 A-Soul 直播的，突然发现板子没打印，字典也没带，和 ShaoJia 紧急抢救了一下，在酒店楼下有偿打印了一份，价格 10RMB，有点亏，A-Soul 直播也只能鸽了。


晚上不想睡觉，ShaoJia 推荐了一款音游 Dancing Lines，很经典的音游，非常容易上手，就是广告有点多。感觉比 phigros 更容易玩一些，毕竟一只手就行，车上都能玩。


睡眠质量还行。




---


由于比赛很晚开始，所以起的很晚，酒店的早餐中规中矩，毕竟这个价格不能要求太多，然后赶往比赛现场。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125352779-411432170.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125417219-579617097.jpg)


领导讲话的时候一直在 Dancing Lines，消磨时间挺好用的，11 点开始比赛。赛前约定了不开 geometry。


开场后 ShaoJia 和 cmk666 随即开题，我先敲头。cmk 一下就把 B 秒了。K 我一眼丁真了上一场 CF 的 F2，然后赶紧上手写，但是写挂了。队友会了 E，非常好写，但是由于没开 long long 吃了一发罚时。


构造大师 cmk 一眼丁真了 L，写写写，20min 就过了，还写了个 checker。


期间打印了一个 K 的代码，大概看出了哪里错了，等 cmk 写完了 L 上手改了一下，过了样例但还是 wa，一看又是没开 long long 惹的祸，改了一下过了。


此时 01:16:54，排名到了 rank14。


随后 ShaoJia 会了 F，但是他声称自己想得不是很清楚，感觉是时间在中午导致的，不过很快还是过了，强强强。时间 01:55:57，重新回到了 rank13。


前期题也就基本上结束了，2h 不到把前期提全部做完了，感觉很顺利。但是接下来就成了坐牢时间。


13:00 了先吃了个饭，发的中饭是一个汉堡 + 鸡柳 + 鸡块，还有一瓶可乐，伙食还行。


cmk 声称他会了交互 J，赶紧上手写，还加了一个 `assert(str == "Correct");`，但是交上去竟然是 wa，这下知道了，是超了交互次数限制。


我随便捏了一个样例，这下他才发现自己的询问次数是 $4m$ 的，这下这下了，只好把 J 先抛了。


我和 cmk 大概糊了一下 I 的做法，感觉很真，我上手写写写，写到一半发现有一个地方有些假，赶紧把在想数数的 ShaoJia 拉过来修锅，cmk 继续去修正 J。


ShaoJia 胡了一个有关众数与重心的性质，然后发现点分治就行了，我是真煞笔我测，ShaoJia 拉着 cmk 来写了个点分治，然后自己写了个点分治的处理，最后又拉我过去写了一个最终的构造，修修修终于在封榜后 04:34:20 过了，但是剩下的时间不多了。


三个人一起想了想 J，感觉还是没有前途，根本不知道限制里的 $n$ 是哪里来的，最后没过结束了，喜提 6 题。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115122816037-670079758.png)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115122831070-1118819190.png)


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125453694-833777026.jpg)


去问了一下 Remakers，也寄了，两个队都没过被过穿了的 J，杭二机房水平有限啊。那边比我们多过一个 C 数数，喜提 7 题。


后来去找了一下呆呆鸟，听 wxw 报了一下 J 的做法，感觉很 naive，但是为啥没想到啊！！！火大！！！


### **算了，菜就多练，输不起，就别玩。**


由于题还没公开，所以有关题目的具体细节和做法就不透露了。


Pointy 还被抓去采访了，素质非常差的 Pointy 直接把采访的任务推给了 cxy。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125557831-2087144007.jpg)


比赛结束后在上海大学食堂里随便吃了一点晚饭，点的有点多，没吃完。金主爸爸的讲座根本没人听，难绷。


EC Final 都炸了，不如直接旅游启动了。晚上组了一个陈老师旅游团，和 cxy，ShaoJia，Pointy 外滩旅游启动了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125644933-701626777.png)


先做了将近一个小时地铁前往陆家嘴，跟着陈导去了东方明珠塔，本来想进去看看的，但是发现票价 199RMB，而且 21:00 就关门了，于是没有爆金币，在塔底拍了几张照片就润了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125815420-1636512587.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115125832801-335302814.png)


陆家嘴这边似乎没什么好玩的了，做了个地铁过江到了外滩，听说这边有一车古建筑，然后发现有一个古建筑还在修，这下蚌埠住了。这些建筑好像基本上都是银行，这是为什么呢。


这边的路名都是以中国的各个省份命名的，来了一趟外滩就当是走遍了全国。


剩下的放点图片吧，感觉没什么好写的了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130538269-1877961812.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130047556-555232028.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130058564-1412450628.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130110038-1084260462.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130119521-413257822.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130122974-2082530286.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130132878-1816135242.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130138433-140367930.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130142857-427491208.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130610668-19861041.png)


手机和摄影技术都不太行，大家就当看个乐子吧。一路走下来腿都麻了，地铁直接回了酒店。


本来说要打 CF 的，但是后来鸽了，直接亚洲杯启动，某位卷皮室友 ShaoJia 还在打 CF，真是受不了了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115130510555-1794911727.jpg)


第二天（准确来说应该已经是当天了）还有华为挑战赛，但是还是熬到了将近 1 点才睡，这下彻底疯狂了。




---


早起，睡眠严重不足，头很晕，吃了个早餐就赶往上海大学了。


挑战赛的题目很怪，A 题写了个标准了 baseline，拿了 60000+ 分，当时瞬间登顶，开始优化，但是发现怎么优化怎么分低，真是难绷。看到 B 题 ShaoJia 和 5ab 都在很高的名次，赛后问了一下 5ab 发现是 `#pragma GCC optimize("unroll-loops")` 基础练习题，这下难绷了。


最后一分钟还在 rank99，结束后掉出了 sub100 到了 rank102，-1000RMB，亏麻了。


ShaoJia 和 5ab 喜提 3k，cxy 和 cmk666 喜提 2k，Pointy 喜提 1k，就我 0RMB /ll /dk。B 题怎么还能有科学计数法输入的，我一个乖乖找小数点输入的直接被爆了。


下午闭幕式，看了好多文艺表演，为啥上海大学全都是外国友人啊，原来，你早就是一个________了。


滚榜，发现封榜后一车队把 J 过了，这下受不了一点了，怄火，怄火，怄火！


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115131452110-1735801695.png)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115133616863-163499725.png)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115133631321-1076196835.png)


华为挑战赛颁奖，两个题的 rank1 都是杭二爷，这就是杭二带给我的自信！一人 +3w。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115131613672-280349841.jpg)


晚上金主爸爸华为包了几十辆大巴车把我们送去陆家嘴正大广场华为之夜，有点壮观的。抽奖还会抽 10 个 huawei pad 和 2 个 mate60，可惜我们要赶火车就没法抽了，随便吃了一点就赶去火车站。


出去的时候还下雨了，没带雨伞，只好“淋雨一直走”了。


![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115132024877-1584749669.png)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115132113737-1978086015.jpg)  

![](https://img2024.cnblogs.com/blog/2286803/202401/2286803-20240115132120872-1556886225.jpg)


上海，再见！遗憾，留给下次再来弥补！




---


感谢一路上陪我走来的同学与朋友们。  

感谢华为，Jane Street，JetBrains 等公司提供的白嫖礼包。  

感谢上海大学与 EC Final 组委会。  

感谢中国国家铁路集团有限公司，上海地铁。  

**感谢桔子水晶上海大华沪太路酒店提供的逆天房间。**




---


附上一些视频的链接：


[比赛录播](https://www.bilibili.com/video/BV1RT4y1n7w1)，[闭幕式录播](https://www.bilibili.com/video/BV1ma4y1C7xf)，[滚榜录播](https://www.bilibili.com/video/BV14L411Q7gq)。
</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17975346.html</id>
    <title type="text">SNOI2024-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-19T10:35:00Z</published>
    <updated>2024-01-19T10:35:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17975346.html" />
    <content type="text"># P10063 [SNOI2024] 平方数

唐完了。

关键性质：在模素数意义下非二次剩余看作 $-1$，二次剩余看作 $1$ 作乘积是对的（e.g. 两个非二次剩余乘起来一定是二次剩余）。

取 $k$ 个 $10^5$ 左右的素数，序列每个数判断在 $k$ 个同余系中是否是二次剩余（不是为 $1$ 是为 $0$），压成 `unsigned long long` 后直接判区间异或和是否为 $0$ 即可。

但序列里的数存在 $k$ 个素数之一的倍数会寄，我们再开一个 `unsigned long long` 存序列每个数 $k$ 个素数作为因子的指数奇偶性，还是判异或为 $0$。

取 $k=40$ 能兼顾正确率和时间，正确率不会分析。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/17988340.html</id>
    <title type="text">PKUWC2024 游记-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-01-25T14:25:00Z</published>
    <updated>2024-01-25T14:25:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/17988340.html" />
    <content type="text">有点不太想写游记。

重庆火锅的辣是真的有点太厉害了。

八一路买了 80r 的钵钵鸡+长沙臭豆腐（我来重庆吃啥长沙特产），一点都没吃饱，最后楼下乡村基吃了 25r 彻底饱了，被宰了/dk。果然网红景点不能去。

pkuwc: 151+255

wc:100+100+5</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/18023217.html</id>
    <title type="text">伯努利数-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-02-20T07:24:00Z</published>
    <updated>2024-02-20T07:24:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/18023217.html" />
    <content type="text">[OI-wiki](https://oi-wiki.org/math/combinatorics/bernoulli/)

递推式是由 $S_m(1)(m&gt;0)$ 的展开得到的。</content>
  </entry>
  <entry>
    <id>https://www.cnblogs.com/shaojia/p/18037772.html</id>
    <title type="text">如何获取cookie：以洛谷为例-ShaoJia</title>
    <summary type="html"></summary>
    <published>2024-02-27T11:56:00Z</published>
    <updated>2024-02-27T11:56:00Z</updated>
    <author>
      <name>ShaoJia</name>
      <uri>https://www.cnblogs.com/shaojia</uri>
    </author>
    <link rel="alternate" href="https://www.cnblogs.com/shaojia/p/18037772.html" />
    <content type="text">需要 PC 操作，在洛谷首页按下 F12，找到「应用程序」（Edge） 或 「Application」（Chrome）或「存储」（FireFox），在左侧的「Cookie」中找到展开 「www.luogu.com.cn」中的「__client_id」和「_uid」的值。</content>
  </entry>
</feed>